<html><head><meta charset="utf-8"/><title>范畴论笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>范畴论笔记</h1><h2>第1章 范畴</h2><h3>第1.1节 引入</h3><p>范畴论在某种意义上可以被视为<em>函数的代数学</em>.</p><h3>第1.2节 集合的函数</h3><p>令<math><mi>f</mi></math>是从集合<math><mi>A</mi></math>到集合<math><mi>B</mi></math>的函数, 记为<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>. 若用<math><mrow><mi>range</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>表示<math><mi>f</mi></math>的值域, 那么<math><mrow><mrow><mi>range</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>B</mi></mrow></math>. 现在设我们还有一个函数<math><mrow><mi>g</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>, 那么我们可以构造复合<math><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>, 其由<math display="block"><mrow><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>,</mo><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></mrow></math>给定. 函数复合<math><mo>&compfn;</mo></math>是结合性的, 即若再有一个函数<math><mrow><mi>h</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>, 那么<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>h</mi><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>这里的函数相等显然是外延相等 (体现为逐点的函数值相等), 即对于每个<math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>有<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>对于任意的集合<math><mi>A</mi></math>, 存在一个恒等函数<math><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>, 其由<math><mrow><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>a</mi></mrow></math>定义. 恒等函数在某种意义上是函数复合<math><mo>&compfn;</mo></math>的单位元, 即<math display="block"><mrow><mrow><mi>f</mi><mo>&compfn;</mo><msub><mn>1</mn><mi>A</mi></msub></mrow><mo>=</mo><mrow><msub><mn>1</mn><mi>B</mi></msub><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mi>f</mi></mrow><mtext>.</mtext></math>对于函数的概念进行抽象或许提供了定义范畴的动机.</p><h3>第1.3节 范畴的定义</h3><div class="definition"><b>定义1.1.</b> 一个<em>范畴</em>由以下资料构成:<ul><li>对象: <math><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi><mo>,</mo><mo>&hellip;</mo></mrow></math></li><li>箭头: <math><mrow><mi>f</mi><mo>,</mo><mi>g</mi><mo>,</mo><mi>h</mi><mo>,</mo><mo>&hellip;</mo></mrow></math></li><li>对于每个箭头<math><mi>f</mi></math>, 存在两个(箭头所内蕴的)对象<math display="block"><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mtext>和</mtext><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></math>其被称为<math><mi>f</mi></math>的定义域 (domain) 和陪域 (codomain). 我们记<math display="block"><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>以指明<math><mrow><mi>A</mi><mo>=</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>和<math><mrow><mi>B</mi><mo>=</mo><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li><li>给定箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>和<math><mrow><mi>g</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>, 即<math display="block"><mrow><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>dom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>存在与之对应的箭头<math display="block"><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>其被称为<math><mi>f</mi></math>和<math><mi>g</mi></math>的复合.</li><li>对于每个对象<math><mi>A</mi></math>, 存在与之对应的箭头<math display="block"><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>其被称为<math><mi>A</mi></math>的恒等箭头.</li></ul>以上这些资料需要满足以下法则.<ul><li>结合律: 对于所有的<math><mrow><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow><mo>,</mo><mrow><mi>g</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow><mo>,</mo><mrow><mi>h</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></mrow></math>有<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>h</mi><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math></li><li>单位元: 对于所有的<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>有<math display="block"><mrow><mrow><mi>f</mi><mo>&compfn;</mo><msub><mn>1</mn><mi>A</mi></msub></mrow><mo>=</mo><mrow><msub><mn>1</mn><mi>B</mi></msub><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mi>f</mi></mrow><mtext>.</mtext></math></li></ul></div><p>范畴的定义是全然抽象的, 对象不必是集合, 箭头不必是函数.</p><h3>第1.4节 范畴的例子</h3><ol><li></li><li>另外一类在数学中常见的例子是<em>带结构集合</em>的范畴, 即带有结构的集合和保持结构的函数, 这些概念在某种意义上是以相对独立的方式确定的. 读者可能熟悉的例子有<ul><li>群和群同态;</li><li>向量空间和线性映射;</li><li>图和图同态;</li><li>实数域<math><mi>&Ropf;</mi></math>和连续函数<math><mrow><mi>&Ropf;</mi><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></math>;</li><li>开集<math><mrow><mi>U</mi><mo>&sube;</mo><mi>&Ropf;</mi></mrow></math>和定义于其间的连续函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>U</mi><mo>&rarr;</mo><mrow><mi>V</mi><mo>&sube;</mo><mi>&Ropf;</mi></mrow></mrow></mrow></math>;</li><li>拓扑空间和连续映射;</li><li>可微流形和光滑映射;</li><li>自然数集<math><mi>&Nopf;</mi></math>和递归函数<math><mrow><mi>&Nopf;</mi><mo>&rarr;</mo><mi>&Nopf;</mi></mrow></math>, 或者也可以像上面的连续函数的例子一样取定义于子集<math><mrow><mi>U</mi><mo>&sube;</mo><mi>&Nopf;</mi></mrow></math>上的部分递归函数;</li><li>偏序集和单调函数.</li></ul>如果你不熟悉其中某些例子, 也不要紧张. 之后我们将更仔细地检视其中一些. 暂时, 让我们讨论一下以上例子中的最后一个.</li><li>偏序集即装备了偏序关系的集合, 偏序集之间的箭头即单调映射. 如果<math display="block"><mrow><mi>m</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>是一个从偏序集<math><mi>A</mi></math>到偏序集<math><mi>B</mi></math>之间的单调映射, 那么<math display="block"><mrow><mrow><mrow><mi>a</mi><msub><mo>&le;</mo><mi>A</mi></msub><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>m</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&le;</mo><mi>B</mi></msub><mrow><mi>m</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo>,</mo><mrow><mrow><mi>a</mi><mo>,</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>A</mi></mrow></mrow><mtext>.</mtext></math>那么, 偏序集和单调映射何以成为范畴呢? 我们需要知道<math><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>是单调的, 但这是显然的, 因为<math><mrow><mrow><mi>a</mi><msub><mo>&le;</mo><mi>A</mi></msub><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mi>a</mi><msub><mo>&le;</mo><mi>A</mi></msub><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></mrow></math>. 我们也需要知道如果<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>和<math><mrow><mi>g</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>是单调的, 那么<math><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>是单调的. 这当然也是成立的, 因为<math display="block"><mrow><mrow><mi>a</mi><mo>&le;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&Implies;</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>&Implies;</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&le;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mtext>.</mtext></math>因此, 我们有由偏序集和单调函数构成的范畴<math><mi mathvariant="bold">Pos</mi></math>.</li><li>到目前为止我们已经考虑了的范畴是所谓<em>具体范畴</em>的例子. 不严格地说, 这些范畴的对象是可能装备有某种结构的集合, 而箭头是特定的函数, 比如说保持结构的函数. 我们将在之后看到这个概念并非全然一致的, 见评注1.7. 但是, 理解范畴论的一种方式在于&quot;doing without elements&quot;, 将函数替换成箭头. 让我们现在来看看一些例子以明白这种观念并非可选, 而是基础性的.<br/>令<math><mi mathvariant="bold">Rel</mi></math>是以下范畴: 取集合为对象, 而取二元关系为箭头. 也就是说, 一个箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>是一个任意的子集<math><mrow><mi>f</mi><mo>&sube;</mo><mrow><mi>A</mi><mo>&times;</mo><mi>B</mi></mrow></mrow></math>. 集合<math><mi>A</mi></math>上的恒等箭头为恒等关系, 即<math display="block"><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>=</mo><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>a</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>A</mi><mo>&times;</mo><mi>A</mi></mrow></mrow><mo stretchy="false">|</mo><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&sube;</mo><mrow><mi>A</mi><mo>&times;</mo><mi>A</mi></mrow></mrow></mrow><mtext>.</mtext></math>给定<math><mrow><mi>R</mi><mo>&sube;</mo><mrow><mi>A</mi><mo>&times;</mo><mi>B</mi></mrow></mrow></math>和<math><mrow><mi>S</mi><mo>&sube;</mo><mrow><mi>B</mi><mo>&times;</mo><mi>C</mi></mrow></mrow></math>, 我们定义复合<math><mrow><mi>S</mi><mo>&compfn;</mo><mi>R</mi></mrow></math>为<math display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mrow><mi>S</mi><mo>&compfn;</mo><mi>R</mi></mrow></mrow><mtext>当且仅当</mtext><mrow><mo>&exist;</mo><mi>b</mi><mo lspace="0">.</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>,</mo><mi>b</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>R</mi></mrow><mo>&amp;</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>b</mi><mo>,</mo><mi>c</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><mi>S</mi></mrow></mrow></mrow><mtext>.</mtext></math>此即<math><mi>S</mi></math>和<math><mi>R</mi></math>的&quot;relative product&quot;. 我们将验证<math><mi mathvariant="bold">Rel</mi></math>在事实上是一个范畴的工作留给读者. (要做什么?)<br/>现在我们要举另一个箭头并非函数的范畴的例子, 令对象是有限集合<math><mrow><mi>A</mi><mo>,</mo><mi>B</mi><mo>,</mo><mi>C</mi></mrow></math>而箭头<math><mrow><mi>F</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>是由自然数构成的矩阵<math><mrow><mi>F</mi><mo>=</mo><msub><mrow><mo stretchy="false">(</mo><msub><mi>n</mi><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow></msub><mo stretchy="false">)</mo></mrow><mrow><mrow><mi>i</mi><mo>&lt;</mo><mi>a</mi></mrow><mo>,</mo><mrow><mi>j</mi><mo>&lt;</mo><mi>b</mi></mrow></mrow></msub></mrow></math>, 其中<math><mrow><mi>a</mi><mo>=</mo><mrow><mo stretchy="false">|</mo><mi>A</mi><mo stretchy="false">|</mo></mrow></mrow></math>且<math><mrow><mi>b</mi><mo>=</mo><mrow><mo stretchy="false">|</mo><mi>B</mi><mo stretchy="false">|</mo></mrow></mrow></math>, 这个记号的含义是集合的元素个数, 也就是基数或者说势. 箭头的复合即通常的矩阵乘法, 恒等箭头即通常的单位矩阵. 对象在这里的作用仅仅是为了确保矩阵乘法有定义, 但是矩阵并非对象之间的函数.</li><li><em>有限范畴</em><br/>当然, 范畴的对象不必是集合, 以下是一些非常简单的例子:</li></ol><div class="definition"><b>定义1.2.</b> 一个范畴<math><mi mathvariant="bold">C</mi></math>和<math><mi mathvariant="bold">D</mi></math>之间的<em>函子</em><math display="block"><mrow><mi>F</mi><mo>:</mo><mrow><mi mathvariant="bold">C</mi><mo>&rarr;</mo><mi mathvariant="bold">D</mi></mrow></mrow></math>是从对象到对象和从箭头到箭头的映射, 其满足<ol type="a"><li><math><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>:</mo><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>B</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></mrow></math>;</li><li><math><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mn>1</mn><mi>A</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mn>1</mn><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></msub></mrow></math>;</li><li><math><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>g</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&compfn;</mo><mrow><mi>F</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>.</li></ol></div><ol start="7"><li>一个<em>预序</em>是一个装备有满足自反性和传递性的二元关系的集合. 若将集合的元素视为对象, 而两个对象之间存在唯一的箭头当且仅当其满足二元关系, 则预序可以被视为范畴.</li><li></li><li>拓扑学一例: 令<math><mi>X</mi></math>是一个拓扑空间, 其开集族为<math><mrow><mi mathvariant="script">O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>. 根据包含关系进行排序, <math><mrow><mi mathvariant="script">O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>就成了一个poset category. 而且, <math><mi>X</mi></math>上我们也可以通过<em>specialization</em>定义一个预序, 即将关系<math><mrow><mi>x</mi><mo>&le;</mo><mi>y</mi></mrow></math>定义为对于每个开集<math><mrow><mi>U</mi><mo>&in;</mo><mrow><mi mathvariant="script">O</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, <math><mrow><mi>x</mi><mo>&in;</mo><mi>U</mi></mrow></math>可以推出<math><mrow><mi>y</mi><mo>&in;</mo><mi>U</mi></mrow></math>. 若<math><mi>X</mi></math>满足<math><msub><mi>T</mi><mn>1</mn></msub></math>公理, 那么这个预序只会是平凡的. 但是如果不是, 这个预序可能会是相当有趣的, 代数几何和指称语义中都有这样的空间的例子. 我们将对于以下事实的证明留作练习, <math><msub><mi>T</mi><mn>0</mn></msub></math>空间在specilization序下实际上是偏序集. [译注: 使用反证法.]</li><li>逻辑学一例: 给定一个逻辑演绎系统, 存在一个与之相关的<em>证明的范畴</em>, 其对象是公式<math display="block"><mrow><mi>&phi;</mi><mo>,</mo><mi>&psi;</mi><mo>,</mo><mo>&hellip;</mo></mrow></math>从<math><mi>&phi;</mi></math>到<math><mi>&psi;</mi></math>的箭头是从(uncanceled)假设<math><mi>&phi;</mi></math>开始的推出<math><mi>&psi;</mi></math>的一个演绎.<math display="block"><mfrac displaystyle="true"><mfrac displaystyle="true"><mi>&phi;</mi><mo>&vellip;</mo></mfrac><mi>&psi;</mi></mfrac></math>箭头的复合不过就是将演绎以显然的方式放在一起, 因而当然是结合的. 我们应该看出从<math><mi>&phi;</mi></math>到<math><mi>&psi;</mi></math>的箭头可以有很多个, 因为证明可以有很多个. 这种范畴实际上具有丰富的结构, 之后我们将和<math><mi>&lambda;</mi></math>演算一起讨论它.</li><li>计算机科学一例: 给定一个函数式编程语言<math><mi>L</mi></math>, 存在一个与之相关的范畴, 其对象是<math><mi>L</mi></math>的数据类型, 而箭头是<math><mi>L</mi></math>的可计算函数. 两个程序<math><mrow><mi>X</mi><mover><mo>&rarr;</mo><mi>f</mi></mover><mrow><mi>Y</mi><mover><mo>&rarr;</mo><mi>g</mi></mover><mi>Z</mi></mrow></mrow></math>的复合显然是将<math><mi>g</mi></math>应用于<math><mi>f</mi></math>的输出, 还有一种写法是<math display="block"><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>;</mo><mi>g</mi></mrow></mrow><mtext>.</mtext></math>恒等箭头当然是&quot;什么也不做&quot;的程序.<br/>这种范畴对于编程语言的指称语义的想法而言是基本的. 例如, 如果<math><mrow><mi mathvariant="bold">C</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></mrow></math>是我们刚才定义的范畴, 那么以Scott domain的范畴<math><mi mathvariant="bold">D</mi></math>作为解释的<math><mi>L</mi></math>的指称语义实际上不过就是一个函子<math display="block"><mrow><mi>S</mi><mo>:</mo><mrow><mrow><mi mathvariant="bold">C</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>L</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mi mathvariant="bold">D</mi></mrow></mrow></math>因为<math><mi>S</mi></math>赋予<math><mi>L</mi></math>的类型以domain, <math><mi>L</mi></math>的程序以domain之间的连续函数. 这个例子和前一个例子都和所谓的笛卡尔闭范畴 (CCC) 有关, 之后我们将讨论CCC.</li><li>令<math><mi>X</mi></math>是一个集合, 那么我们可以将<math><mi>X</mi></math>当作一个范畴<math><mrow><mi mathvariant="bold">Dis</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>, 其对象是<math><mi>X</mi></math>的元素而箭头就只有必要的恒等箭头. 这样的范畴被称为离散范畴, 实际上我们应该注意到离散范畴不过就是非常特殊的偏序集.</li><li>一个幺半群 (monoid, 偶尔会说semigroup with unit) 是一个集合<math><mi>M</mi></math>装备了一个二元运算<math><mrow><mo>&sdot;</mo><mo>:</mo><mrow><mrow><mi>M</mi><mo>&times;</mo><mi>M</mi></mrow><mo>&rarr;</mo><mi>M</mi></mrow></mrow></math>, 并且这个运算是结合的, 即对于<math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi><mo>,</mo><mi>z</mi></mrow><mo>&in;</mo><mi>M</mi></mrow></math>, 我们有<math display="block"><mrow><mrow><mi>x</mi><mo>&sdot;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>y</mi><mo>&sdot;</mo><mi>z</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>&sdot;</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&sdot;</mo><mi>z</mi></mrow></mrow></math>另外, 这个运算还有一个幺元, 即存在<math><mrow><mi>u</mi><mo>&in;</mo><mi>M</mi></mrow></math>使得对于每个<math><mrow><mi>x</mi><mo>&in;</mo><mi>M</mi></mrow></math>都有<math display="block"><mrow><mrow><mi>u</mi><mo>&sdot;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>x</mi><mo>&sdot;</mo><mi>u</mi></mrow><mo>=</mo><mi>x</mi></mrow></math>等价地说, 其实一个幺半群是一个仅有一个对象的范畴. 这个范畴的箭头是幺半群的元素. 恒等箭头即幺元<math><mi>u</mi></math>. 箭头的复合不过就是幺半群的二元运算而已.<br/>幺半群太过常见了. 例如, <math><mrow><mi>&Nopf;</mi><mo>,</mo><mi>&Qopf;</mi><mo>,</mo><mi>&Ropf;</mi></mrow></math>相对于加法是幺半群, 其幺元 (可能用加法的单位元更好) 是<math><mn>0</mn></math>, 相对于乘法也是, 其幺元是<math><mn>1</mn></math>. 另外, 对于任意的集合<math><mi>X</mi></math>, 从<math><mi>X</mi></math>到<math><mi>X</mi></math>的所有函数构成的集合, 即<math display="block"><mrow><msub><mi>Hom</mi><mi mathvariant="bold">Sets</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>X</mi><mo>,</mo><mi>X</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>在函数复合下也是一个幺半群. 更一般地, 对于任意的范畴<math><mi mathvariant="bold">C</mi></math>中的任意的对象<math><mi>C</mi></math>, 从<math><mi>C</mi></math>到<math><mi>C</mi></math>的箭头的集合<math><mrow><msub><mi>Hom</mi><mi mathvariant="bold">C</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>,</mo><mi>C</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>在范畴<math><mi mathvariant="bold">C</mi></math>的箭头复合运算下是一个幺半群.<br/>既然幺半群也是所谓的带结构的集合, 那么存在这样一个范畴<math><mi mathvariant="bold">Mon</mi></math>, 其对象是幺半群, 而箭头是保持幺半群结构的函数. 更细致地说, 从幺半群<math><mi>M</mi></math>到幺半群<math><mi>N</mi></math>的一个同态是一个函数<math><mrow><mi>h</mi><mo>:</mo><mrow><mi>M</mi><mo>&rarr;</mo><mi>N</mi></mrow></mrow></math>满足对于任意的<math><mrow><mrow><mi>m</mi><mo>,</mo><mi>n</mi></mrow><mo>&in;</mo><mi>M</mi></mrow></math>, 有<math display="block"><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>m</mi><msub><mo>&sdot;</mo><mi>M</mi></msub><mi>n</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>m</mi><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sdot;</mo><mi>N</mi></msub><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>并且<math display="block"><mrow><mrow><mi>h</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>M</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>u</mi><mi>N</mi></msub></mrow></math>我们应该观察到, 从<math><mi>M</mi></math>到<math><mi>N</mi></math>的同态可以被视为函子, 若是将<math><mi>M</mi></math>和<math><mi>N</mi></math>视为范畴. 在这种意义下, 范畴是一般化了的幺半群, 函子是一般化了的同态.</li></ol><h3>第1.5节 同构</h3><div class="definition"><b>定义1.3.</b> 在任意的集合<math><mi mathvariant="bold">C</mi></math>中, 称箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>为<em>同构</em>, 如果存在箭头<math><mrow><mi>g</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>满足<math display="block"><mrow><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><msub><mn>1</mn><mi>A</mi></msub></mrow><mtext>且</mtext><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>g</mi></mrow><mo>=</mo><msub><mn>1</mn><mi>B</mi></msub></mrow><mtext>.</mtext></math>这样的逆显然是唯一的, 我们记<math><mrow><mi>g</mi><mo>=</mo><msup><mi>f</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup></mrow></math>. 我们称<math><mi>A</mi></math>同构于<math><mi>B</mi></math>, 如果其间存在同构, 此时记<math><mrow><mi>A</mi><mo>&cong;</mo><mi>B</mi></mrow></math>.</div><div class="definition"><b>定义1.4.</b> 一个群<math><mi>G</mi></math>是一个幺半群, 并且每个元素<math><mi>g</mi></math>都有一个逆元<math><msup><mi>g</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup></math>. 换言之, <math><mi>G</mi></math>是一个只有一个对象的范畴, 并且其每个箭头都是同构. [译注: 箭头都是同构的范畴被称为群胚.]</div><p><math><mi>&Nopf;</mi></math>在加法下并非一个群, <math><mi>&Zopf;</mi></math>在加法下的确是一个群, 正有理数集合<math><msup><mi>&Qopf;</mi><mo>+</mo></msup></math>在乘法下是一个群. 对于任意的集合<math><mi>X</mi></math>, <math><mi>X</mi></math>上的所有自同构, 或者说置换, 构成了群<math><mrow><mi>Aut</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></math>. 所谓的<em>置换群</em>是子群<math><mrow><mi>G</mi><mo>&sube;</mo><mrow><mi>Aut</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>X</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 因此, <math><mi>G</mi></math>必须满足以下性质:<ol><li>恒等函数<math><msub><mn>1</mn><mi>X</mi></msub></math>在<math><mi>G</mi></math>之中.</li><li>如果<math><mrow><mrow><mi>g</mi><mo>,</mo><msup><mi>g</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>G</mi></mrow></math>, 那么<math><mrow><mrow><mi>g</mi><mo>&compfn;</mo><msup><mi>g</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>G</mi></mrow></math>.</li><li>如果<math><mrow><mi>g</mi><mo>&in;</mo><mi>G</mi></mrow></math>, 那么<math><mrow><msup><mi>g</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&in;</mo><mi>G</mi></mrow></math>.</li></ol></p><p>两个群之间的同态<math><mrow><mi>h</mi><mo>:</mo><mrow><mi>G</mi><mo>&rarr;</mo><mi>H</mi></mrow></mrow></math>实际上是幺半群的同态, 而且其也必然保持逆元运算.</p><p>以下是关于抽象群的基本的经典的结果.</p><div class="theorem"><b>定理. Cayley.</b> 每个群都同构于一个置换群.</div><div class="proof"><b>证明.</b> <ol><li>首先, 对于群<math><mi>G</mi></math>, 定义其Cayley表示<math><mover><mi>G</mi><mo>&OverBar;</mo></mover></math>为以下的集合<math><mi>G</mi></math>的一个置换群: 对于每个<math><mrow><mi>g</mi><mo>&in;</mo><mi>G</mi></mrow></math>, 我们有置换<math><mrow><mover><mi>g</mi><mo>&OverBar;</mo></mover><mo>:</mo><mrow><mi>G</mi><mo>&rarr;</mo><mi>G</mi></mrow></mrow></math>, 其定义为<math display="block"><mrow><mi>h</mi><mo>&mapsto;</mo><mrow><mi>g</mi><mo>&sdot;</mo><mi>h</mi></mrow></mrow><mtext>.</mtext></math>这的确是一个置换, 因为<math><mover><msup><mi>g</mi><mrow><mo>&minus;</mo><mn>1</mn></mrow></msup><mo>&OverBar;</mo></mover></math>是其逆.</li><li>接着, 定义同态<math><mrow><mi>i</mi><mo>:</mo><mrow><mi>G</mi><mo>&rarr;</mo><mover><mi>G</mi><mo>&OverBar;</mo></mover></mrow></mrow></math>为<math><mrow><mi>g</mi><mo>&mapsto;</mo><mover><mi>g</mi><mo>&OverBar;</mo></mover></mrow></math>, <math><mrow><mi>j</mi><mo>:</mo><mrow><mover><mi>G</mi><mo>&OverBar;</mo></mover><mo>&rarr;</mo><mi>G</mi></mrow></mrow></math>为<math><mrow><mover><mi>g</mi><mo>&OverBar;</mo></mover><mo>&mapsto;</mo><mrow><mover><mi>g</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>G</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</li><li>最后, 证明<math><mrow><mrow><mi>i</mi><mo>&compfn;</mo><mi>j</mi></mrow><mo>=</mo><msub><mn>1</mn><mover><mi>G</mi><mo>&OverBar;</mo></mover></msub></mrow></math>和<math><mrow><mrow><mi>j</mi><mo>&compfn;</mo><mi>i</mi></mrow><mo>=</mo><msub><mn>1</mn><mi>G</mi></msub></mrow></math>.</li></ol><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>Cayley定理是说任何的抽象群都可以由一个&quot;具体&quot;的置换群表示. 这个定理可以被推广为, 任何&quot;不太大&quot;的范畴都可以被表示为一个&quot;具体&quot;的范畴, 即一个由集合和函数构成的范畴. (第1.8节讨论了一些关于基础的技术细节.)</p><div class="theorem"><b>定理1.6.</b> 每个范畴<math><mi mathvariant="bold">C</mi></math>都同构于这样的一个范畴, 其对象是集合, 其箭头是函数.</div><div class="proof"><b>证明.</b> 定义<math><mi mathvariant="bold">C</mi></math>的Cayley表示<math><mover><mi mathvariant="bold">C</mi><mo>&OverBar;</mo></mover></math>为以下具体范畴:<ul><li>对象是具有形式<math display="block"><mrow><mover><mi>C</mi><mo>&OverBar;</mo></mover><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>f</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>C</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>的集合, 其中<math><mrow><mi>C</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>.</li><li>对于<math><mi mathvariant="bold">C</mi></math>中的箭头<math><mrow><mi>g</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>, 我们有一个<math><mover><mi mathvariant="bold">C</mi><mo>&OverBar;</mo></mover></math>中的箭头<math display="block"><mrow><mover><mi>g</mi><mo>&OverBar;</mo></mover><mo>:</mo><mrow><mover><mi>C</mi><mo>&OverBar;</mo></mover><mo>&rarr;</mo><mover><mi>D</mi><mo>&OverBar;</mo></mover></mrow></mrow></math>对于<math><mover><mi>C</mi><mo>&OverBar;</mo></mover></math>中的每个箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>, 我们定义<math display="block"><mrow><mrow><mover><mi>g</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow></mrow><mtext>.</mtext></math></li></ul><div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>这向我们表明了集合和函数的&quot;具体&quot;范畴的朴素概念有什么<em>错误</em>: 尽管不是每个范畴都以集合为对象而函数为箭头, 但是每个范畴都同构于一个这样的具体范畴. 因此, 这样的范畴可能具有的什么特殊性质是和范畴论无关的, 例如不以任何方式影响到箭头的对象的那些性质 (就像通过Dedekind分割或者Cauchy序列构造的实数之间的区别). 更好的捕获极其模糊的&quot;具体&quot;范畴的想法的尝试是这样的, 任意的箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>都完全由其和箭头们<math><mrow><mi>x</mi><mo>:</mo><mrow><mi>T</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>的复合确定, 这里的<math><mi>T</mi></math>是某种&quot;测试对象&quot;. 这句话的意思是若对于所有这样的<math><mi>x</mi></math>都有<math><mrow><mrow><mi>f</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>g</mi><mo>&it;</mo><mi>x</mi></mrow></mrow></math>, 那么<math><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow></math>. 之后我们将看到, 这相当于考虑由<math><mi>T</mi></math>确定的范畴的一个具体表示. </p><h3>第1.6节 范畴上的构造</h3><p>现在我们有了一些能与之打交道的范畴, 所以我们可以开始考虑一些从旧的范畴产生新的范畴的构造.</p><ol><li>两个范畴<math><mi mathvariant="bold">C</mi></math>和<math><mi mathvariant="bold">D</mi></math>的<em>积</em>, 记作<math display="block"><mrow><mi mathvariant="bold">C</mi><mo>&times;</mo><mi mathvariant="bold">D</mi></mrow></math>其对象具有形式<math><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>,</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></math>, 其中<math><mrow><mi>C</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>而<math><mrow><mi>D</mi><mo>&in;</mo><mi mathvariant="bold">D</mi></mrow></math>, 并且箭头具有形式<math display="block"><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>:</mo><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>,</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">(</mo><mrow><msup><mi>C</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>D</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>其中<math><mrow><mrow><mi>f</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><msup><mi>C</mi><mo>&prime;</mo></msup></mrow></mrow><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>而<math><mrow><mrow><mi>g</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><msup><mi>D</mi><mo>&prime;</mo></msup></mrow></mrow><mo>&in;</mo><mi mathvariant="bold">D</mi></mrow></math>. 复合是按分量定义的, 即<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>,</mo><msup><mi>g</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&compfn;</mo><mi>f</mi></mrow><mo>,</mo><mrow><msup><mi>g</mi><mo>&prime;</mo></msup><mo>&compfn;</mo><mi>g</mi></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>恒等箭头显然是<math display="block"><mrow><msub><mn>1</mn><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>,</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mn>1</mn><mi>C</mi></msub><mo>,</mo><msub><mn>1</mn><mi>D</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></math>存在两个显然的<em>投影函子</em><math display="block"><mi mathvariant="bold">C</mi><mover><mo>&larr;</mo><msub><mi>&pi;</mi><mn>1</mn></msub></mover><mrow><mi mathvariant="bold">C</mi><mo>&times;</mo><mi mathvariant="bold">D</mi></mrow><mover><mo>&rarr;</mo><msub><mi>&pi;</mi><mn>2</mn></msub></mover><mi mathvariant="bold">D</mi></math>其定义为<math><mrow><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>C</mi><mo>,</mo><mi>D</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>C</mi></mrow></math>和<math><mrow><mrow><msub><mi>&pi;</mi><mn>1</mn></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>f</mi></mrow></math>, <math><msub><mi>&pi;</mi><mn>2</mn></msub></math>的定义是类似的.<br/>若是读者熟悉群, 那么对于群<math><mi>G</mi></math>和<math><mi>H</mi></math>, 若将它们当成范畴, 则其积范畴<math><mrow><mi>G</mi><mo>&times;</mo><mi>H</mi></mrow></math>不过就是通常的群的直积.</li><li>一个范畴<math><mi mathvariant="bold">C</mi></math>的<em>反</em>范畴, 或者说对偶范畴, 其对象和<math><mi mathvariant="bold">C</mi></math>无异, 但是<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>是<math><mi mathvariant="bold">C</mi></math>中的箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>D</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>. 换言之, <math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>其实就是箭头调转方向的<math><mi mathvariant="bold">C</mi></math>.<br/>最好能有记号让我们区分<math><mi>C</mi></math>和<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的对象和箭头. 因此, 让我们对于<math><mi mathvariant="bold">C</mi></math>中的<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>记<math display="block"><mrow><msup><mi>f</mi><mo>&#8270;</mo></msup><mo>:</mo><mrow><msup><mi>D</mi><mo>&#8270;</mo></msup><mo>&rarr;</mo><msup><mi>C</mi><mo>&#8270;</mo></msup></mrow></mrow></math>这是<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的相应箭头. 以此记号, 我们可以基于<math><mi mathvariant="bold">C</mi></math>中的相应操作来定义<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的复合和单位元, 即<math display="block"><mrow><mrow><msub><mn>1</mn><msup><mi>C</mi><mo>&#8270;</mo></msup></msub><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><msub><mn>1</mn><mi>C</mi></msub><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo></msup></mrow><mo>,</mo><mrow><mrow><msup><mi>f</mi><mo>&#8270;</mo></msup><mo>&compfn;</mo><msup><mi>g</mi><mo>&#8270;</mo></msup></mrow><mo>=</mo><msup><mrow><mo stretchy="false">(</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>f</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&#8270;</mo></msup></mrow></mrow></math>数学的许多&quot;对偶&quot;定理实际上不过表达了这样的事实, 一个范畴是另一个范畴的反范畴 (或者是这个反范畴的一个子范畴). 一个这样的例子是我们将在之后证明的<math><mi mathvariant="bold">Sets</mi></math>对偶于完备原子布尔代数的范畴.</li><li>一个范畴<math><mi mathvariant="bold">C</mi></math>的<em>箭头范畴</em><math><msup><mi mathvariant="bold">C</mi><mo>&rarr;</mo></msup></math>以<math><mi mathvariant="bold">C</mi></math>的箭头为对象, 并且<math><msup><mi mathvariant="bold">C</mi><mo>&rarr;</mo></msup></math>中从对象<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>到<math><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>:</mo><mrow><msup><mi>A</mi><mo>&prime;</mo></msup><mo>&rarr;</mo><msup><mi>B</mi><mo>&prime;</mo></msup></mrow></mrow></math>的一个箭头<math><mi>g</mi></math>是一个&quot;交换正方形&quot;<svg width="160" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>A</mi></math></foreignObject><foreignObject x="93" y="32" width="100" height="30"><math><msup><mi>A</mi><mo>&prime;</mo></msup></math></foreignObject><foreignObject x="23" y="106" width="100" height="30"><math><mi>B</mi></math></foreignObject><foreignObject x="93" y="102" width="100" height="30"><math><msup><mi>B</mi><mo>&prime;</mo></msup></math></foreignObject><line x1="44" y1="44" x2="86" y2="44" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="44" y1="114" x2="86" y2="114" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="30" y1="58" x2="30" y2="100" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="100" y1="58" x2="100" y2="100" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="13" y="71" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="103" y="67" width="100" height="30"><math><msup><mi>f</mi><mo>&prime;</mo></msup></math></foreignObject><foreignObject x="58" y="22" width="100" height="30"><math><msub><mi>g</mi><mn>1</mn></msub></math></foreignObject><foreignObject x="58" y="116" width="100" height="30"><math><msub><mi>g</mi><mn>2</mn></msub></math></foreignObject></svg>其中<math><msub><mi>g</mi><mn>1</mn></msub></math>和<math><msub><mi>g</mi><mn>2</mn></msub></math>是<math><mi mathvariant="bold">C</mi></math>中的箭头. 换句话说, 这样的一个箭头<math><mi>g</mi></math>是<math><mi mathvariant="bold">C</mi></math>中的箭头序对<math><mrow><mo stretchy="false">(</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></math>并且满足<math display="block"><mrow><mrow><msub><mi>g</mi><mn>2</mn></msub><mo>&compfn;</mo><mi>f</mi></mrow><mo>=</mo><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&compfn;</mo><msub><mi>g</mi><mn>1</mn></msub></mrow></mrow><mtext>.</mtext></math>一个对象<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>上的恒等箭头是序对<math><mrow><mo stretchy="false">(</mo><mrow><msub><mn>1</mn><mi>A</mi></msub><mo>,</mo><msub><mn>1</mn><mi>B</mi></msub></mrow><mo stretchy="false">)</mo></mrow></math>. 箭头的复合是按分量计算的:<math display="block"><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>,</mo><msub><mi>h</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow><mo>&compfn;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>g</mi><mn>1</mn></msub><mo>,</mo><msub><mi>g</mi><mn>2</mn></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo stretchy="false">(</mo><mrow><mrow><msub><mi>h</mi><mn>1</mn></msub><mo>&compfn;</mo><msub><mi>g</mi><mn>1</mn></msub></mrow><mo>,</mo><mrow><msub><mi>h</mi><mn>2</mn></msub><mo>&compfn;</mo><msub><mi>g</mi><mn>2</mn></msub></mrow></mrow><mo stretchy="false">)</mo></mrow></mrow></math>读者应该画出合适的交换图以验证这个定义的确合理.<br/>观察到有两个函子:<math display="block"><mi mathvariant="bold">C</mi><mover><mo>&larr;</mo><mi>dom</mi></mover><msup><mi mathvariant="bold">C</mi><mo>&rarr;</mo></msup><mover><mo>&rarr;</mo><mi>cod</mi></mover><mi mathvariant="bold">C</mi></math></li><li>一个范畴<math><mi mathvariant="bold">C</mi></math>在对象<math><mrow><mi>C</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>上的<em>切片范畴</em>如下<ul><li>对象: 所有满足<math><mrow><mrow><mi>cod</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>f</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>C</mi></mrow></math>的箭头<math><mrow><mi>f</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math></li><li>箭头: 从对象<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>到对象<math><mrow><mi>f</mi><mo>:</mo><mrow><msup><mi>X</mi><mo>&prime;</mo></msup><mo>&rarr;</mo><mi>C</mi></mrow></mrow></math>的一个箭头<math><mi>a</mi></math>是一个<math><mi mathvariant="bold">C</mi></math>中的箭头<math><mrow><mi>a</mi><mo>:</mo><mrow><mi>X</mi><mo>&rarr;</mo><msup><mi>X</mi><mo>&prime;</mo></msup></mrow></mrow></math>使得<math><mrow><mrow><msup><mi>f</mi><mo>&prime;</mo></msup><mo>&compfn;</mo><mi>a</mi></mrow><mo>=</mo><mi>f</mi></mrow></math>, 如以下交换图所示:<svg width="160" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>X</mi></math></foreignObject><foreignObject x="93" y="32" width="100" height="30"><math><msup><mi>X</mi><mo>&prime;</mo></msup></math></foreignObject><foreignObject x="58" y="96" width="100" height="30"><math><mi>C</mi></math></foreignObject><line x1="44" y1="42" x2="86" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="37" y1="54" x2="58" y2="90" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="72" y1="90" x2="93" y2="54" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="33" y="66" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="83" y="62" width="100" height="30"><math><msup><mi>f</mi><mo>&prime;</mo></msup></math></foreignObject><foreignObject x="58" y="24" width="100" height="30"><math><mi>a</mi></math></foreignObject></svg>恒等箭头和箭头复合都继承自范畴<math><mi mathvariant="bold">C</mi></math>, 这和之前的箭头范畴的情况差不多. </li></ul></li></ol><h3>第1.7节 自由范畴</h3><p><b>自由幺半群. </b>我们从字母表<math><mi>A</mi></math>开始. 一个<math><mi>A</mi></math>上的词是来自于<math><mi>A</mi></math>的字母构成的有限序列. <math><mi>A</mi></math>的Kleene闭包<math><msup><mi>A</mi><mo>&#8270;</mo></msup></math>被定义为所有<math><mi>A</mi></math>上的词构成的集合. <math><msup><mi>A</mi><mo>&#8270;</mo></msup></math>上我们可以定义所谓的连接运算<math><mo>&#8270;</mo></math>. 这个运算显然是结合的, 并且长度为零的空序列是其单位元. 因此, <math><msup><mi>A</mi><mo>&#8270;</mo></msup></math>形成了一个幺半群, 其被称为集合<math><mi>A</mi></math>上的<em>自由幺半群</em>. 元素<math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>可以被视为长度为一的词, 即我们有一个函数<math display="block"><mrow><mi>i</mi><mo>:</mo><mrow><mrow><mi>A</mi><mo>&rarr;</mo><msup><mi>A</mi><mo>&#8270;</mo></msup></mrow><mo>,</mo><mrow><mi>a</mi><mo>&mapsto;</mo><mi>a</mi></mrow></mrow></mrow></math>虽然说以上的定义算是一种符号滥用 (abuse of notation) 吧. <math><mi>A</mi></math>的元素在某种意义上&quot;生成&quot;了这个自由幺半群, 即每个<math><mrow><mi>w</mi><mo>&in;</mo><msup><mi>A</mi><mo>&#8270;</mo></msup></mrow></math>都是<math><mi>A</mi></math>的元素的<math><mo>&#8270;</mo></math>积. 也就是说, 对于某些<math><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>,</mo><msub><mi>a</mi><mn>2</mn></msub><mo>,</mo><mo>&hellip;</mo><mo>,</mo><msub><mi>a</mi><mi>n</mi></msub></mrow><mo>&in;</mo><mi>A</mi></mrow></math>有<math><mrow><mi>w</mi><mo>=</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#8270;</mo><msub><mi>a</mi><mn>2</mn></msub><mo>&#8270;</mo><mo>&ctdot;</mo><mo>&#8270;</mo><msub><mi>a</mi><mi>n</mi></msub></mrow></mrow></math>.</p><p>到底何谓&quot;自由&quot;呢? 我们称一个幺半群<math><mi>M</mi></math>是由其子集<math><mi>A</mi></math><em>自由生成</em>的, 如果<ol><li>每个<math><mrow><mi>m</mi><mo>&in;</mo><mi>M</mi></mrow></math>都可以被写成<math><mi>A</mi></math>的元素之积:<math display="block"><mrow><mrow><mi>m</mi><mo>=</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><msub><mo>&sdot;</mo><mi>M</mi></msub><mo>&ctdot;</mo><msub><mo>&sdot;</mo><mi>M</mi></msub><msub><mi>a</mi><mi>n</mi></msub></mrow></mrow><mo>,</mo><mrow><msub><mi>a</mi><mi>i</mi></msub><mo>&in;</mo><mi>A</mi></mrow></mrow><mtext>.</mtext></math></li><li><math><mi>M</mi></math>中不存在&quot;非平凡&quot;的关系, 即如果<math><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>j</mi></msub></mrow><mo>=</mo><mrow><msubsup><mi>a</mi><mn>1</mn><mo>&prime;</mo></msubsup><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msubsup><mi>a</mi><mi>k</mi><mo>&prime;</mo></msubsup></mrow></mrow></math>, 那么这是幺半群的公理所要求的.</li></ol>第一个条件有时被称为&quot;没有垃圾&quot;, 第二个条件有时被称为&quot;没有噪音&quot;. 因此, <math><mi>A</mi></math>上的自由幺半群是包含<math><mi>A</mi></math>的没有垃圾也没有噪音的幺半群.</p><p>每个幺半群<math><mi>N</mi></math>都拥有一个作为基础的集合<math><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow></math>, 而每个幺半群同态<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>N</mi><mo>&rarr;</mo><mi>M</mi></mrow></mrow></math>都可以导出一个集合之间的函数<math><mrow><mrow><mo stretchy="false">|</mo><mi>f</mi><mo stretchy="false">|</mo></mrow><mo>:</mo><mrow><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mi>M</mi><mo stretchy="false">|</mo></mrow></mrow></mrow></math>. 很容易看出来这是一个函子, 即所谓的&quot;遗忘函子&quot;. 集合<math><mi>A</mi></math>上的自由幺半群<math><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></math>是满足以下<em>泛性质</em>的&quot;唯一&quot;的那个幺半群. (本书里将泛性质 (universal property) 称为泛映射性质 (universal mapping property, UMP), 这两者是一回事.)</p><p>存在函数<math><mrow><mi>i</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></mrow></mrow></math>, 对于任意的幺半群<math><mi>N</mi></math>和函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow></mrow></mrow></math>, 有唯一的幺半群同态<math><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>:</mo><mrow><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&rarr;</mo><mi>N</mi></mrow></mrow></math>满足<math><mrow><mrow><mrow><mo stretchy="false">|</mo><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo stretchy="false">|</mo></mrow><mo>&compfn;</mo><mi>i</mi></mrow><mo>=</mo><mi>f</mi></mrow></math>, 这可以画成以下交换图表:<svg width="640" height="320" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="6" width="100" height="30"><em>在<math><mi mathvariant="bold">Mon</mi></math>之中:</em></foreignObject><line x1="264" y1="60" x2="376" y2="60" marker-end="url(#arrow)" stroke-width="1.2px" stroke-dasharray="4 4"/><foreignObject x="216" y="51" width="100" height="30"><math><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></math></foreignObject><foreignObject x="383" y="51" width="100" height="30"><math><mi>N</mi></math></foreignObject><foreignObject x="313" y="32" width="100" height="30"><math><mover><mi>f</mi><mo>&OverBar;</mo></mover></math></foreignObject><foreignObject x="23" y="106" width="100" height="30"><em>在<math><mi mathvariant="bold">Sets</mi></math>之中:</em></foreignObject><line x1="264" y1="150" x2="376" y2="150" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="211" y="141" width="100" height="30"><math><mrow><mo stretchy="false">|</mo><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow><mo stretchy="false">|</mo></mrow></math></foreignObject><foreignObject x="383" y="141" width="100" height="30"><math><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow></math></foreignObject><line x1="240" y1="276" x2="240" y2="164" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="233" y="286" width="100" height="30"><math><mi>A</mi></math></foreignObject><line x1="256" y1="276" x2="384" y2="164" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="224" y="211" width="100" height="30"><math><mi>i</mi></math></foreignObject><foreignObject x="329" y="212" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="313" y="127" width="100" height="30"><math><mrow><mo stretchy="false">|</mo><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo stretchy="false">|</mo></mrow></math></foreignObject></svg></p><div class="proposition"><b>命题1.9.</b> <math><msup><mi>A</mi><mo>&#8270;</mo></msup></math>具有<math><mi>A</mi></math>上的自由幺半群的泛性质.</div><div class="proof"><b>证明.</b> 对于函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow></mrow></mrow></math>, 我们通过<math display="block"><mrow><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>-</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>u</mi><mi>N</mi></msub></mrow></math>其中<math><mi>-</mi></math>是空字符串而<math><msub><mi>u</mi><mi>N</mi></msub></math>是幺半群<math><mi>N</mi></math>的单位元, 以及<math display="block"><mrow><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sdot;</mo><mi>N</mi></msub><mo>&ctdot;</mo><msub><mo>&sdot;</mo><mi>N</mi></msub><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow></math>来定义<math><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>:</mo><mrow><msup><mi>A</mi><mo>&#8270;</mo></msup><mo>&rarr;</mo><mi>N</mi></mrow></mrow></math>, 其显然是一个同态, 并且满足对于每个<math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>有<math display="block"><mrow><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>.</mtext></math>这仍然是符号滥用, 更准确地说, 左边的<math><mi>a</mi></math>实际上是<math><mrow><mi>i</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></math>. 如果同态<math><mrow><mi>g</mi><mo>:</mo><mrow><msup><mi>A</mi><mo>&#8270;</mo></msup><mo>&rarr;</mo><mi>N</mi></mrow></mrow></math>也满足对于每个<math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>有<math><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 那么对于所有<math><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo>&in;</mo><msup><mi>A</mi><mo>&#8270;</mo></msup></mrow></math>:<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#8270;</mo><mo>&ctdot;</mo><mo>&#8270;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sdot;</mo><mi>N</mi></msub><mo>&ctdot;</mo><msub><mo>&sdot;</mo><mi>N</mi></msub><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sdot;</mo><mi>N</mi></msub><mo>&ctdot;</mo><msub><mo>&sdot;</mo><mi>N</mi></msub><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow></mrow><msub><mo>&sdot;</mo><mi>N</mi></msub><mo>&ctdot;</mo><msub><mo>&sdot;</mo><mi>N</mi></msub><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>a</mi><mi>i</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#8270;</mo><mo>&ctdot;</mo><mo>&#8270;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mover><mi>f</mi><mo>&OverBar;</mo></mover><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>于是, <math><mrow><mi>g</mi><mo>=</mo><mover><mi>f</mi><mo>&OverBar;</mo></mover></mrow></math>, 证明就结束了. 怎么说呢, <math><msup><mi>A</mi><mo>&#8270;</mo></msup></math>是自由幺半群的玄机藏在似乎平凡的事实<math><mrow><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#8270;</mo><mo>&ctdot;</mo><mo>&#8270;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow><mo>=</mo><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></mrow></math>之中. <math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&it;</mo><mo>&hellip;</mo><mo>&it;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math>在某种意义上其实是一种双关, 它暗示了只有唯一一种将其表示为乘积<math><mrow><msub><mi>a</mi><mn>1</mn></msub><mo>&#8270;</mo><mo>&ctdot;</mo><mo>&#8270;</mo><msub><mi>a</mi><mi>i</mi></msub></mrow></math>的方式.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><p>现在我们回头重新以泛性质来检视旧有的定义, 或者说思考泛性质是怎样捕获naive定义的想法的. 这个泛性质的存在性部分捕获了&quot;没有噪音&quot;的概念, 因为任意的生成元的代数组合之间的等式也对于其所映射至的东西成立, 也就是所有地方都成立. 唯一性部分捕获了&quot;没有垃圾&quot;的想法, 因为任何不是生成元的组合的元素, 其所映射至的东西可以是任意的值.</p><p>使用泛性质, 很容易表明自由幺半群<math><mrow><mi>M</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></math>在同构意义下是唯一的.</p><h3>第1.8节 基础问题: 大, 小, 局部小</h3><p>让我们首先区分以下两种东西:<ol type="i"><li>数学的范畴论基础;</li><li>范畴论的数学基础.</li></ol>对于第一点而言, 人们有时会听说范畴论可以用来提供&quot;数学的基础&quot;, 作为集合论的替代物. 实际上的确如此, 但是这不是我们这里要做的事情. 在集合论中, 人们经常从存在性公理开始, 例如&quot;存在一个无穷集合&quot;, 然后通过某些公理来导出更多的集合, 例如&quot;每个集合都有一个幂集&quot;, 由此人们构筑了一个数学对象 (即集合) 的宇宙, 从原则上说它对于&quot;所有的数学&quot;而言应该是足够了. 我们的公理&quot;每个箭头都有一个domain和一个codomain&quot;不应该和集合论公理&quot;每个集合都有一个幂集&quot;以相同的方式理解! 区别在于, 在集合论中 (至少是一般意义上的集合论), 这些公理被认为是指 (或者说确定) 一个单一的由集合构成的宇宙. 而在范畴论中, 与之相对的是, 这些公理是某种东西的<em>定义</em>, 即范畴的定义. 这就像群论或者拓扑学, 其公理是为了定义需要检视的对象的, 而这些对象又被认为是存在于某种&quot;背景&quot;或者&quot;基础&quot;系统之中, 例如集合论 (或者类型论). 而集合论本身又可能使用范畴论确定, 或者以其他某种方式.</p><p>这将我们带至第二点: 我们假定我们的范畴是由集合和函数构成的, 以这样或那样的方式, 就和其他绝大多数数学对象一样, 然后开始考虑范畴论 (或者其他什么理论) 作为基础的可能性. 但是, 在范畴论中, 我们经常在通常的实践中遇到集合论的困难. 大多数这些问题是和&quot;大小&quot;有关的; 一些范畴&quot;太大&quot;以至于我们没法按照寻常集合论的方式妥当地进行处理. 在第1.5节里考虑Cayley表示时, 我们就已经遇到了这种问题. 那里我们要求考虑的范畴</p><h3>第1.9节 练习</h3><h2>第2章 抽象结构</h2><h3>第2.1节 满态射和单态射</h3><p>给定函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>, 其被称为单射的, 如果对于所有的<math><mrow><mrow><mi>a</mi><mo>,</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>A</mi></mrow></math>, <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>可以推出<math><mrow><mi>a</mi><mo>=</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></math>; 其被称为满射的, 如果对于每个<math><mrow><mi>b</mi><mo>&in;</mo><mi>B</mi></mrow></math>, 存在<math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>使得<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>b</mi></mrow></math>.</p><div class="definition"><b>定义2.1.</b> 在任意的范畴<math><mi mathvariant="bold">C</mi></math>中, 给定箭头<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>, 其被称为是一个<em>单态射(monomorphism)</em>, 如果对于任意的<math><mrow><mrow><mi>g</mi><mo>,</mo><mi>h</mi></mrow><mo>:</mo><mrow><mi>C</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>, <math><mrow><mrow><mi>f</mi><mo>&it;</mo><mi>g</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>&it;</mo><mi>h</mi></mrow></mrow></math>可以推出<math><mrow><mi>g</mi><mo>=</mo><mi>h</mi></mrow></math>; 其被称为是一个<em>满态射(epimorphism)</em>, 如果对于任意的<math><mrow><mrow><mi>i</mi><mo>,</mo><mi>j</mi></mrow><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>D</mi></mrow></mrow></math>, <math><mrow><mrow><mi>i</mi><mo>&it;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>j</mi><mo>&it;</mo><mi>f</mi></mrow></mrow></math>可以推出<math><mrow><mi>i</mi><mo>=</mo><mi>j</mi></mrow></math>.</div><p>如果<math><mi>f</mi></math>是一个单态射, 那么我们记<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarrtl;</mo><mi>B</mi></mrow></mrow></math>. 如果<math><mi>f</mi></math>是一个满态射, 那么我们记<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&Rarr;</mo><mi>B</mi></mrow></mrow></math>.</p><div class="proposition"><b>命题.</b> 一个集合之间的函数<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>是单态射恰当其为单射.</div><div class="proof"><b>证明.</b> 设<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarrtl;</mo><mi>B</mi></mrow></mrow></math>. 令<math><mrow><mrow><mi>a</mi><mo>,</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo>&in;</mo><mi>A</mi></mrow></math>满足<math><mrow><mi>a</mi><mo>&ne;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow></math>, 并令<math><mrow><mo stretchy="false">{</mo><mi>x</mi><mo stretchy="false">}</mo></mrow></math>是任意的一个单元素集. <div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="example"><b>例子2.3.</b> 在许多类似于幺半群的<q>结构化集合</q>的范畴中, 单态射就恰为<q>单射的同态</q>. 更精确地说, 一个幺半群的同态<math><mrow><mi>h</mi><mo>:</mo><mrow><mi>M</mi><mo>&rarr;</mo><mi>N</mi></mrow></mrow></math>是单态射恰当其基础函数<math><mrow><mrow><mo stretchy="false">|</mo><mi>h</mi><mo stretchy="false">|</mo></mrow><mo>:</mo><mrow><mrow><mo stretchy="false">|</mo><mi>M</mi><mo stretchy="false">|</mo></mrow><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mi>N</mi><mo stretchy="false">|</mo></mrow></mrow></mrow></math>是单态射, 即前文的单射. 为了证明这点, 设<math><mi>h</mi></math>是一个单态射并取两个不同的<q>元素</q><math><mrow><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo>:</mo><mrow><mn>1</mn><mo>&rarr;</mo><mrow><mo stretchy="false">|</mo><mi>M</mi><mo stretchy="false">|</mo></mrow></mrow></mrow></math>, 其中<math><mrow><mn>1</mn><mo>=</mo><mrow><mo stretchy="false">{</mo><mo lspace="0" rspace="0">&#8270;</mo><mo stretchy="false">}</mo></mrow></mrow></math>是任意的单元素集合. </div><h3>第2.2节 始对象和终对象</h3><p>现在我们考虑对于范畴<math><mi mathvariant="bold">Sets</mi></math>中的空集和单元素集的抽象刻画, 而这可以推广至一般范畴中从结构上考虑类似的对象.</p><div class="definition"><b>定义2.9.</b> 在任何范畴<math><mi mathvariant="bold">C</mi></math>中, 对象<math><mn>0</mn></math>被称为始对象, 如果对于任意的对象<math><mrow><mi>C</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>, 存在唯一的态射<math><mrow><mn>0</mn><mo>&rarr;</mo><mi>C</mi></mrow></math>; 对象<math><mn>1</mn></math>被称为终对象, 如果对于任意的对象<math><mrow><mi>C</mi><mo>&in;</mo><mi mathvariant="bold">C</mi></mrow></math>, 存在唯一的态射<math><mrow><mi>C</mi><mo>&rarr;</mo><mn>1</mn></mrow></math>.</div><p>就像单态射和满态射一样, 我们应该注意到这定义中存在某种&quot;对偶性&quot;. 精确地说, <math><mi mathvariant="bold">C</mi></math>中的终对象恰是<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的始对象. 我们在第3章中系统地考虑了对偶性.</p><p>首先, 我们应该注意到始对象和终对象的概念显然是泛性质, 这样的对象在同构意义下是唯一的, 就和自由幺半群一样.</p><div class="proposition"><b>命题2.10.</b> 始对象在同构下是唯一的, 终对象也是.</div><h2>第3章 对偶</h2><h3>第3.1节 对偶原理</h3><h3>第3.2节 余积</h3><h3>第3.3节 等化子</h3><div class="definition"><b>定义3.13.</b> 在任何范畴<math><mi mathvariant="bold">C</mi></math>中, 给定平行的箭头<math display="block"><mi>A</mi><munderover><mo>&rrarr;</mo><mi>g</mi><mi>f</mi></munderover><mi>B</mi></math><math><mi>f</mi></math>和<math><mi>g</mi></math>的一个<em>等化子</em>由一个对象<math><mi>E</mi></math>和一个箭头<math><mrow><mi>e</mi><mo>:</mo><mrow><mi>E</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>构成, universal such that<math display="block"><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>e</mi></mrow><mo>=</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>e</mi></mrow></mrow><mtext>.</mtext></math>此即是说, 给定任意的<math><mrow><mi>z</mi><mo>:</mo><mrow><mi>Z</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>满足<math display="block"><mrow><mrow><mi>f</mi><mo>&compfn;</mo><mi>z</mi></mrow><mo>=</mo><mrow><mi>g</mi><mo>&compfn;</mo><mi>z</mi></mrow></mrow></math>存在<em>唯一</em>的<math><mrow><mi>u</mi><mo>:</mo><mrow><mi>Z</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>使得<math><mrow><mrow><mi>e</mi><mo>&compfn;</mo><mi>u</mi></mrow><mo>=</mo><mi>z</mi></mrow></math>, 如图所示则为<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>E</mi></math></foreignObject><foreignObject x="23" y="136" width="100" height="30"><math><mi>Z</mi></math></foreignObject><foreignObject x="153" y="36" width="100" height="30"><math><mi>A</mi></math></foreignObject><foreignObject x="283" y="36" width="100" height="30"><math><mi>B</mi></math></foreignObject><line x1="173" y1="37" x2="277" y2="37" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="173" y1="47" x2="277" y2="47" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="42" x2="147" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="132" x2="147" y2="52" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="218" y="14" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="218" y="49" width="100" height="30"><math><mi>g</mi></math></foreignObject><foreignObject x="88" y="19" width="100" height="30"><math><mi>e</mi></math></foreignObject><foreignObject x="98" y="96" width="100" height="30"><math><mi>z</mi></math></foreignObject><line x1="30" y1="127" x2="30" y2="57" marker-end="url(#arrow)" stroke-width="1.2px" stroke-dasharray="2 2"/><foreignObject x="16" y="81" width="100" height="30"><math><mi>u</mi></math></foreignObject></svg></div><p>让我们考虑一些简单的例子.</p><div class="example"><b>例子3.14.</b> 设我们有函数<math><mrow><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo>:</mo><mrow><msup><mi>&Ropf;</mi><mn>2</mn></msup><mo>&rrarr;</mo><mi>&Ropf;</mi></mrow></mrow></math>, 其中<math display="block"><mtable columnalign="right center left" displaystyle="true"><mtr><mtd><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></mtd></mtr><mtr><mtd><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mn>1</mn></mtd></mtr></mtable></math>我们取等化子, 比如说在<math><mi mathvariant="bold">Top</mi></math>范畴中. 这是子空间<math display="block"><mrow><mi>S</mi><mo>=</mo><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>x</mi><mo>,</mo><mi>y</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&in;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow><mo stretchy="false">|</mo><mrow><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow><mo>=</mo><mn>1</mn></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&rarrhk;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></mrow></math>即平面中的单位圆. 这是因为, 给定任意的<q>泛化元素</q><math><mrow><mi>z</mi><mo>:</mo><mrow><mi>Z</mi><mo>&rarr;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></mrow></math>, 通过与两个投影进行复合, 我们就得到了一对这样的<q>元素</q><math><mrow><mrow><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub></mrow><mo>:</mo><mrow><mi>Z</mi><mo>&rarr;</mo><mi>&Ropf;</mi></mrow></mrow></math>, <math><mrow><mi>z</mi><mo>=</mo><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow></mrow></math>, 对于这些我们然后有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>z</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mtd><mtd><mtext>iff</mtext></mtd><mtd><mrow><mrow><msubsup><mi>z</mi><mn>1</mn><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>z</mi><mn>2</mn><mn>2</mn></msubsup></mrow><mo>=</mo><mn>1</mn></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mtext>iff</mtext></mtd><mtd><mrow><mtext>&quot;</mtext><mrow><mrow><mo stretchy="false">&lang;</mo><mrow><msub><mi>z</mi><mn>1</mn></msub><mo>,</mo><msub><mi>z</mi><mn>2</mn></msub></mrow><mo stretchy="false">&rang;</mo></mrow><mo>=</mo><mrow><mi>z</mi><mo>&in;</mo><mi>S</mi></mrow></mrow><mtext>&quot;</mtext></mrow></mtd></mtr></mtable></math>其中最后一行实际上意味着<math><mi>z</mi></math>可以通过嵌入<math><mrow><mi>i</mi><mo>:</mo><mrow><mi>S</mi><mo>&rarrhk;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></mrow></math>分解为<math><mrow><mi>z</mi><mo>=</mo><mrow><mi>i</mi><mo>&compfn;</mo><mover><mi>z</mi><mo>&OverBar;</mo></mover></mrow></mrow></math> [译注: 这里原文似乎有笔误, 将顺序颠倒了, 但未见于勘误], 如以下交换图表所示 [译注: 这里从<math><mi>S</mi></math>到<math><msup><mi>&Ropf;</mi><mn>2</mn></msup></math>实际上应该是嵌入箭头, 但是译者嫌麻烦, 还没有画]:<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>S</mi></math></foreignObject><foreignObject x="23" y="136" width="100" height="30"><math><mi>Z</mi></math></foreignObject><foreignObject x="153" y="36" width="100" height="30"><math><msup><mi>&Ropf;</mi><mn>2</mn></msup></math></foreignObject><foreignObject x="283" y="36" width="100" height="30"><math><mi>&Ropf;</mi></math></foreignObject><line x1="173" y1="37" x2="277" y2="37" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="173" y1="47" x2="277" y2="47" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="42" x2="147" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="132" x2="147" y2="52" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="195" y="14" width="100" height="30"><math><mrow><msup><mi>x</mi><mn>2</mn></msup><mo>+</mo><msup><mi>y</mi><mn>2</mn></msup></mrow></math></foreignObject><foreignObject x="218" y="49" width="100" height="30"><math><mn>1</mn></math></foreignObject><foreignObject x="88" y="19" width="100" height="30"><math><mi>i</mi></math></foreignObject><foreignObject x="98" y="96" width="100" height="30"><math><mi>z</mi></math></foreignObject><line x1="30" y1="127" x2="30" y2="57" marker-end="url(#arrow)" stroke-width="1.2px" stroke-dasharray="2 2"/><foreignObject x="16" y="81" width="100" height="30"><math><mover><mi>z</mi><mo>&OverBar;</mo></mover></math></foreignObject></svg>既然嵌入<math><mi>i</mi></math>是单态射, 这样的分解在存在的情况下必然是唯一的, 因而<math><mrow><mi>S</mi><mo>&rarrhk;</mo><msup><mi>&Ropf;</mi><mn>2</mn></msup></mrow></math>的确是<math><mi>f</mi></math>和<math><mi>g</mi></math>的等化子.</div><div class="example"><b>例子3.15.</b> 类似地, 在<math><mi mathvariant="bold">Sets</mi></math>中, 给定任意的函数<math><mrow><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rrarr;</mo><mi>B</mi></mrow></mrow></math>, 其等化子是由等式定义的子集<math display="block"><mrow><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></mrow><mo stretchy="false">}</mo></mrow><mo>&rarrhk;</mo><mi>A</mi></mrow></math>到<math><mi>A</mi></math>的嵌入. 其论证基本上和刚才给出的是一模一样的.</div><p>现在让我们暂停一下, 观察到一个基本事实. 实际上, 每个子集都具有这种<q>等式性</q>的形式, 即每个子集都是某对函数的等化子. 的确, 我们可以用非常canonical的方式构造出来. 首先, 让我们置<math display="block"><mrow><mn>2</mn><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mi>&top;</mi><mo>,</mo><mi>&bottom;</mi></mrow><mo stretchy="false">}</mo></mrow></mrow></math>将其想成是<q>真值</q>的集合, 然后考虑<em>特征函数</em><math display="block"><mrow><mrow><msub><mi>&chi;</mi><mi>U</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>&top;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mi>x</mi><mo>&in;</mo><mi>U</mi></mrow></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mi>x</mi><mo>&notin;</mo><mi>U</mi></mrow></mtd></mtr></mtable></mrow></mrow></math>因此, 我们有<math display="block"><mrow><mi>U</mi><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><msub><mi>&chi;</mi><mi>U</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&top;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>于是, 以下是一个等化子:<math display="block"><mi>U</mi><mo>&rarr;</mo><mi>A</mi><munderover><mo>&rrarr;</mo><msub><mi>&chi;</mi><mi>U</mi></msub><mrow><mi>&top;</mi><mo>&it;</mo><mi>!</mi></mrow></munderover><mn>2</mn></math>其中<math><mrow><mrow><mi>&top;</mi><mo>&it;</mo><mi>!</mi></mrow><mo>=</mo><mrow><mrow><mi>&top;</mi><mo>&compfn;</mo><mi>!</mi></mrow><mo>:</mo><mrow><mi>A</mi><mover><mo>&rarr;</mo><mi>!</mi></mover><mrow><mn>1</mn><mover><mo>&rarr;</mo><mi>&top;</mi></mover><mn>2</mn></mrow></mrow></mrow></mrow></math>. [译注: 原文是<math><mrow><mi>U</mi><mover><mo>&rarr;</mo><mi>!</mi></mover><mrow><mn>1</mn><mover><mo>&rarr;</mo><mi>&top;</mi></mover><mn>2</mn></mrow></mrow></math>, 但是译者认为这是作者的笔误.]</p><p>而且, 对于每个函数<math display="block"><mrow><mi>&phi;</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mn>2</mn></mrow></mrow></math>我们可以构造<q>variety</q>(即等式性子集)<math display="block"><mrow><msub><mi>V</mi><mi>&phi;</mi></msub><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&top;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>作为等化子, 以同样的方式. (将<math><mi>&phi;</mi></math>想成是定义于<math><mi>A</mi></math>上的一个<q>命题函数</q>, 子集<math><mrow><msub><mi>V</mi><mi>&phi;</mi></msub><mo>&sube;</mo><mi>A</mi></mrow></math>是由分离公理提供的<math><mi>&phi;</mi></math>的<q>外延</q>.) [译注: 所谓命题函数, 也可以称为谓词.]</p><p>现在, 很容易看出来操作<math><msub><mi>&chi;</mi><mi>U</mi></msub></math>和<math><msub><mi>V</mi><mi>&phi;</mi></msub></math>是互逆的 [译注: 我更愿意省略dummy variable而说<math><mi>&chi;</mi></math>和<math><mi>V</mi></math>是互逆的, 当然这只是风格问题]:<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><msub><mi>V</mi><msub><mi>&chi;</mi><mi>U</mi></msub></msub></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow><mo stretchy="false">|</mo><mrow><mrow><msub><mi>&chi;</mi><mi>U</mi></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&top;</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&in;</mo><mi>U</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mi>U</mi></mtd></mtr></mtable></math>对于任意的<math><mrow><mi>U</mi><mo>&sube;</mo><mi>A</mi></mrow></math>成立. 并且, 给定任意的<math><mrow><mi>&phi;</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mn>2</mn></mrow></mrow></math>, 我们有<math display="block"><mtable displaystyle="true" columnalign="right center left"><mtr><mtd><mrow><msub><mi>&chi;</mi><msub><mi>V</mi><mi>&phi;</mi></msub></msub><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>&top;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mi>x</mi><mo>&in;</mo><msub><mi>V</mi><mi>&phi;</mi></msub></mrow></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mi>x</mi><mo>&notin;</mo><msub><mi>V</mi><mi>&phi;</mi></msub></mrow></mtd></mtr></mtable></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mo>{</mo><mtable displaystyle="true"><mtr><mtd><mi>&top;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&top;</mi></mrow></mtd></mtr><mtr><mtd><mi>&bottom;</mi></mtd><mtd columnalign="left"><mtext>,&nbsp;</mtext><mrow><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mi>&bottom;</mi></mrow></mtd></mtr></mtable></mrow></mtd></mtr><mtr><mtd><mrow/></mtd><mtd><mo>=</mo></mtd><mtd><mrow><mi>&phi;</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mtd></mtr></mtable></math>因此, 我们有熟悉的同构<math display="block"><mrow><mrow><mi>Hom</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>A</mi><mo>,</mo><mn>2</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&cong;</mo><mrow><mi>P</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>A</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>mediated by taking equalizers.</p><p>函数的等化子可以取子集这样一个事实实际上是一种更一般的现象的特殊情形.</p><div class="proposition"><b>命题3.16.</b> 在任何范畴中, 如果<math><mrow><mi>e</mi><mo>:</mo><mrow><mi>E</mi><mo>&rarr;</mo><mi>A</mi></mrow></mrow></math>是某对箭头的一个等化子, 那么<math><mi>e</mi></math>是一个单态射.</div><div class="proof"><b>证明.</b> [译注: 这个证明近乎于重复了一遍定义.] 考虑图表<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>E</mi></math></foreignObject><foreignObject x="23" y="136" width="100" height="30"><math><mi>Z</mi></math></foreignObject><foreignObject x="153" y="36" width="100" height="30"><math><mi>A</mi></math></foreignObject><foreignObject x="283" y="36" width="100" height="30"><math><mi>B</mi></math></foreignObject><line x1="173" y1="37" x2="277" y2="37" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="173" y1="47" x2="277" y2="47" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="42" x2="147" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="132" x2="147" y2="52" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="218" y="14" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="218" y="49" width="100" height="30"><math><mi>g</mi></math></foreignObject><foreignObject x="88" y="19" width="100" height="30"><math><mi>e</mi></math></foreignObject><foreignObject x="98" y="96" width="100" height="30"><math><mi>z</mi></math></foreignObject><line x1="25" y1="128" x2="25" y2="58" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="35" y1="128" x2="35" y2="58" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="11" y="81" width="100" height="30"><math><mi>x</mi></math></foreignObject><foreignObject x="40" y="81" width="100" height="30"><math><mi>y</mi></math></foreignObject></svg>其中我们假定<math><mi>e</mi></math>是<math><mi>f</mi></math>和<math><mi>g</mi></math>的等化子. 设<math><mrow><mrow><mi>e</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>e</mi><mo>&it;</mo><mi>y</mi></mrow></mrow></math>, 我们想要证明<math><mrow><mi>x</mi><mo>=</mo><mi>y</mi></mrow></math>. 置<math><mrow><mi>z</mi><mo>=</mo><mrow><mi>e</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>e</mi><mo>&it;</mo><mi>y</mi></mrow></mrow></math>, 那么<math><mrow><mrow><mi>f</mi><mo>&it;</mo><mi>z</mi></mrow><mo>=</mo><mrow><mi>f</mi><mo>&it;</mo><mi>e</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>g</mi><mo>&it;</mo><mi>e</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mrow><mi>g</mi><mo>&it;</mo><mi>z</mi></mrow></mrow></math>, 于是存在<em>唯一</em>的<math><mrow><mi>u</mi><mo>:</mo><mrow><mi>Z</mi><mo>&rarr;</mo><mi>E</mi></mrow></mrow></math>使得<math><mrow><mrow><mi>e</mi><mo>&it;</mo><mi>u</mi></mrow><mo>=</mo><mi>z</mi></mrow></math>. 因此, 根据<math><mrow><mrow><mi>e</mi><mo>&it;</mo><mi>x</mi></mrow><mo>=</mo><mi>z</mi></mrow></math>和<math><mrow><mrow><mi>e</mi><mo>&it;</mo><mi>y</mi></mrow><mo>=</mo><mi>z</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>=</mo><mi>u</mi><mo>=</mo><mi>y</mi></mrow></math>.<div class="qed"><math><mo>&EmptySmallSquare;</mo></math></div></div><div class="example"><b>例子3.17.</b> 在许多范畴中, 例如偏序集和幺半群的范畴, 一个平行箭头序对<math><mrow><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rrarr;</mo><mi>B</mi></mrow></mrow></math>的等化子可以通过取作为基础函数的等化子按照以上方式构造出来, 即子集<math><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&sube;</mo><mi>A</mi></mrow></math>, 其指的是满足<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>的所有元素<math><mrow><mi>x</mi><mo>&in;</mo><mi>A</mi></mrow></math>构成的集合. 例如, 在偏序集中我们取从<math><mi>A</mi></math>限制到<math><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>的序, 而在拓扑空间中, 我们取子空间拓扑.<br/>在幺半群中, 子集<math><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>在<math><mi>A</mi></math>的运算下也是一个幺半群, 因此这个嵌入是一个同态. 这个的原因是 [译注: 当然十分显然] <math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><msub><mi>u</mi><mi>B</mi></msub><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msub><mi>u</mi><mi>A</mi></msub><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 并且如果<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>且<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow></math>, 那么<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>&sdot;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>&sdot;</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><msup><mi>a</mi><mo>&prime;</mo></msup><mo stretchy="false">)</mo></mrow></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>a</mi><mo>&sdot;</mo><msup><mi>a</mi><mo>&prime;</mo></msup></mrow><mo stretchy="false">)</mo></mrow></mrow></mrow></math>. 于是, <math><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>=</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow></math>包含单位元并在乘积运算下封闭.<br/>在Abel群中, 我们可以有对于等化子的另外的描述方式, 使用以下事实<math display="block"><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow></mrow><mtext>当且仅当</mtext><mrow><mrow><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&minus;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mn>0</mn></mrow></math>因此, <math><mi>f</mi></math>和<math><mi>g</mi></math>的等化子就等于同态<math><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&minus;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></math>和零同态<math><mrow><mn>0</mn><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>的等化子. 于是, 只需要对于任意的同态<math><mrow><mi>h</mi><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math>考虑特殊形式的等化子<math><mrow><mrow><mi>A</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>h</mi><mo>,</mo><mn>0</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarrtl;</mo><mi>A</mi></mrow></math>就够了. 这个<math><mi>A</mi></math>的子群被称为<math><mi>h</mi></math>的<em>核</em>, 记作<math><mrow><mi>ker</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow></mrow></math>. 因此, 我们有等化子<math display="block"><mrow><mi>ker</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>f</mi><mo>&minus;</mo><mi>g</mi></mrow><mo stretchy="false">)</mo></mrow></mrow><mo>&rarrhk;</mo><mi>A</mi><munderover><mo>&rrarr;</mo><mi>g</mi><mi>f</mi></munderover><mi>B</mi><mtext>.</mtext></math>同态的核在对于群的研究中具有根本的重要性, 在第4章中我们将进一步考虑这个概念.</div><h3>第3.4节 余等化子</h3><p>余等化子是对于由等价关系取商的泛化, 所以让我们从回顾这个概念开始, 当然我们已经用过很多次了. 首先回忆一下, 一个集合<math><mi>X</mi></math>上的一个<em>等价关系</em>是一个二元关系<math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></math>, 其满足<ul><li>自反性: <math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>x</mi></mrow></math>;</li><li>对称性: <math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></math>可以推出<math><mrow><mi>y</mi><mo>&Tilde;</mo><mi>x</mi></mrow></math>;</li><li>传递性: <math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></math>和<math><mrow><mi>y</mi><mo>&Tilde;</mo><mi>z</mi></mrow></math>可以推出<math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>z</mi></mrow></math>.</li></ul>给定这样一个关系, 定义一个元素<math><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow></math>的<em>等价类</em>为<math display="block"><mrow><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mi>y</mi><mo>&in;</mo><mi>X</mi></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow><mtext>.</mtext></math>所有不同的等价类然后构成了<math><mi>X</mi></math>的一个<em>划分</em>, 意思是每个元素<math><mi>y</mi></math>都恰好位于其中一个集合中, 即<math><mrow><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow></math> (证明一下!).</p><p>有时人们将等价关系想成是由具有某种相同性质 (例如具体相同的颜色) 的等价元素所产生的. 我们可以将等价类<math><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></math>当成是性质, 在这种意义下作为<q>抽象对象</q> (比如说颜色红色, 蓝色, 等等, 它们本身). 这有时被称为<q>definition by abstraction</q>, 举例来说, 它描述了实数是如何从有理数的Cauchy序列构造出来的, 或者有限基数是如何从有限集合构造出来的.</p><p>所有等价类构成的集合<math display="block"><mrow><mrow><mi>X</mi><mo lspace="0" rspace="0">/</mo><mo lspace="0" rspace="0">&Tilde;</mo></mrow><mo>=</mo><mrow><mo stretchy="false">{</mo><mrow><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mo stretchy="false">|</mo><mrow><mi>x</mi><mo>&in;</mo><mi>X</mi></mrow></mrow><mo stretchy="false">}</mo></mrow></mrow></math>或许可以被称为<math><mi>X</mi></math>除以<math><mo>&Tilde;</mo></math>的<em>商</em>. 当人们想要<q>抽象出</q>等价元素<math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></math>之间的差异时 [译注: 也就是忽略等价元素之间的差异], 就是使用<math><mrow><mi>X</mi><mo lspace="0" rspace="0">/</mo><mo lspace="0" rspace="0">&Tilde;</mo></mrow></math>代替<math><mi>X</mi></math>, 即在<math><mrow><mi>X</mi><mo lspace="0" rspace="0">/</mo><mo lspace="0" rspace="0">&Tilde;</mo></mrow></math>中这样的元素 (也仅是这样的元素) 会被等同起来, 因为<math display="block"><mrow><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow><mo>=</mo><mrow><mo stretchy="false">[</mo><mi>y</mi><mo stretchy="false">]</mo></mrow></mrow><mtext>当且仅当</mtext><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow><mtext>.</mtext></math>观察到<em>商映射</em><math display="block"><mrow><mi>q</mi><mo>:</mo><mrow><mi>X</mi><mo>&rarr;</mo><mrow><mi>X</mi><mo lspace="0" rspace="0">/</mo><mo lspace="0" rspace="0">&Tilde;</mo></mrow></mrow></mrow></math>其取<math><mi>x</mi></math>至<math><mrow><mo stretchy="false">[</mo><mi>x</mi><mo stretchy="false">]</mo></mrow></math>, 具有这样的性质, 即一个映射<math><mrow><mi>f</mi><mo>:</mo><mrow><mi>X</mi><mo>&rarr;</mo><mi>Y</mi></mrow></mrow></math> extends along <math><mi>q</mi></math>,<svg width="160" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>X</mi></math></foreignObject><foreignObject x="123" y="36" width="100" height="30"><math><mrow><mi>X</mi><mo lspace="0" rspace="0">/</mo><mo lspace="0" rspace="0">&Tilde;</mo></mrow></math></foreignObject><foreignObject x="123" y="136" width="100" height="30"><math><mi>Y</mi></math></foreignObject><line x1="40" y1="42" x2="120" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="130" y1="52" x2="130" y2="132" marker-end="url(#arrow)" stroke-width="1.2px" stroke-dasharray="2 2"/><line x1="40" y1="52" x2="120" y2="132" marker-end="url(#arrow)" stroke-width="1.2px"/><foreignObject x="73" y="24" width="100" height="30"><math><mi>q</mi></math></foreignObject><foreignObject x="68" y="91" width="100" height="30"><math><mi>f</mi></math></foreignObject></svg>只要<math><mi>f</mi></math>尊重等价关系, 意即<math><mrow><mi>x</mi><mo>&Tilde;</mo><mi>y</mi></mrow></math>可以推出<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>y</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math>.</p><p>现在让我们来考虑对偶于等化子的概念, 即所谓的余等化子.</p><div class="definition"><b>定义3.18.</b> 对于某个范畴<math><mi mathvariant="bold">C</mi></math>中任意的平行箭头<math><mrow><mrow><mi>f</mi><mo>,</mo><mi>g</mi></mrow><mo>:</mo><mrow><mi>A</mi><mo>&rarr;</mo><mi>B</mi></mrow></mrow></math> [译注: 老实说, 这本书的很多记号都不太一致, 但是理解意思就行了], 一个<em>余等化子</em>由<math><mi>Q</mi></math>和<math><mrow><mi>q</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>Q</mi></mrow></mrow></math>构成, universal with the property <math><mrow><mrow><mi>q</mi><mo>&it;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>q</mi><mo>&it;</mo><mi>g</mi></mrow></mrow></math>, 如下图所示<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs><foreignObject x="23" y="36" width="100" height="30"><math><mi>A</mi></math></foreignObject><foreignObject x="153" y="36" width="100" height="30"><math><mi>B</mi></math></foreignObject><foreignObject x="283" y="36" width="100" height="30"><math><mi>Q</mi></math></foreignObject><foreignObject x="283" y="136" width="100" height="30"><math><mi>Z</mi></math></foreignObject><line x1="43" y1="37" x2="147" y2="37" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="43" y1="49" x2="147" y2="49" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="173" y1="42" x2="277" y2="42" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="173" y1="52" x2="277" y2="132" marker-end="url(#arrow)" stroke-width="1.2px"/><line x1="290" y1="52" x2="290" y2="132" marker-end="url(#arrow)" stroke-width="1.2px" stroke-dasharray="2 2"/><foreignObject x="88" y="16" width="100" height="30"><math><mi>f</mi></math></foreignObject><foreignObject x="88" y="48" width="100" height="30"><math><mi>g</mi></math></foreignObject><foreignObject x="218" y="21" width="100" height="30"><math><mi>q</mi></math></foreignObject><foreignObject x="293" y="81" width="100" height="30"><math><mi>u</mi></math></foreignObject><foreignObject x="215" y="89" width="100" height="30"><math><mi>z</mi></math></foreignObject></svg>也就是说, 给定任意的<math><mi>Z</mi></math>和<math><mrow><mi>z</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>Z</mi></mrow></mrow></math>, 如果<math><mrow><mrow><mi>z</mi><mo>&it;</mo><mi>f</mi></mrow><mo>=</mo><mrow><mi>z</mi><mo>&it;</mo><mi>g</mi></mrow></mrow></math>, 那么存在唯一的态射<math><mrow><mi>u</mi><mo>:</mo><mrow><mi>Q</mi><mo>&rarr;</mo><mi>Z</mi></mrow></mrow></math>使得<math><mrow><mrow><mi>u</mi><mo>&it;</mo><mi>q</mi></mrow><mo>=</mo><mi>z</mi></mrow></math>.</div><p>首先观察到, 根据对偶性, 我们知道范畴<math><mi mathvariant="bold">C</mi></math>中的这样一个余等化子是范畴<math><msup><mi mathvariant="bold">C</mi><mi>op</mi></msup></math>中的一个等化子, 这个等化子根据命题3.16是单态射, 所以在<math><mi mathvariant="bold">C</mi></math>中这个余等化子应该是满态射.</p><div class="proposition"><b>命题3.19.</b> 如果<math><mrow><mi>q</mi><mo>:</mo><mrow><mi>B</mi><mo>&rarr;</mo><mi>Q</mi></mrow></mrow></math>是某对箭头的一个余等化子, 那么<math><mi>q</mi></math>是一个满态射.</div><p>因此, 我们可以将一个余等化子<math><mrow><mi>q</mi><mo>:</mo><mrow><mi>B</mi><mo>&Rarr;</mo><mi>Q</mi></mrow></mrow></math>想成是<math><mi>B</mi></math>的一种<q>坍缩</q>, 通过将所有序对<math><mrow><mrow><mi>f</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow><mo>=</mo><mrow><mi>g</mi><mo>&af;</mo><mrow><mo stretchy="false">(</mo><mi>a</mi><mo stretchy="false">)</mo></mrow></mrow></mrow></math><q>等同起来</q> (speaking as if there were such <q>elements</q> <math><mrow><mi>a</mi><mo>&in;</mo><mi>A</mi></mrow></math>). 而且, 我们以<q>最小</q>的方式这么做, 也就是说, 尽可能少地打扰<math><mi>B</mi></math>, 在于我们总是可以将<math><mi>Q</mi></math>映射到任何其他的<math><mi>Z</mi></math>, 只要其中所有这样的等同起来都是成立的.</p><div class="example"><b>例子3.20.</b> 令<math><mrow><mi>R</mi><mo>&sube;</mo><mrow><mi>X</mi><mo>&times;</mo><mi>X</mi></mrow></mrow></math>是集合<math><mi>X</mi></math>上的一个等价关系, 并考虑图<math display="block"><mi>R</mi><munderover><mo>&rrarr;</mo><msub><mi>r</mi><mn>2</mn></msub><msub><mi>r</mi><mn>1</mn></msub></munderover><mi>X</mi></math>其中<math><msub><mi>r</mi><mn>1</mn></msub></math>和<math><msub><mi>r</mi><mn>2</mn></msub></math>是嵌入 (inclusion) <math><mrow><mi>R</mi><mo>&sube;</mo><mrow><mi>X</mi><mo>&times;</mo><mi>X</mi></mrow></mrow></math>的两个投影, 即<svg width="320" height="160" stroke="black" style="display: block; margin: auto;"><defs><marker id="arrow" viewbox="0 0 10 10" refX="5" refY="5" markerWidth="6" markerHeight="6" orient="auto-start-reverse"><path d="M 0 2 L 6 5 L 0 8 z"/></marker></defs></svg></div><h2>第4章 群和范畴</h2><h2>第5章 极限和余极限</h2></body></html>