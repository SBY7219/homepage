<html><head><meta charset="utf-8"/><title>P423笔记</title><link href="styles.css" rel="stylesheet"/></head><body><h1>P423笔记</h1><p>P423是IUB一门关于编译器构造的课程. 和C311一样, 历史都比较悠久了. 当然, 课程的内容是不断更新的, 比如说现在的P423课程会使用一本叫做Essentials of Compilation的书. 但是, 我这里的笔记是针对曾经的Kent Dybvig还在IUB时上的P423课程的作业材料的探究.</p><p>我最初是在2020年初的时候开始阅读这些作业材料, 大概花了一段时间我才搞明白整个作业的结构. 最终, 我决定倒着完成这些作业. 不过, 实际上我只完成了作业的后半部分. 前半部分里我遇到了一些困难, 最终导致我没能完成所有的作业. 当初写的代码已经全被我删除了, 这是我的坏习惯. 不过, 至少我还记得一些东西. 现在, 我决定复习一下之前完成的作业, 并试着真正写完一个从Scheme到x86的优化编译器.</p><p>nanopass编译器框架实际上不是必要的, 只需要一个最简单的模式匹配宏也足够完成P423作业了. 当然了, nanopass提供了比较fancy的机制, 例如catamorphism, 这真的很方便, 但是没有的话也不是不能写编译器就是了.</p><p>我决定和上次一样, 仍然使用C311课程里的那个模式匹配宏, 据说这是Oleg Kiselyov写的, 我做了一点修改.<pre><code>(define-syntax match
  (syntax-rules (guard)
    ((_ v) (error 'match &quot;~s&quot; v))
    ((_ v (pat (guard g ...) e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (if (and g ...) (let () e ...) (fk)) (fk))))
    ((_ v (pat e ...) cs ...)
     (let ((fk (lambda () (match v cs ...))))
       (ppat v pat (let () e ...) (fk))))))
(define-syntax ppat
  (syntax-rules (unquote)
    ((_ v () kt kf) (if (null? v) kt kf))
    ((_ v (unquote var) kt kf) (let ((var v)) kt))
    ((_ v (x . y) kt kf)
     (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
    ((_ v lit kt kf) (if (eqv? v (quote lit)) kt kf))))</code></pre></p><p>我印象中, 后半部分最令我捉摸不透的地方实际上是<code>purify-letrec</code>, 我到现在还是没能理解<code>letrec</code>和<code>letrec*</code>的语义, 而且似乎顶层程序的语义也值得好好琢磨. 闭包变换也多花了我一段时间, 因为实际上网上没法找到那次作业的pdf文件. 但是, 我的确可以猜出来大致上要做什么, 而且在某个上过P423课程的人写的作业里, 我找到了比较详尽的描述, 所以没有耗费我太多精力. 实际上, 闭包变换在概念上是比较简单的. 至于是不是有人故意删除了这次作业的文件, 那就不得而知了.</p><p>为了完成这个作业, 除了作业要求材料之外, Andy Keep为了展示nanopass框架而写的两个编译器是值得阅读的, Andy Keep的PhD论文也是值得阅读的. Kent Dybvig的PhD论文, 以及其他一些关于Chez Scheme优化的论文, 同样地令人感兴趣. 有些材料没有那么适切, 但也仍然值得阅读, 比如Appel的Compiling with Continuations, 其刻画了SML/NJ的后端.</p><h2>作业15: <code>parse-scheme</code></h2><p>这次作业仅需要完成<code>parse-scheme</code>, 目的主要是将最初的源语言规约为更加紧凑的形式, 并对于输入进行一些简单的验证, 排除一些基本的错误. 当然, 顺便进行一下<math><mi>&alpha;</mi></math>变换, 使得变量名唯一, 这是之后诸多分析和变换的基础.</p><p>虽然概念上没有什么复杂的地方, 但是写起来有许多细节问题, 导致我当初写得非常难受, 似乎也犯了不少错误. 不过, 最终我的代码和主流也稍微有所不同, 因为我试图解决一类常见但也经常不被注意到的问题, 就是绑定可以引入名字和<q>关键词</q>相同的变量, 这时的处理我选择和一般的Scheme实现一致. 但是, 似乎网上别人上传的作业解答都没有注意到这一点. 当然, 这也不能算很重要就是了.</p><p><code>parse-scheme</code>这个pass的输入语言的句法如下:<pre><code>&lt;exp> ::= &lt;fixnum>
       |  &lt;boolean>
       |  (quote &lt;datum>)
       |  &lt;var>
       |  (if &lt;exp> &lt;exp>)
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (set! &lt;var> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;var>*) &lt;exp>+)
       |  (let ((&lt;var> &lt;exp>)*) &lt;exp>+)
       |  (letrec ((&lt;var> &lt;exp>)*) &lt;exp>+)
       |  (and &lt;exp>*)
       |  (or &lt;exp>*)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)
&lt;datum> ::= ()
         |  &lt;boolean>
         |  &lt;fixnum>
         |  (&lt;datum> . &lt;datum>)
         |  #(&lt;datum>*)
&lt;boolean> ::= #t
           |  #f</code></pre>这里当然有一些需要解释的地方, 而且还有一些额外的限制, 但是这些限制没有体现在句法里. 首先, <code>&lt;fixnum></code>是一个<math><mn>61</mn></math>位的带符号整数. 至于为什么是<math><mn>61</mn></math>位, 这是因为我们拿了<math><mn>3</mn></math>位用作类型标记 (type tag). Scheme是一种动态类型的语言, 所以需要运行时的类型标记. 另外, 可以提前剧透一下, <code>&lt;fixnum></code>的类型标记是<code>000</code>, 这不是随意选择的, 而是有原因的. 当然, 原因之后再说. <code>&lt;var></code>实际上就是一个Scheme符号而已, 不是其他东西. 单分支的<code>if</code>, 理论上而言是利用其副作用, 若是不能成立, 我们选择返回<code>(void)</code>, 这是许多Scheme实现的选择, 用其表达利用副作用的意图. 当然, 单分支的<code>if</code>是以宏扩展一般的方式转化为正常的<code>if</code>表达式的. 非终结符后面跟着的星号叫做Kleene star, 这是相当标准的东西, 表示零个或任意有限多个. 非终结符后面跟着的加号叫做Kleene plus, 也基本上是相当标准的东西, 表示一个或(更多的)任意有限多个. <code>begin</code>表达式可以有多个句法参数, 但是只有最后一个才是作为值意图的, 其余的那些表达式我们则是意图利用其副作用. <code>lambda</code>, <code>let</code>, <code>letrec</code>这三种构造里出现的诸变量应该是互异的, 这没有什么可说的. <code>let</code>和<code>letrec</code>的绑定规则, 其实大家也是知道的, 当然的确是有所不同的. <code>and</code>和<code>or</code>也相当于是利用宏扩展实现的, 会被转换为嵌套的<code>if</code>表达式. 应用一个原始过程和应用非原始过程的句法其实很像, 不过其实在这种情况下的确是必要的. 读者可能会发现, <code>&lt;prim></code>竟然不能单独出现, 这其实和正常的Scheme实现还不太一样. 不过, 也不是什么大的限制, 毕竟可以使用<math><mi>&eta;</mi></math>扩展. 当然, 编译器可以考虑纳入这种单独出现的原始过程引用的句法, 但是这里无所谓啦. 之前只出现了<code>and</code>和<code>or</code>, <code>not</code>去哪里了呢, <code>not</code>是一个过程, 而不是特殊句法. 不过, 老实说, <code>not</code>也将以宏展开的形式实现就是了. 我们选取的Scheme子集的每个过程都有固定的元数 (arity), 原始过程当然不例外, 我们会检查应用原始过程时元数是否正确. 至于在最一般的情况下检查元数是否合规, 其实不是简单的问题. 的确可以做一部分简单的情况, 但是我不想增加复杂性了. 老实说, 在句法上区分原始过程应用和非原始过程应用对于之后的pass是有益的, 但是P423里没有这么做. 我怀疑出发点还是在于这使得中间的pass看起来会更像是普通的Scheme表达式, 因而检查的时候可以直接在Scheme的REPL里尝试, 不知道Kent Dybvig是不是这样想的. 反正不管怎么说, 我们并没有进行区分. 最后我们来说说<code>&lt;datum></code>, 但其实也没有什么可说的了. 序对和向量的记号都是按照Lisp语言的记法来的, 所以Lisper应该都能理解. 注意, 这里没有符号字面量, 因为实现符号需要另外的机制, 其实不算复杂, 但是估计Kent Dybvig认为没有必要教这种东西, 之后学生可以自己学会. 大概要说的就是这么多了.</p><p>我现在意识到我几年前写的每个pass都犯了一个共同的错误, 就是没有区分原始过程应用和非原始过程应用. 以我的直觉来看, 这应该会导致一些混乱而不清晰的代码, 比如说很多时候原始应用不必再次进入递归过程之中. 这会导致一个问题, 处理变量的逻辑有时还需要剔除意外而来的原始过程, 这并不符合follow the syntax的精神. 至于是否一定会造成什么问题, 我其实回忆不起来很细节的事情了. 但是印象中, 可能因此出现的问题我应该是以丑陋的方式解决了.</p><p>现在其实可以动笔开始写了, 不过在这之前, 其实我们还需要写一些辅助过程, 辅助过程被放在<code>utils.rkt</code>里. 正好, 我们也可以说明一下编译器整体的结构, 实际上非常简单. 每个编译器pass都是独立(成一个文件)的, 只依赖于<code>utils.rkt</code>, 然后都会provide一个过程. 最后, 有一个文件将这些pass组合在一起, 形成一个完整的编译器.</p><p>首先, 我们需要<code>unique-symbol</code>来生成唯一的标识符, 这是通过一个全局的计数器实现的.<pre><code>(define (make-counter x)
  (lambda ()
    (set! x (+ x 1))
    x))
(define unique-symbol
  (let ((counter (make-counter -1)))
    (lambda (x)
      (string->symbol
       (format &quot;~s.~s&quot; x (counter))))))</code></pre>这个标识符实际上很有特点, 它将计数器信息保存在了名字里.</p><p>其次, 我们需要实现集合. 其实, Racket的确有一个集合数据结构, 而且效率肯定比我们随便用顺序可达的列表实现的集合要高. 但是呢, 现在我们的确不在乎编译的效率, 也没想着测试复杂的输入. 不论如何, 之后都可以再改.<pre><code>(define (set? x)
  (cond ((null? x) #t)
        ((memq (car x) (cdr x)) #f)
        (else (set? (cdr x)))))
(define (set-cons x s)
  (if (memq x s)
      s
      (cons x s)))
(define (U s1 s2)
  (cond ((null? s1) s2)
        ((memq (car s1) s2) (U (cdr s1) s2))
        (else (cons (car s1) (U (cdr s1) s2)))))
(define (I s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (cons (car s1) (I (cdr s1) s2)))
        (else (I (cdr s1) s2))))
(define (D s1 s2)
  (cond ((null? s1) '())
        ((memq (car s1) s2) (D (cdr s1) s2))
        (else (cons (car s1) (D (cdr s1) s2)))))</code></pre></p><p>接着, 让我们想一想我们对于<code>&lt;fixnum></code>的要求, 写下谓词<code>target-fixnum?</code>.<pre><code>(define (target-fixnum? x)
  (and (integer? x)
       (exact? x)
       (<= (- (expt 2 60)) x (- (expt 2 60) 1))))</code></pre>当然, 谓词<code>datum?</code>也不要忘了.<pre><code>(define (datum? x)
  (or (null? x) (boolean? x) (target-fixnum? x)
      (and (pair? x) (datum? (car x)) (datum? (cdr x)))
      (and (vector? x)
           (let ((len (vector-length x)))
             (let loop ((i 0))
               (cond ((= len i) #t)
                     ((datum? (vector-ref x i)) (loop (+ i 1)))
                     (else #f)))))))</code></pre></p><p>最后, 让我们写下用来解构<code>let</code>或<code>letrec</code>绑定的过程, 以及构造<code>let</code>或<code>letrec</code>构造的过程. 老实说, 没有必要将中间表示设计得看上去和Scheme长得一样, 但是可能Kent Dybvig乐意这么做吧. 另外, nanopass本身提供了方便解构和构造这类东西的机制, 但是我们没有就是了, 所以不得不采取这种看起来比较迂回的方法.<pre><code>(define (: bds k)
  (k (map car bds) (map cadr bds)))
(define (Let x* e* body)
  (list 'let (map list x* e*) body))
(define (Letrec x* e* body)
  (list 'letrec (map list x* e*) body))</code></pre></p><p>好了, 差不多就是这样. 如果之后用到什么其他的辅助过程, 那就之后再说. 接下来, 我们终于开始着手写<code>parse-scheme</code>.</p><p>在<code>parse-scheme</code>的内部, 我们会有两个互递归的过程<code>parse</code>和<code>parse-form</code>. 这两者的功能很容易从名字中看出来, <code>parse-form</code>用来parse特殊形式相关的构造, 其余则由<code>parse</code>处理, <code>parse</code>可以接受一般的<code>&lt;exp></code>作为参数.</p><pre><code>(define (parse-scheme exp)
  (define prim-env
    '((+ . 2)
      (- . 2)
      (* . 2)
      (= . 2)
      (&lt; . 2)
      (> . 2)
      (&lt;= . 2)
      (>= . 2)
      (null? . 1)
      (boolean? . 1)
      (fixnum? . 1)
      (pair? . 1)
      (vector? . 1)
      (box? . 1)
      (procedure? . 1)
      (eq? . 2)
      (not . 1)
      (cons . 2)
      (car . 1)
      (cdr . 1)
      (set-car! . 2)
      (set-cdr! . 2)
      (make-vector . 1)
      (vector-length . 1)
      (vector-ref . 2)
      (vector-set! . 3)
      (box . 1)
      (unbox . 1)
      (set-box! . 2)
      (void . 0)))
  (define (make-body exps env)
    (cond ((null? exps) (error 'parse-scheme &quot;empty begin body&quot;))
          ((null? (cdr exps)) ((parse env) (car exps)))
          (else (cons 'begin (map (parse env) exps)))))
  (define (parse env)
    (lambda (exp)
      (match exp
        (,n (guard (number? n)) (if (target-fixnum? n)
                                    `(quote ,n)
                                    (error 'parse-scheme &quot;invalid number ~s&quot; n)))
        (,b (guard (boolean? b)) `(quote ,b))
        (,x (guard (symbol? x))
            (cond ((assq x env) => cdr)
                  ((assq x prim-env)
                   (error 'parse-scheme
                          &quot;primitive ~s should not appear independently&quot; x))
                  (else (error 'parse-scheme &quot;unbound variable ~s&quot; x))))</code></pre><p><code>parse-scheme</code>起手是这样的, 实际上我们还未触及什么实质性的逻辑. 即便如此, 还是有一些应该解释的东西. <code>prim-env</code>是一个固定的上下文, 在递归过程中不会发生改变. 或许有的人将其当作基础的环境, 在递归中会得到增长, 但从概念上来说这么做是有点混乱的, 不过能达成目的就行. <code>prim-env</code>里记录了原始过程的名字和其对应的元数, 元数是用来检查原始应用表达式的. <code>env</code>和<code>prim-env</code>不同, 其记录的是旧名字和新名字之间的绑定. 另外, 读者看到, 我们的确不允许原始过程单独以变量的形式的出现. 对于常量, 我们会将其用<code>quote</code>包裹, 这约简了句法的复杂性 (也就是减少了一些产生式). 至于<code>make-body</code>的作用, 之后我们才会看到, 它主要是为了将<code>&lt;exp>+</code>都转换为恰好一个<code>&lt;exp></code>. 多于一个<code>&lt;exp></code>的情况下, 我们会将其转换成<code>begin</code>形式, 这是我们所期望的语义.</p><pre><code>        ((,rator . ,rands)
         (if (symbol? rator)
             (let ((a (assq rator env)))
               (if a
                   (let ((rator (cdr a))
                         (rands (map (parse env) rands)))
                     (cons rator rands))
                   (let ((a (assq rator prim-env)))
                     (if a
                         (let ((arity (cdr a)))
                           (unless (= (length rands) arity)
                             (error 'parse-scheme
                                    &quot;arity mismatch expected ~s given ~s&quot;
                                    arity (length rands)))
                           (let ((rands (map (parse env) rands)))
                             (if (eq? rator 'not)
                                 `(if ,(car rands) '#f '#t)
                                 (cons rator rands))))
                         ((parse-form env) exp)))))
             (map (parse env) exp))))))</code></pre><p><code>parse</code>的最后一部分还是比较复杂的, 我们需要分类拆解来看. 首先, 在<code>rator</code>是一个符号的情况下, 实际上有两种可能. 一种可能是原始过程应用, 还有一种可能是非原始过程应用. 我们需要先在环境中去检索这个符号, 如果存在的话, 就说明其应该是一个非原始过程应用. 这里有一个很自然的地方, 就是如果绑定变量的名字和原始过程一致, 那么这个绑定就会遮盖原始过程. 因此, 我们不能先在原始环境中检索符号, 那不符合输入语言的语义. 若是环境中没有这个符号, 那么就在原始环境中寻找. 若是找到了, 就说明这是一个原始过程应用. 并且, 此时我们可以检查元数的一致性. 这里我们对于<code>not</code>进行了特殊处理, 对其进行了扩展. 如果环境和原始环境中都找不到这个符号, 说明这个表达式可能是一个特殊形式, 所以接下来的任务就交给<code>parse-form</code>了. 当然, 我们不能排除这个符号是在引用一个未绑定的变量, 不过这件事情当然也交由<code>parse-form</code>处理. 以上我们只考虑了<code>rator</code>为一个符号的情况, 实际上<code>rator</code>还有可能是一个表达式, 那么此时肯定是一个非原始的过程应用, 我们以直接的结构递归对待.</p><pre><code>  (define (parse-form env)
    (lambda (exp)
      (match exp
        ((quote ,d) (if (datum? d)
                        exp
                        (error 'parse-scheme &quot;invalid datum ~s&quot; d)))
        ((if ,q ,a) `(if ,((parse env) q) ,((parse env) a) (void)))
        ((if ,q ,a ,e) `(if ,((parse env) q) ,((parse env) a) ,((parse env) e)))
        ((set! ,x ,e)
         (let ((x (cond ((assq x env) => cdr)
                        ((assq x prim-env)
                         (error 'parse-scheme &quot;can't assign to prim ~s&quot; x))
                        (else (error 'parse-scheme &quot;unbound variable ~s&quot; x))))
               (e ((parse env) e)))
           `(set! ,x ,e)))
        ((begin . ,exps) (make-body exps env))
        ((and . ,exps)
         (if (null? exps)
             ''#t
             (let ((exps (map (parse env) exps)))
               (let loop ((exp (car exps)) (exps (cdr exps)))
                 (if (null? exps)
                     exp
                     `(if ,exp ,(loop (car exps) (cdr exps)) '#f))))))
        ((or . ,exps)
         (if (null? exps)
             ''#f
             (let ((exps (map (parse env) exps)))
               (let loop ((exp (car exps)) (exps (cdr exps)))
                 (if (null? exps)
                     exp
                     (let ((t (unique-symbol 't)))
                       `(let ((,t ,exp))
                          (if ,t ,t ,(loop (car exps) (cdr exps))))))))))</code></pre><p>我们继续来看<code>parse-form</code>. 这一部分所做的事情基本都是自明的. 对于<code>and</code>和<code>or</code>形式的扩展方式, 每一个Schemer应该都不陌生. 这本质上和利用宏来实现<code>and</code>和<code>or</code>如出一辙. 在扩展<code>or</code>的时候, 不要忘了使用<code>let</code>绑定引入临时变量以避免重复求值.</p><pre><code>        ((lambda ,x* . ,exps)
         (unless (set? x*)
           (error 'parse-scheme &quot;invalid formals ~s&quot; x*))
         (let* ((x*^ (map unique-symbol x*))
                (env^ (append (map cons x* x*^) env))
                (body (make-body exps env^)))
           `(lambda ,x*^ ,body)))
        ((let ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme &quot;invalid let LHS vars ~s&quot; x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env) e*))
                     (body (make-body exps env^)))
                (Let x*^ e* body)))))
        ((letrec ,bds . ,exps)
         (: bds
            (lambda (x* e*)
              (unless (set? x*)
                (error 'parse-scheme &quot;invalid letrec LHS vars ~s&quot; x*))
              (let* ((x*^ (map unique-symbol x*))
                     (env^ (append (map cons x* x*^) env))
                     (e* (map (parse env^) e*))
                     (body (make-body exps env^)))
                (Letrec x*^ e* body)))))
        (,else (error 'parse-scheme &quot;unbound variable ~s&quot; (car exp))))))
  ((parse '()) exp))</code></pre><p>以上就是<code>parse-scheme</code>的全部代码了. 这段程序主要是处理绑定结构. 对于这三种绑定结构, 我们都需要使用<code>unique-symbol</code>来引入新的名字, 然后将这些旧名字和新名字之间的绑定加入到环境中. 我们对于<code>let</code>和<code>letrec</code>的处理几乎是完全一致的, 只是在处理<code>e*</code>那里, <code>let</code>的环境是<code>env</code>, 而<code>letrec</code>的环境是<code>env^</code>, 这反映了两者在语义上的不同.</p><p>让我们来看几个例子. 注意, 变量的编号并不重要, 应该<math><mi>&alpha;</mi></math>等价地阅读.<pre><code>> (parse-scheme
   '(letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 88)))
'(letrec ((even?.0 (lambda (n.2) (if (= n.2 '0) '#t (odd?.1 (- n.2 '1)))))
          (odd?.1 (lambda (n.3) (if (= n.3 '0) '#f (even?.0 (- n.3 '1))))))
   (even?.0 '88))</code></pre><pre><code>> (parse-scheme '(and 1 2 3 4 5))
'(if '1 (if '2 (if '3 (if '4 '5 '#f) '#f) '#f) '#f)</code></pre><pre><code>> (parse-scheme '(or 1 2 3 4 5))
'(let ((t.0 '1))
   (if t.0
     t.0
     (let ((t.1 '2))
       (if t.1 t.1 (let ((t.2 '3)) (if t.2 t.2 (let ((t.3 '4)) (if t.3 t.3 '5))))))))</code></pre><pre><code>> (parse-scheme
   '(let ((x 0))
      (let ((x (+ x 1)))
        (let ((x (+ x 2)))
          (+ x 3)))))
'(let ((x.0 '0)) (let ((x.1 (+ x.0 '1))) (let ((x.2 (+ x.1 '2))) (+ x.2 '3))))</code></pre></p><p>本部分的最后, 我们应该给出<code>parse-scheme</code>的输出语言的句法.<pre><code>&lt;exp> ::= (quote &lt;datum>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (set! &lt;uvar> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;uvar>*) &lt;exp>)
       |  (let ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre>我们看到, <code>&lt;var></code>变成了<code>&lt;uvar></code>. 并且, 产生式的种类更少, 也更加规整了.</p><h2>作业14: <code>convert-complex-datum</code></h2><p>这次作业需要编写多个pass, 不过先让我们来完成<code>convert-complex-datum</code>. 这个pass的目的在于将复杂的<code>&lt;datum></code>转换为简单的<code>&lt;immediate></code>, 其中<code>&lt;immediate></code>的句法为<pre><code>&lt;immediate> ::= ()
             |  &lt;boolean>
             |  &lt;fixnum></code></pre>那么其他的<code>&lt;datum></code>该怎么办呢? 答曰, 通过某些原始过程的组合得到, 并且在一开始就进行分配. 何谓原始过程的组合, 我们来枚举一些例子.<pre><code>'(#t . #f)</code></pre>将被转化为<pre><code>(cons '#t '#f)</code></pre><pre><code>'#(#t #f)</code></pre>将被转化为<pre><code>(let ((vec.0 (make-vector '2)))
  (begin
    (vector-set! vec.0 '0 '#t)
    (vector-set! vec.0 '1 '#f)
    vec.0))</code></pre>当然, <code>vec.0</code>这个变量的编号只是意思一下, 不代表实际一定会是这样.</p><p>既然在一开始就分配这些常量, 我们需要在执行的过程中记录一些绑定. 这些绑定可以随着执行过程一起传递, 也可以定义一个全局变量, 通过赋值来积累这些绑定. 在这里更多是一种口味问题, 我认为没有明显的优劣, 两种风格我都尝试过.</p><pre><code>(define (convert-datum x)
  (cond ((pair? x)
         (list 'cons (convert-datum (car x)) (convert-datum (cdr x))))
        ((vector? x)
         (let ((l (vector-length x)))
           (if (= l 0)
               '(make-vector '0)
               (let ((v (unique-symbol 'vec)))
                 `(let ((,v (make-vector (quote ,l))))
                    ,(let loop ((i l) (e* (cons v '())))
                       (if (= i 0)
                           (cons 'begin e*)
                           (let ((i (- i 1)))
                             (loop i
                                   (cons
                                    `(vector-set!
                                      ,v (quote ,i)
                                      ,(convert-datum (vector-ref x i)))
                                    e*))))))))))
        (else `(quote ,x))))</code></pre><p>当然, 不论采用何种风格, 首先我们都需要编写转换过程<code>convert-datum</code>. 这个过程没有什么难的, 就是很直接的结构递归.</p><p>以下我将展示两种风格, 首先是利用副作用来积累绑定的版本.</p><pre><code>(define (convert-complex-datum exp)
  (define bindings '())
  (define (add-binding! datum)
    (define t (unique-symbol 't))
    (define d (convert-datum datum))
    (push! (list t d) bindings)
    t)
  (define (convert exp)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (add-binding! d)
                      exp))</code></pre><p>这是<code>convert-complex-datum</code>的开头, 我们定义了一个全局的变量<code>bindings</code>. 当我们遇到一个复杂的<code>&lt;datum></code>时, 就会调用<code>add-binding!</code>, 作为命名约定的<code>!</code>是在提示我们该过程含有副作用. 它会生成一个新的变量, 然后构造这个变量和转换之后的<code>&lt;datum></code>之间的绑定, 将其添加到<code>bindings</code>里, 并且最终返回生成的这个变量, 其中<code>push!</code>是一个特殊形式, 可以按照以下方式定义.<pre><code>(define-syntax push!
  (syntax-rules ()
    ((_ x l) (set! l (cons x l)))))</code></pre></p><p>实际上主要的逻辑就集中于开头, 剩余的代码只是一些定式而已.</p><pre><code>      (,uvar (guard (symbol? uvar)) uvar)
      ((if ,q ,a ,e) `(if ,(convert q)
                          ,(convert a)
                          ,(convert e)))
      ((set! ,uvar ,exp) `(set! ,uvar ,(convert exp)))
      ((begin . ,exps) (cons 'begin (map convert exps)))
      ((lambda ,x* ,body) `(lambda ,x* ,(convert body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map convert e*))
                  (body (convert body)))
              (Letrec x* e* body)))))
      ((,prim . ,rands)
       (guard (prim? prim))
       `(,prim . ,(map convert rands)))
      ((,rator . ,rands)
       (map convert exp))))
  (let ((exp (convert exp)))
    (if (null? bindings)
        exp
        `(let ,bindings ,exp))))</code></pre><p>最后, 如果没有绑定, 也没有必要添加空的<code>let</code>就是了. 当然, 这是一个可有可无的优化, 主要目的只是让我看得更顺眼一点. 另外, 还有一点要说, 通过<code>prim?</code>来区分是否是原始应用看起来有点尴尬, 但是既然我们没有设计直接分辨两者的句法, 那么这的确是必要的. 至于如何实现, 没有什么秘密, 读到这里的人应该都明白.</p><p>接着, 让我们展示不基于副作用来积累绑定的版本, 或者说更函数式的版本. 有的人可能更喜欢这个版本, 这是因为在刚才的版本里, 有些求值顺序是由实现隐式决定的, 不那么确定或者说具有可预测性. 更函数式的版本允许我们细致地控制求值顺序, 这样不同的Scheme实现也可以显而易见地产生相同的结果.</p><pre><code>(define (convert-complex-datum exp)
  (define (convert* exp* k)
    (if (null? exp*)
        (k '() '())
        (convert
         (car exp*)
         (lambda (exp bindings0)
           (convert*
            (cdr exp*)
            (lambda (exp* bindings1)
              (k (cons exp exp*)
                 (append bindings0 bindings1))))))))
  (define (convert exp k)
    (match exp
      ((quote ,d) (if (or (pair? d) (vector? d))
                      (let ((t (unique-symbol 't)))
                        (k t `((,t ,(convert-datum d)))))
                      (k exp '())))</code></pre><p>还是先来看开头, 这奠定了代码的基本结构. 我们使用了所谓的延续传递风格来返回多值, 这只是一种可能的手段, 当然还有其他各种写法. <code>convert*</code>基于<code>convert</code>, 它意图转换一列表达式, 并将得到的绑定合并起来. 当然, 更准确地说, <code>convert*</code>和<code>convert</code>是一种互递归的关系. 对于<code>(quote ,d)</code>的处理和之前并没有本质区别, 只是我们现在将结果传递给<q>延续参数</q><code>k</code>而已.</p><pre><code>      (,uvar (guard (symbol? uvar)) (k uvar '()))
      ((if ,q ,a ,e)
       (convert*
        (cdr exp)
        (lambda (qae bindings)
          (k (cons 'if qae) bindings))))
      ((set! ,uvar ,exp)
       (convert exp (lambda (exp bindings)
                      (k `(set! ,uvar ,exp) bindings))))
      ((begin . ,exp*)
       (convert* exp* (lambda (exp* bindings)
                        (k (cons 'begin exp*) bindings))))
      ((lambda ,x* ,body)
       (convert body (lambda (body bindings)
                       (k `(lambda ,x* ,body) bindings))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (convert*
             e* (lambda (e* bindings0)
                  (convert
                   body (lambda (body bindings1)
                          (k (Let x* e* body)
                             (append bindings0 bindings1)))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (convert*
             e* (lambda (e* bindings0)
                  (convert
                   body (lambda (body bindings1)
                          (k (Letrec x* e* body)
                             (append bindings0 bindings1)))))))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (convert* rands (lambda (rands bindings)
                         (k (cons prim rands) bindings))))
      ((,rator . ,rands) (convert* exp k))))
  (convert exp (lambda (exp bindings)
                 (if (null? bindings)
                     exp
                     `(let ,bindings ,exp)))))</code></pre><p>以上是剩下来的代码, 没有什么好说的. 我们通常遵循这样一种模式, 通过<code>convert</code>或者<code>convert*</code>进行转换, 然后对于返回的表达式和绑定加工一下再返回.</p><p>现在让我们来看一些例子. 当然, 在这之前, 我们需要将<code>convert-complex-datum</code>和<code>parse-scheme</code>连接起来, 通过函数复合<code>compose</code>.</p><pre><code>(define compil
  (compose convert-complex-datum
           parse-scheme
           ))</code></pre><p>接着才是例子.</p><pre><code>> (compil '(letrec ((append (lambda (l1 l2)
                              (if (null? l1)
                                  l2
                                  (cons (car l1)
                                        (append (cdr l1) l2))))))
             (append '(0 1 2) '(3 4 5))))
'(let ((t.3 (cons '0 (cons '1 (cons '2 '())))) (t.4 (cons '3 (cons '4 (cons '5 '())))))
   (letrec ((append.0
             (lambda (l1.1 l2.2)
               (if (null? l1.1) l2.2 (cons (car l1.1) (append.0 (cdr l1.1) l2.2))))))
     (append.0 t.3 t.4)))</code></pre><pre><code>> (compil '(+ 1 (* 2 3)))
'(+ '1 (* '2 '3))</code></pre><pre><code>> (compil '(vector-length '#(0 1 2)))
'(let ((t.0
        (let ((vec.1 (make-vector '3)))
          (begin
            (vector-set! vec.1 '0 '0)
            (vector-set! vec.1 '1 '1)
            (vector-set! vec.1 '2 '2)
            vec.1))))
   (vector-length t.0))</code></pre><pre><code>> (compil ''#(#(0) (1) (#t #f)))
'(let ((t.0
        (let ((vec.1 (make-vector '3)))
          (begin
            (vector-set!
             vec.1
             '0
             (let ((vec.2 (make-vector '1))) (begin (vector-set! vec.2 '0 '0) vec.2)))
            (vector-set! vec.1 '1 (cons '1 '()))
            (vector-set! vec.1 '2 (cons '#t (cons '#f '())))
            vec.1))))
   t.0)</code></pre><p>本部分的最后, 让我们给出<code>convert-complex-datum</code>的输出语言的句法.<pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (set! &lt;uvar> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;uvar>*) &lt;exp>)
       |  (let ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)
&lt;immediate> ::= ()
             |  &lt;boolean>
             |  &lt;fixnum></code></pre>实际上句法没有发生很大的变化, 只有<code>&lt;datum></code>被替换为了<code>&lt;immediate></code>.</p><h2>作业14: <code>uncover-assigned</code></h2><p>现在让我们接着完成<code>uncover-assigned</code>, 这个pass实际上是为了<code>convert-assignments</code>作准备, 当然<code>purify-letrec</code>也会用到这里得到的信息. <code>uncover-assigned</code>是为了分析被赋值了的变量, 然后在这些变量被绑定引入的地方标示出来. 正如刚才所说, <code>uncover-assigned</code>是为了<code>convert-assignments</code>作准备, <code>convert-assignments</code>的目的在于消除赋值. 消除赋值的方法是将<code>set!</code>形式转换为等效的利用<code>box</code>相关函数的表达式. 为什么要消除赋值呢? 这是因为在赋值存在的情况下之后的闭包变换难以进行.</p><p><code>uncover-assigned</code>写起来当然也非常容易, 不过这次我们最好要先明确其输出语言的句法.<pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (set! &lt;uvar> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;uvar>*) (assigned (&lt;uvar>*) &lt;exp>))
       |  (let ((&lt;uvar> &lt;exp>)*) (assigned (&lt;uvar>*) &lt;exp>))
       |  (letrec ((&lt;uvar> &lt;exp>)*) (assigned (&lt;uvar>*) &lt;exp>))
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre>我们看到, 只有三种绑定结构<code>lambda</code>, <code>let</code>, <code>letrec</code>的句法发生了变化, 也就是记录了被赋值的变量. 为了明显起见, 这里还使用了<code>assigned</code>进行提示, 但是从功能上来说这可有可无, 只是便于阅读而已.</p><p>编写<code>uncover-assigned</code>需要我们分析和积累被赋值的变量, 并自下而上地传递. 当我们碰到绑定结构时, 它会<q>截胡</q>由它引入且被赋值的变量, 这其实有点让人联想到<code>lambda</code>绑定自由变量的过程. 诚然如此, 之后当我们进行闭包变换时, 首先要进行<code>uncover-free</code>来分析自由变量, 而其写法与<code>uncover-assigned</code>如出一辙. 多说一句, 自下而上地分析也保证了我们分析的被赋值变量和自由变量与绑定结构(的遮盖行为)相适配.</p><pre><code>(define (uncover-assigned exp)
  (define (uncover* exp*)
    (if (null? exp*)
        (values '() '())
        (let-values (((exp u*) (uncover (car exp*)))
                     ((exp* v*) (uncover* (cdr exp*))))
          (values (cons exp exp*) (U u* v*)))))
  (define (uncover exp)
    (match exp
      ((quote ,i) (values exp '()))
      (,uvar (guard (symbol? uvar)) (values exp '()))
      ((if ,q ,a ,e)
       (let-values (((qae u*) (uncover* (cdr exp))))
         (values (cons 'if qae) u*)))
      ((set! ,uvar ,exp)
       (let-values (((exp u*) (uncover exp)))
         (values `(set! ,uvar ,exp)
                 (set-cons uvar u*))))</code></pre><p>这是<code>uncover-assigned</code>的开头, 我展示了一种和<code>convert-complex-datum</code>不同的返回多值的方法, 也就是使用<code>values</code>. 这里最值得关注的其实是处理<code>(set! ,uvar ,exp)</code>的部分, <code>uvar</code>是被赋值的变量, 当然也不要忘记<code>exp</code>的被赋值变量. <code>set-cons</code>和<code>U</code>类似, 但只是添加一个元素到某个集合中.</p><pre><code>      ((begin . ,exp*)
       (let-values (((exp* u*) (uncover* exp*)))
         (values (cons 'begin exp*) u*)))
      ((lambda ,x* ,body)
       (let-values (((body u*) (uncover body)))
         (values `(lambda ,x*
                    (assigned ,(I x* u*) ,body))
                 (D u* x*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*) (uncover* e*))
                         ((body v*) (uncover body)))
              (values (Let x* e* `(assigned ,(I x* v*) ,body))
                      (U u* (D v* x*)))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let-values (((e* u*) (uncover* e*))
                         ((body v*) (uncover body)))
              (define w* (U u* v*))
              (values (Letrec x* e* `(assigned ,(I x* w*) ,body))
                      (D w* x*))))))</code></pre><p>接着, 我们应该将注意力集中到三种绑定结构上来: <code>lambda</code>, <code>let</code>, <code>letrec</code>. 处理这三种构造的代码都是清晰的, 只是我想提请读者注意一下<code>letrec</code>和<code>let</code>的处理方式的确不同, <code>letrec</code>的绑定可以管辖到它的右支的那些表达式, 因而需要将<code>e*</code>的被赋值变量<code>u*</code>和<code>body</code>的被赋值变量<code>v*</code>并为<code>w*</code>.</p><pre><code>      ((,prim . ,rands)
       (guard (prim? prim))
       (let-values (((rands u*) (uncover* rands)))
         (values `(,prim . ,rands) u*)))
      ((,rator . ,rands) (uncover* exp))))
  (let-values (((exp u*) (uncover exp)))
    (if (null? u*)
        exp
        (error 'uncover-assigned &quot;unbound assigned variables ~s&quot; u*))))</code></pre><p>收尾的部分并不那么有趣, 只是我们需要注意, 我们并不期望存在未被绑定的被赋值变量. 当然了, 一般来说这不太可能, 因为未被绑定的变量在<code>parse-scheme</code>那里就被拦截下来了. 不过, 层层设防还是有好处的, 因为笔误是永远也无法排除的.</p><p>说点无关紧要的话, 就是我们的转换是<q>保守</q>的. 何谓保守, 就是我们没有试图分析什么样的赋值是在<em>运行时</em>真正可达的, 而是将所有具有嫌疑的变量都一网打尽. 当然, 根据可计算理论的经典结果, 想要完美地进行这种分析在一般情况下是不可能的. 因此, 其实绝大多数编译器中的pass都是保守的. 不过, 的确我们在之后是可以有机会去优化一下的, 不过现在不是好时机.</p><p>以下是一些例子, 当然记得更新<code>compil</code>的定义.</p><pre><code>> (compil '(let ((counter (let ((x 0))
                            (lambda ()
                              (set! x (+ x 1))
                              x))))
             (counter)
             (counter)
             (counter)))
'(let ((counter.0
        (let ((x.1 '0))
          (assigned
           (x.1)
           (lambda () (assigned () (begin (set! x.1 (+ x.1 '1)) x.1)))))))
   (assigned () (begin (counter.0) (counter.0) (counter.0))))</code></pre><pre><code>> (compil '(letrec ((append (lambda (l1 l2)
                              (if (null? l1)
                                  l2
                                  (cons (car l1)
                                        (append (cdr l1) l2))))))
             (append '(0 1 2) '(3 4 5))))
'(let ((t.3 (cons '0 (cons '1 (cons '2 '()))))
       (t.4 (cons '3 (cons '4 (cons '5 '())))))
   (assigned
    ()
    (letrec ((append.0
              (lambda (l1.1 l2.2)
                (assigned
                 ()
                 (if (null? l1.1)
                   l2.2
                   (cons (car l1.1) (append.0 (cdr l1.1) l2.2)))))))
      (assigned () (append.0 t.3 t.4)))))</code></pre><h2>作业14: <code>purify-letrec</code></h2><p>老实说, 我并不真正理解<code>purify-letrec</code>. 但是, 既然它将要做的事情描述得很明确, 只是写一写没有多大问题.</p><p><code>letrec</code>的问题在于它太灵活了, 其实对它稍作限制, 也不会影响任何常见程序的表达. 不过, 既然Scheme的原则就是消除限制, 那么我就不得不严肃一点思考怎么处理<code>letrec</code>.</p><p>如果一个Scheme实现不提供<code>letrec</code>, 那么我们可以通过宏来实现<code>letrec</code>, 其中最简单但也最低效的转换方式是将<pre><code>(letrec ((x e) ...) body)</code></pre>变换为<pre><code>(let ((x (void)) ...)
  (let ((t e) ...)
    (set! x t)
    ...
    body))</code></pre>其中诸<code>t</code>是新的变量. 为什么说这种方式低效呢? 因为它会阻碍之后的优化.</p><p><code>letrec</code>并非洪水猛兽, 对于最简单纯粹的<code>letrec</code>, 我们想直接保留其形式. 何谓纯粹呢? 也就是说, <code>letrec</code>的右支诸表达式均为<code>lambda</code>表达式, 并且由该<code>letrec</code>引入的诸变量均未得到赋值, 例如<pre><code>(letrec ((even? (lambda (n)
                  (if (= n 0)
                      #t
                      (odd? (- n 1)))))
         (odd? (lambda (n)
                 (if (= n 0)
                     #f
                     (even? (- n 1))))))
  (even? 88))</code></pre></p><p>现在让我们来详细描述作业14里的<code>purify-letrec</code>的所作所为. 首先, <code>letrec</code>的右支诸表达式和体都会递归地应用这个转换. 接着, 我们将<code>letrec</code>的绑定分为三种情况, 分别是简单, lambda, 复杂. lambda我们已经说过了, 也就是右支是一个<code>lambda</code>且其绑定至的变量未被赋值. 至于简单和复杂之分, 还是让我引用作业的原文吧.<blockquote>A simple expression contains no occurrences of the variables bound by the <code>letrec</code> expression and no applications unless nested within <code>lambda</code> expressions. The latter constraint prevents simple expressions from reaching a call to <code>call/cc</code> if we ever add <code>call/cc</code> to our language. Of course, at that time we would also rule out primitive calls to <code>call/cc</code> itself. It would also make sense to disallow <code>letrec</code> expressions, to prevent this pass from becoming nonlinear, and to disallow other expressions, such as <code>lambda</code> expressions, to reduce the cost of the <q>simple</q> check. Use your own judgement on this as long as you do treat as simple constants, references to variables not bound by the letrec, and primitive calls with simple operands.</blockquote>可以看到, 对于简单表达式的判定存在一定的灵活空间. 不过, 简单绑定还不完全等同于简单表达式, 它还需要被绑定至的变量没有被赋值. 若是一个绑定不满足这两个条件中的任何一个, 那么它就是一个复杂绑定. <s>(其实这里我有个小小的疑问, 就是如果<code>letrec</code>的右支表达式引用了其绑定的变量, 然而却没有被<code>lambda</code>包裹, 那么此时其实编译器按照<code>letrec</code>的语义应该引起一个异常才对. (当然, 被<code>lambda</code>包裹还是有可能被求值, 此时还是应该引起异常.) 换言之, 一个合理的<code>letrec</code>表达式的右支出现的没有包裹在<code>lambda</code>里的变量一定是不会引用该<code>letrec</code>绑定的变量的. 我的猜测是, 这留待运行时才会抛出异常, 因为全然分析这种可能性应该也是不可计算的. 不过, 在简单的情形下, 检查出这种错误应该是容易的, 比如上述情况.)</s></p><p>最终, 在我们将<code>letrec</code>的绑定划分为了<pre><code>(x_s e_s) ... : simple
(x_l e_l) ... : lambda
(x_c e_c) ... : complex</code></pre>之后, 我们所期望的变换是<pre><code>(let ((x_s e_s) ...)
  (assigned ()
    (let ((x_c (void)) ...)
      (assigned (x_c ...)
        (letrec ((x_l e_l) ...)
          (let ((x_t e_c) ...)
            (assigned ()
              (begin
                (set! x_c x_t)
                ...
                body))))))))</code></pre>其中<code>x_t ...</code>是新的变量. 我们看到, <code>letrec</code>已没有了<code>assigned</code>, 这是因为<code>letrec</code>所绑定的每个变量均不会被赋值.</p><pre><code>(define (purify-letrec exp)
  (define (purify exp)
    (match exp
      ((quote ,i) exp)
      (,uvar (guard (symbol? uvar)) uvar)
      ((if ,q ,a ,e)
       (cons 'if (map purify (cdr exp))))
      ((set! ,uvar ,exp)
       `(set! ,uvar ,(purify exp)))
      ((begin . ,exp*)
       (cons 'begin (map purify exp*)))
      ((lambda ,x* (assigned ,u* ,body))
       `(lambda ,x*
          (assigned ,u* ,(purify body))))
      ((let ,bds (assigned ,u* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (Let x* e* `(assigned ,u* ,body))))))</code></pre><p>以上这些代码对于<code>purify-letrec</code>而言都不是实质性的, 所以让我们将注意力聚焦到对于<code>letrec</code>的处理上来.</p><pre><code>      ((letrec ,bds (assigned ,u* ,body))
       (: bds
          (lambda (x* e*)
            (let ((e* (map purify e*))
                  (body (purify body)))
              (define (assigned? x) (memq x u*))
              (define (bound? x) (memq x x*))
              (define (lambda? e)
                (and (pair? e)
                     (eq? (car e) 'lambda)))
              (define (simple? e)
                (match e
                  ((quote ,i) #t)
                  (,x (guard (symbol? x)) (not (bound? x)))
                  ((if . ,e*) (andmap simple? e*))
                  ((begin . ,e*) (andmap simple? e*))
                  ((,prim . ,e*)
                   (guard (prim? prim))
                   (andmap simple? e*))
                  (,else #f)))
              (define (Leta x* e* u* body)
                (if (null? x*)
                    body
                    `(let ,(map list x* e*)
                       (assigned ,u* ,body))))</code></pre><p>首先, 我们应该做一些准备工作, 故我们递归地变换了<code>e*</code>和<code>body</code>, 并定义了<code>assigned?</code>, <code>bound?</code>, <code>lambda?</code>, <code>simple?</code>, <code>Leta</code>. 其中的<code>Leta</code>只是为了方便地构造带有<code>assigned</code>的<code>let</code>而已, 不过它还多做了一个判断, 避免空<code>let</code>绑定的产生.</p><pre><code>              (let iter ((x* x*)
                         (e* e*)
                         (xs* '())
                         (es* '())
                         (xl* '())
                         (el* '())
                         (xc* '())
                         (ec* '()))
                (if (null? x*)
                    (let ((xt* (map (lambda (x)
                                      (unique-symbol 't))
                                    xc*)))
                      (Leta
                       xs* es* '()
                       (Leta
                        xc* (map (lambda (x) '(void)) xc*) xc*
                        (Letrec
                         xl* el*
                         (Leta
                          xt* ec* '()
                          `(begin
                             ,@(map (lambda (xc xt)
                                      `(set! ,xc ,xt))
                                    xc* xt*)
                             ,body))))))</code></pre><p>这部分展示了我们通过一个迭代将绑定划分为不同的种类, 并且在划分结束后按照之前所描述的转换方式来构造表达式.</p><pre><code>                    (let ((x (car x*))
                          (x* (cdr x*))
                          (e (car e*))
                          (e* (cdr e*)))
                      (cond ((assigned? x)
                             (iter x* e* xs* es* xl* el*
                                   (cons x xc*) (cons e ec*)))
                            ((lambda? e)
                             (iter x* e* xs* es*
                                   (cons x xl*) (cons e el*)
                                   xc* ec*))
                            ((simple? e)
                             (iter x* e*
                                   (cons x xs*) (cons e es*)
                                   xl* el* xc* ec*))
                            (else
                             (iter x* e* xs* es* xl* el*
                                   (cons x xc*) (cons e ec*)))))))))))</code></pre><p>这部分是划分的逻辑: 如果变量被赋值, 那么不论如何绑定都是复杂的; 接着表达式有可能是lambda, 那么绑定就是lambda; 然后表达式有可能是简单的, 那么绑定就是简单的; 最后, 如果还没有被归类, 那无疑就是一个复杂绑定了.</p><pre><code>      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map purify rands)))
      ((,rator . ,rands)
       (map purify exp))))
  (purify exp))</code></pre><p>收尾没有什么令人惊讶的地方.</p><pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (set! &lt;uvar> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;uvar>*) (assigned (&lt;uvar>*) &lt;exp>))
       |  (let ((&lt;uvar> &lt;exp>)*) (assigned (&lt;uvar>*) &lt;exp>))
       |  (letrec ((&lt;uvar> (lambda (&lt;uvar>*) (assigned (&lt;uvar>*) &lt;exp>)))*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre><p>最后, 我们给出<code>purify-letrec</code>输出的语言的句法. 我们可以看到, <code>letrec</code>不再具有<code>assigned</code>形式, 并且其右支的诸表达式一定是<code>lambda</code>表达式.</p><p>以下是一些例子.</p><pre><code>> (compil
   '(letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 88)))
'(letrec ((odd?.1
           (lambda (n.3) (assigned () (if (= n.3 '0) '#f (even?.0 (- n.3 '1))))))
          (even?.0
           (lambda (n.2) (assigned () (if (= n.2 '0) '#t (odd?.1 (- n.2 '1)))))))
   (begin (even?.0 '88)))</code></pre><pre><code>> (compil
   '(letrec ((x 10))
      (set! x (+ x 1))
      x))
'(let ((x.0 (void)))
   (assigned
    (x.0)
    (letrec ()
      (let ((t.1 '10))
        (assigned () (begin (set! x.0 t.1) (begin (set! x.0 (+ x.0 '1)) x.0)))))))</code></pre><pre><code>> (compil
   '(letrec ((f (lambda ()
                  (set! f g)
                  1))
             (g (lambda () 0)))
      (f)))
'(let ((f.0 (void)))
   (assigned
    (f.0)
    (letrec ((g.1 (lambda () (assigned () '0))))
      (let ((t.2 (lambda () (assigned () (begin (set! f.0 g.1) '1)))))
        (assigned () (begin (set! f.0 t.2) (f.0)))))))</code></pre><p>我们没有试图消除冗余的<code>begin</code>, 不过这在之后的pass会被优化, 空<code>let</code>和<code>letrec</code>也是.</p><h2>作业14: <code>convert-assignments</code></h2><p><code>convert-assignments</code>施行的是所谓的赋值变换 (assignment conversion). 据我所知, 这是Kent Dybvig发明的, 用来解决闭包变换和赋值不能兼容的问题. 这个变换会降低具有大量赋值的程序的运行速度, 但是正常的Scheme程序应该也没有多少赋值.</p><p>目前, <code>let</code>和<code>lambda</code>还具有附加的<code>assigned</code>结构, 这将作为我们的脚手架使用. 我们会用<code>box</code>包裹被赋值变量的值, 将<code>set!</code>形式转变为对于函数<code>set-box!</code>的调用, 将对于被赋值变量的引用转变为通过调用<code>unbox</code>函数得到置于盒子 (box) 中的值.</p><p>举一个简单的例子或许比较容易理解.<pre><code>(let ((x '2) (y '3))
  (assigned (x)
    (begin
      (set! x (* x y))
      x)))</code></pre>会被转换成<pre><code>(let ((t '2) (y '3))
  (let ((x (box t)))
    (begin
      (set-box! x (* (unbox x) y))
      (unbox x))))</code></pre>对于<code>lambda</code>的处理也是类似的.</p><p><code>convert-assignments</code>应该是相当简单的pass. 注意到我们应该维护一个运行时的上下文, 其记录了哪些变量是被赋值了的.</p><pre><code>(define (convert-assignments exp)
  (define (Let x* e* body)
    (if (null? x*)
        body
        `(let ,(map list x* e*) ,body)))
  (define ((apply-env env) x)
    (cond ((assq x env) => cdr)
          (else x)))
  (define (convert env)
    (lambda (exp)
      (match exp
        ((quote ,i) exp)
        (,x (guard (symbol? x)) ((apply-env env) x))
        ((if ,q ,a ,e)
         (cons 'if (map (convert env) (cdr exp))))
        ((set! ,uvar ,exp)
         `(set-box! ,uvar ,((convert env) exp)))
        ((begin . ,exp*)
         (cons 'begin (map (convert env) exp*)))</code></pre><p>开头没有什么希奇的地方. 这里的<code>Let</code>是为了避免冗余的<code>let</code>绑定, 这是因为每当我们遇到<code>lambda</code>和<code>let</code>时, 都要试图转换<code>assigned</code>结构, 而对于空的<code>assigned</code>, 没有必要放置一个空的<code>let</code>绑定上去. 另外, <code>apply-env</code>具有两种不同的用途 (稍微算是滥用), 这在之后的代码中会看得很清楚.</p><pre><code>        ((lambda ,x* (assigned ,u* ,body))
         (define t*
           (map (lambda (x) (unique-symbol 't)) u*))
         (define ctx (map cons u* t*))
         (define y*
           (map (apply-env ctx) x*))
         (define box*
           (map (lambda (t) `(box ,t)) t*))
         (define env^
           (append (map (lambda (u)
                          (cons u `(unbox ,u))) u*)
                   env))
         (define body^ ((convert env^) body))
         `(lambda ,y*
            ,(Let u* box* body^)))</code></pre><p><code>convert</code>的实质逻辑集中在对于<code>lambda</code>和<code>let</code>的处理上. 我们先看<code>lambda</code>, <code>let</code>是完全类似的. 我们需要为被赋值的变量<code>u*</code>生成相应的新变量<code>t*</code>, 然后的处理基本上遵循之前的描述. 现在我们可以看到<code>env</code>的形状了, 它是被赋值变量<code>u</code>和表达式<code>`(unbox ,u)</code>的对应. 当然, 其实记录被赋值变量已经足够了, 这里只是一种可能的实现方式.</p><pre><code>        ((let ,bds (assigned ,u* ,body))
         (: bds
            (lambda (x* e*)
              (let* ((e* (map (convert env) e*))
                     (env^ (append
                            (map (lambda (u)
                                   (cons u `(unbox ,u))) u*)
                            env))
                     (body ((convert env^) body)))
                (define t*
                  (map (lambda (x) (unique-symbol 't)) u*))
                (define ctx (map cons u* t*))
                (define y*
                  (map (apply-env ctx) x*))
                (define box*
                  (map (lambda (t) `(box ,t)) t*))
                (Let y* e*
                     (Let u* box* body))))))</code></pre><p>对于<code>let</code>的处理基本上和<code>lambda</code>一样, 只是不要忘了转换右支<code>e*</code>, 其上下文仍应为<code>env</code>, 因为<code>let</code>绑定管辖不到其右支.</p><pre><code>        ((letrec ,bds ,body)
         (: bds
            (lambda (x* e*)
              (let ((e* (map (convert env) e*))
                    (body ((convert env) body)))
                (Letrec x* e* body)))))
        ((,prim . ,rands)
         (guard (prim? prim))
         (cons prim (map (convert env) rands)))
        ((,rator . ,rands)
         (map (convert env) exp)))))
  ((convert '()) exp))</code></pre><p>收尾相当平淡无奇. 可以看到, 对于<code>letrec</code>的处理完全是平凡的, 因为该做的事情在<code>purify-letrec</code>里就已经完成了.</p><pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (lambda (&lt;uvar>*) &lt;exp>)
       |  (let ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> (lambda (&lt;uvar>*) &lt;exp>))*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre><p>最后我们给出<code>convert-assignments</code>的输出语言的句法. 和<code>uncover-assigned</code>之前的语言的句法相比, 赋值形式<code>set!</code>消失了, 并且<code>letrec</code>的右支变得更加狭隘, 只能是<code>lambda</code>表达式了.</p><p>以下是一些例子.</p><pre><code>> (compil
   '(let ((x 0) (y 1) (z 2))
      (let ((counter (lambda ()
                       (set! x (+ x 1))
                       (set! z (+ z 2))
                       (cons x z))))
        (counter)
        (counter)
        (counter))))
'(let ((t.4 '0) (y.1 '1) (t.5 '2))
   (let ((x.0 (box t.4)) (z.2 (box t.5)))
     (let ((counter.3
            (lambda ()
              (begin
                (set-box! x.0 (+ (unbox x.0) '1))
                (set-box! z.2 (+ (unbox z.2) '2))
                (cons (unbox x.0) (unbox z.2))))))
       (begin (counter.3) (counter.3) (counter.3)))))</code></pre><pre><code>> (compil
   '(letrec ((f (lambda ()
                  (set! f g)
                  1))
             (g (lambda () 0)))
      (f)))
'(let ((t.3 (void)))
   (let ((f.0 (box t.3)))
     (letrec ((g.1 (lambda () '0)))
       (let ((t.2 (lambda () (begin (set-box! f.0 g.1) '1))))
         (begin (set-box! f.0 t.2) ((unbox f.0)))))))</code></pre><h2>作业13: <code>optimize-direct-call</code></h2><p><code>optimize-direct-call</code>是一个简单的优化步骤, 所以它不会改变句法. 它的想法也非常简单, 就是将<pre><code>((lambda (x ...) body) e ...)</code></pre>转换为<pre><code>(let ((x e) ...) body)</code></pre>这类似于通过宏来实现<code>let</code>的变换的逆.</p><pre><code>(define (optimize-direct-call exp)
  (define (optimize exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e)
       (cons 'if (map optimize (cdr exp))))
      ((begin . ,exp*)
       (cons 'begin (map optimize exp*)))
      ((lambda ,x* ,body)
       `(lambda ,x* ,(optimize body)))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map optimize e*))
                  (body (optimize body)))
              (Letrec x* e* body)))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map optimize rands)))</code></pre><p>以上只能算是样板代码 (boilerplate code). 若是借助于某种编译器框架, 或许可以写得更加简单.</p><pre><code>      ((,rator . ,rands)
       (let ((rator (optimize rator))
             (rands (map optimize rands)))
         (match rator
           ((lambda ,x* ,body)
            (unless (= (length x*) (length rands))
              (error 'optimize-direct-call
                     &quot;arity mismatch expected ~s given ~s&quot;
                     (length x*) (length rands)))
            (Let x* rands body))
           (,else (cons rator rands)))))))
  (optimize exp))</code></pre><p>处理应用是<code>convert</code>的实质部分, 其实也就是判断<code>rator</code>是否是<code>lambda</code>表达式而已.</p><p>句法没有发生变化, 不再赘述. 以下是一些例子.</p><pre><code>> (compil
   '((lambda (x y)
       (set! x (* x x))
       (set! y (* y y))
       (+ x y))
     3 4))
'(let ((t.2 '3) (t.3 '4))
   (let ((x.0 (box t.2)) (y.1 (box t.3)))
     (begin
       (set-box! x.0 (* (unbox x.0) (unbox x.0)))
       (set-box! y.1 (* (unbox y.1) (unbox y.1)))
       (+ (unbox x.0) (unbox y.1)))))</code></pre><pre><code>> (compil
   '(((lambda (x)
        (lambda (y)
          (+ x y)))
      1) 2))
'((let ((x.0 '1)) (lambda (y.1) (+ x.0 y.1))) '2)</code></pre><h2>作业13: <code>remove-anonymous-lambda</code></h2><p>顾名思义, <code>remove-anonymous-lambda</code>是为了消除匿名的<code>lambda</code>. 所谓的匿名<code>lambda</code>, 指的是没有直接出现在<code>let</code>或者<code>letrec</code>右支的<code>lambda</code>. 对于藏在右支而非直接出现的情况, 当然也应该视为匿名的.</p><p>对于匿名<code>lambda</code>的处理是很简单的, 即为其赋一个名字而已. 换言之, 匿名的<pre><code>(lambda (x ...) body)</code></pre>将被转换为<pre><code>(letrec ((t (lambda (x ...) body))) t)</code></pre>其中<code>t</code>是一个新的变量. 这样的转换不依赖于上下文, 直接进行即可.</p><pre><code>(define (remove-anonymous-lambda exp)
  (define (remove exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e)
       (cons 'if (map remove (cdr exp))))
      ((begin . ,exp*)
       (cons 'begin (map remove exp*)))
      ((lambda ,x* ,body)
       (define t (unique-symbol 't))
       (define l `(lambda ,x* ,(remove body)))
       `(letrec ((,t ,l)) ,t))</code></pre><p>以上代码中只有对于<code>lambda</code>的处理是实质性的. 能在这里被捕获的<code>lambda</code>一定是匿名的, 否则会被<code>let</code>和<code>letrec</code>截胡. 我们放心地生成新的变量<code>t</code>, 并施行前述的转换.</p><pre><code>      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(remove body)))
                               (,else (remove e))))
                           e*))
                  (body (remove body)))
              (Let x* e* body)))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(remove body)))))
                           e*))
                  (body (remove body)))
              (Letrec x* e* body)))))</code></pre><p>对于<code>let</code>和<code>letrec</code>的处理可以说是意料之中的事情, 它们大抵上是类似的. <code>let</code>和<code>letrec</code>都剔出了右支出现的<code>lambda</code>单独处理. 对于<code>let</code>而言, 这是为了避免引入冗余的<code>letrec</code>绑定. 对于<code>letrec</code>而言, 这则是必要的, 因为其右支只能是<code>lambda</code>. 因此, 处理<code>letrec</code>右支的<code>match</code>仅有一个分支, 其他情况并不符合句法.</p><pre><code>      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map remove rands)))
      ((,rator . ,rands)
       (map remove exp))))
  (remove exp))</code></pre><p>收尾是平淡无奇的, 输出语言的句法也并没有发生变化. 暂时我们还不能将<code>lambda</code>从产生式中剔除, 因为有些<code>lambda</code>是被<code>let</code>绑定的. 不过, 经过接下来的<code>sanitize-binding-forms</code>之后, 我们的确可以和<code>lambda</code>说再见了.</p><p>然而, 刚才我们的描述实际上并不够准确. 严格来说, <code>remove-anonymous-lambda</code>的输出实际上是原本句法的一个子集. 在编写之后的<code>sanitize-binding-forms</code>时, 既可以采用原本的句法, 也可以采用更加精细的句法. 从理论上来说, 后者应该有一定的效率优势. 当然, 说了这么多废话, 下面是更精细的句法.</p><pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (let ((&lt;uvar> &lt;exp0>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> &lt;lam>)*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)
&lt;exp0> ::= &lt;lam> | &lt;exp>
&lt;lam> ::= (lambda (&lt;uvar>*) &lt;exp>)</code></pre><p>看起来有点fancy, 不是吗? 不过这能将<code>lambda</code>表达式的出现限制在<code>let</code>和<code>letrec</code>的右支里.</p><p>以下是一些例子.</p><pre><code>> (compil
   '(let ((compose (lambda (f g)
                     (lambda (x)
                       (f (g x))))))
      ((compose (lambda (x) (* x x))
                (lambda (x) (+ x 3)))
       13)))
'(let ((compose.0
        (lambda (f.1 g.2) (letrec ((t.6 (lambda (x.3) (f.1 (g.2 x.3))))) t.6))))
   ((compose.0
     (letrec ((t.7 (lambda (x.4) (* x.4 x.4)))) t.7)
     (letrec ((t.8 (lambda (x.5) (+ x.5 '3)))) t.8))
    '13))</code></pre><pre><code>> (compil
   '(let ((c (let ((x 0))
               (lambda ()
                 (set! x (+ x 1))
                 x))))
      (c) (c) (c)))
'(let ((c.0
        (let ((t.2 '0))
          (let ((x.1 (box t.2)))
            (letrec ((t.3
                      (lambda ()
                        (begin (set-box! x.1 (+ (unbox x.1) '1)) (unbox x.1)))))
              t.3)))))
   (begin (c.0) (c.0) (c.0)))</code></pre><h2>作业13: <code>sanitize-binding-forms</code></h2><p><code>sanitize-binding-forms</code>的目的很简单, 也就是将<code>let</code>绑定的<code>lambda</code>表达式提取出来, 将其转换成由<code>letrec</code>绑定的. 在这个pass之后, 一切<code>lambda</code>表达式就都只能出现在<code>letrec</code>的右支了, 而且当然<code>letrec</code>的右支只能是<code>lambda</code>表达式. 另外, 虽然并非严格必要, <code>sanitize-binding-forms</code>还会消除空<code>let</code>和<code>letrec</code>, 以及冗余的<code>begin</code>. 在某种意义上, 这个pass算是进行闭包变换之前的一块里程碑. 因此, 修整一下程序也并非什么不可理解的事情.</p><p>从概念上来说, 编写这个pass并不困难, 应该说一切的要素都似曾相识. 不过, 最终的程序也不是很短, 这需要一点耐心.</p><pre><code>(define (sanitize-binding-forms exp)
  (define (Let x* e* body)
    (if (null? x*)
        body
        `(let ,(map list x* e*) ,body)))
  (define (Letrec x* e* body)
    (if (null? x*)
        body
        `(letrec ,(map list x* e*) ,body)))
  (define (make-begin exp*)
    (let ((exp* (append-map
                 (lambda (exp)
                   (match exp
                     ((begin . ,exp*) exp*)
                     (,else (list exp))))
                 exp*)))
      (if (null? (cdr exp*))
          (car exp*)
          (cons 'begin exp*))))
  (define (lambda? exp)
    (and (pair? exp)
         (eq? (car exp) 'lambda)))
  (define (sanitize exp)
    (match exp
      ((quote ,i) exp)
      (,x (guard (symbol? x)) x)
      ((if ,q ,a ,e)
       (cons 'if (map sanitize (cdr exp))))
      ((begin . ,exp*)
       (make-begin (map sanitize exp*)))</code></pre><p>以上的代码中, 避免空绑定的<code>Let</code>和<code>Letrec</code>, 判断是否是<code>lambda</code>表达式的谓词<code>lambda?</code>, 都应该是容易理解的. <code>make-begin</code>需要一点思考, 因为它并不是在一般情况下消除冗余<code>begin</code>的过程, 而是假定了<code>sanitize</code>的确能够消除冗余的<code>begin</code>. 这是结构递归的想法. 至于一般的<code>make-begin</code>, 可以写成<pre><code>(define (make-begin exp*)
  (define (flatten exp*)
    (append-map
     (lambda (exp)
       (match exp
         ((begin . ,exp*) (flatten exp*))
         (,else (list exp))))
     exp*))
  (let ((exp* (flatten exp*)))
    (if (null? (cdr exp*))
        (car exp*)
        (cons 'begin exp*))))</code></pre>不过我们真的有用到这个过程的机会吗? 我表示怀疑.</p><pre><code>      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(sanitize body)))
                               (,else (sanitize e))))
                           e*))
                  (body (sanitize body)))
              (let iter ((x* x*)
                         (e* e*)
                         (xo* '())
                         (eo* '())
                         (xl* '())
                         (el* '()))
                (if (null? x*)
                    (Letrec
                     xl* el*
                     (Let xo* eo* body))
                    (let ((x (car x*))
                          (x* (cdr x*))
                          (e (car e*))
                          (e* (cdr e*)))
                      (if (lambda? e)
                          (iter x* e* xo* eo*
                                (cons x xl*) (cons e el*))
                          (iter x* e* (cons x xo*) (cons e eo*)
                                xl* el*)))))))))</code></pre><p>对于<code>let</code>的处理是冗长的, 原因在于我们需要分类, 这看起来有点像之前的<code>purify-letrec</code>的某块内容, 但是概念上要简单得多. 我们只是要区分<code>lambda</code>和非<code>lambda</code>. <s>最近在GitHub上逛逛别人写的P423作业, 看到有人通过逐一判断的方式避免划分之后引入多余的<code>let</code>或<code>letrec</code>, 我觉得这种写法非常奇怪.</s></p><pre><code>      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (let ((e* (map (lambda (e)
                             (match e
                               ((lambda ,x* ,body)
                                `(lambda ,x* ,(sanitize body)))))
                           e*))
                  (body (sanitize body)))
              (Letrec x* e* body)))))
      ((,prim . ,rands)
       (guard (prim? prim))
       (cons prim (map sanitize rands)))
      ((,rator . ,rands)
       (map sanitize exp))))
  (sanitize exp))</code></pre><p>收尾没有什么好解释的地方, 如常而已.</p><pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (let ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> (lambda (&lt;uvar>*) &lt;exp>))*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre><p><code>sanitize-binding-forms</code>的输出语言的句法如上, 虽然之前我们已经刻画过了. 也就是说, 产生式里的<code>lambda</code>表达式没有了. 现在<code>lambda</code>表达式只能出现于<code>letrec</code>的右支, 且<code>letrec</code>的右支只能是<code>lambda</code>表达式.</p><p>以下是一些例子.</p><pre><code>> (compil '(begin 1 (begin 2 (begin (begin 3 4) 5) 6) 7))
'(begin '1 '2 '3 '4 '5 '6 '7)</code></pre><pre><code>> (compil
   '(letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 88)))
'(letrec ((odd?.1 (lambda (n.3) (if (= n.3 '0) '#f (even?.0 (- n.3 '1)))))
          (even?.0 (lambda (n.2) (if (= n.2 '0) '#t (odd?.1 (- n.2 '1))))))
   (even?.0 '88))</code></pre><pre><code>> (compil
   '(((lambda (x)
        (lambda (y)
          (+ x y)))
      1) 2))
'((let ((x.0 '1)) (letrec ((t.2 (lambda (y.1) (+ x.0 y.1)))) t.2)) '2)</code></pre><pre><code>> (compil
   '(((lambda (h)
        ((lambda (f) (f f))
         (lambda (g)
           (h (lambda (x) ((g g) x))))))
      (lambda (fact)
        (lambda (n)
          (if (= n 0)
              1
              (* n (fact (- n 1)))))))
     10))
'((letrec ((h.0
            (lambda (fact.4)
              (letrec ((t.6
                        (lambda (n.5)
                          (if (= n.5 '0) '1 (* n.5 (fact.4 (- n.5 '1)))))))
                t.6))))
    (letrec ((f.1
              (lambda (g.2)
                (h.0 (letrec ((t.7 (lambda (x.3) ((g.2 g.2) x.3)))) t.7)))))
      (f.1 f.1)))
  '10)</code></pre><h2>作业12: <code>uncover-free</code></h2><p>实际上作业13还包括<code>optimize-known-call</code>, 不过那是插入闭包变换中间的优化步骤, 所以先让我们来看作业12. <code>uncover-free</code>是闭包变换的预备步骤, 其分析每个<code>lambda</code>表达式的自由变量.</p><pre><code>(define (uncover-free exp)
  (define (Lam lam k)
    (match lam
      ((lambda ,x* ,body)
       (uncover
        body
        (lambda (body u*)
          (define v* (D u* x*))
          (k `(lambda ,x*
                (free ,v* ,body))
             v*))))))
  (define (Lam* lam* k)
    (if (null? lam*)
        (k '() '())
        (Lam
         (car lam*)
         (lambda (lam u*)
           (Lam*
            (cdr lam*)
            (lambda (lam* v*)
              (k (cons lam lam*)
                 (U u* v*))))))))
  (define (uncover* exp* k)
    (if (null? exp*)
        (k '() '())
        (uncover
         (car exp*)
         (lambda (exp u*)
           (uncover*
            (cdr exp*)
            (lambda (exp* v*)
              (k (cons exp exp*)
                 (U u* v*))))))))</code></pre><p>即便只是开头, 也能看出来<code>uncover-free</code>和<code>uncover-assigned</code>相当类似, 的确如此. 当然, <code>uncover-assigned</code>那里我们使用<code>values</code>返回多值, 而这里我们使用额外的延续参数<code>k</code>, 但这不是本质上的区别. <code>Lam</code>专门用于处理<code>lambda</code>表达式, 现在它只出现在右支. <code>Lam*</code>处理一列<code>lambda</code>表达式, <code>uncover*</code>处理一列表达式, 它们和<code>uncover</code>一道构成了互相递归的过程, 各司其职地处理相应的句法.</p><p>现在更详细地描述一下<code>Lam</code>, 它利用<code>uncover</code>分析<code>lambda</code>的体的自由变量, 然后除去被<code>lambda</code>的形式参数绑定的那些变量, 就得到了整个<code>lambda</code>表达式的自由变量. 最后, 我们将自由变量记录于<code>free</code>形式里.</p><pre><code>  (define (uncover exp k)
    (match exp
      ((quote ,i) (k exp '()))
      (,x (guard (symbol? x)) (k x (list x)))
      ((if ,q ,a ,e)
       (uncover*
        (cdr exp)
        (lambda (qae u*)
          (k (cons 'if qae) u*))))
      ((begin . ,exp*)
       (uncover*
        exp*
        (lambda (exp* u*)
          (k (cons 'begin exp*) u*))))
      ((let ,bds ,body)
       (: bds
          (lambda (x* e*)
            (uncover*
             e* (lambda (e* u*)
                  (uncover
                   body
                   (lambda (body v*)
                     (k (Let x* e* body)
                        (U u* (D v* x*))))))))))
      ((letrec ,bds ,body)
       (: bds
          (lambda (x* e*)
            (Lam*
             e* (lambda (e* u*)
                  (uncover
                   body
                   (lambda (body v*)
                     (k (Letrec x* e* body)
                        (D (U u* v*) x*)))))))))</code></pre><p>以上代码几乎只是常规而已. 不过, 或许应该再强调一下, <code>letrec</code>的右支受到<code>letrec</code>绑定的管辖, 而<code>let</code>的右支不会受到<code>let</code>绑定的管辖. 因此, 计算自由变量的代码也不太一样.</p><pre><code>      ((,prim . ,rands)
       (guard (prim? prim))
       (uncover rands
                (lambda (rands u*)
                  (k (cons prim rands) u*))))
      ((,rator . ,rands) (uncover* exp k))))
  (uncover
   exp (lambda (exp u*)
         (unless (null? u*)
           (error 'uncover-free
                  &quot;unbound variables ~s&quot; u*))
         exp)))</code></pre><p>收尾的时候, 如果整个表达式还有自由变量, 那一定是不太对的. 当然, 或许前面的pass已经能够排除这种情况了, 但我们的确没有必要省略这样的检查, 这有点类似于防御式编程.</p><pre><code>&lt;exp> ::= (quote &lt;immediate>)
       |  &lt;uvar>
       |  (if &lt;exp> &lt;exp> &lt;exp>)
       |  (begin &lt;exp>+)
       |  (let ((&lt;uvar> &lt;exp>)*) &lt;exp>)
       |  (letrec ((&lt;uvar> (lambda (&lt;uvar>*) (free (&lt;uvar>*) &lt;exp>)))*) &lt;exp>)
       |  (&lt;prim> &lt;exp>*)
       |  (&lt;exp> &lt;exp>*)</code></pre><p>句法的变动只出现在<code>lambda</code>表达式里.</p><p>以下是一些例子.</p><pre><code>> (compil
   '(letrec ((even? (lambda (n)
                      (if (= n 0)
                          #t
                          (odd? (- n 1)))))
             (odd? (lambda (n)
                     (if (= n 0)
                         #f
                         (even? (- n 1))))))
      (even? 88)))
'(letrec ((odd?.1
           (lambda (n.3) (free (even?.0) (if (= n.3 '0) '#f (even?.0 (- n.3 '1))))))
          (even?.0
           (lambda (n.2) (free (odd?.1) (if (= n.2 '0) '#t (odd?.1 (- n.2 '1)))))))
   (even?.0 '88))</code></pre><pre><code>> (compil
   '(((lambda (h)
        ((lambda (f) (f f))
         (lambda (g)
           (h (lambda (x) ((g g) x))))))
      (lambda (fact)
        (lambda (n)
          (if (= n 0)
              1
              (* n (fact (- n 1)))))))
     10))
'((letrec ((h.0
            (lambda (fact.4)
              (free
               ()
               (letrec ((t.6
                         (lambda (n.5)
                           (free
                            (fact.4)
                            (if (= n.5 '0) '1 (* n.5 (fact.4 (- n.5 '1))))))))
                 t.6)))))
    (letrec ((f.1
              (lambda (g.2)
                (free
                 (h.0)
                 (h.0
                  (letrec ((t.7 (lambda (x.3) (free (g.2) ((g.2 g.2) x.3)))))
                    t.7))))))
      (f.1 f.1)))
  '10)</code></pre><pre><code>> (compil
   '(let ((counter (let ((x 0))
                     (lambda ()
                       (set! x (+ x 1))
                       x))))
      (counter)
      (counter)
      (counter)))
'(let ((counter.0
        (let ((t.2 '0))
          (let ((x.1 (box t.2)))
            (letrec ((t.3
                      (lambda ()
                        (free
                         (x.1)
                         (begin (set-box! x.1 (+ (unbox x.1) '1)) (unbox x.1))))))
              t.3)))))
   (begin (counter.0) (counter.0) (counter.0)))</code></pre><h2>作业12: <code>convert-closures</code></h2><p>顾名思义, <code>convert-closures</code>进行闭包变换, 不过实际上它只是闭包变换的第一步, 而或许<code>uncover-free</code>应该算作闭包变换的第零步.</p></body></html>