<html><head><meta charset="utf-8"/><title>The Little Typer</title><link href="styles.css" rel="stylesheet"/></head><body><h1>The Little Typer</h1><h2 id="ch1">第1章 愈是变化, 愈是不变</h2><table class="dialogue"><tr><td class="leftd">欢迎回来!</td><td class="middled"><sup>1</sup></td><td class="rightd">很高兴回到这里!</td></tr></table><table class="dialogue"><tr><td class="leftd">让我们为一门叫做Pie的新语言擦拭并更新一些我们的旧玩具.<br/>以下东西是一个<code>Atom</code>, 这显然吗?<pre><code>'atom</code></pre></td><td class="middled"><sup>2</sup></td><td class="rightd">一点也不, <code>Atom</code>是什么意思?</td></tr></table><table class="dialogue"><tr><td class="leftd">要成为一个<code>Atom</code>, 就是要成为一个<em>原子(atom)</em>.<div class="comment"><b>注记.</b> 在Lisp中, 原子可以是符号, 数字, 以及其他许多东西. 但在这里, 原子只是符号.</div></td><td class="middled"><sup>3</sup></td><td class="rightd">那么, <code>'atom</code>是一个<code>Atom</code>是因为<code>'atom</code>是一个原子.</td></tr></table><table class="dialogue"><tr><td class="leftd">以下东西是一个<code>Atom</code>, 这显然吗?<pre><code>'ratatouille</code></pre><div class="tcomment"><b>译注.</b> ratatouille指的是普罗旺斯杂烩.</div></td><td class="middled"><sup>4</sup></td><td class="rightd">是的, 因为<code>'ratatouille</code>也是一个原子.<p>但是, 精确地说, 什么是一个原子呢?</p></td></tr></table><table class="dialogue" id="atom-definition"><tr><td class="leftd">原子是由一个单引号 (tick mark) 后跟着一个或更多的字母或者连字符而来的.<div class="comment"><b>注记.</b> 在Pie中, 只有原子使用单引号.</div></td><td class="middled"><sup>5</sup></td><td class="rightd">因此, 那么<pre><code>'is-it-obvious-that-this-is-an-atom</code></pre>显然是一个<code>Atom</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">当然了, 因为原子可以包含连字符.<br/>那么<pre><code>'---</code></pre>和<pre><code>---</code></pre>和<pre><code>'</code></pre>如何, 它们是原子吗?</td><td class="middled"><sup>6</sup></td><td class="rightd"><pre><code>'---</code></pre>是一个原子, 因为连字符可以出现在一个原子里的任何位置;<pre><code>---</code></pre>不是一个原子, 因为它缺少了单引号;<pre><code>'</code></pre>不是一个原子, 因为它的后面既没有跟着一个字母, 也没有跟着一个连字符.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'Atom</code>是一个<code>Atom</code>吗?</td><td class="middled"><sup>7</sup></td><td class="rightd">是的, 即便<code>'Atom</code>也是一个<code>Atom</code>, 因为它是一个单引号后面跟着一个或更多的字母或者连字符.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'at0m</code>是一个<code>Atom</code>吗?</td><td class="middled"><sup>8</sup></td><td class="rightd">不是, 因为根据<a href="#atom-definition">第1章第5框</a>, 原子只能包含字母或者连字符, 而字符<code>0</code>并不是一个字母, 它是数位零.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'cœurs-d-artichauts</code>是一个<code>Atom</code>吗?<div class="tcomment"><b>译注.</b> cœurs d'artichauts是一种食物, 即洋蓟心.</div></td><td class="middled"><sup>9</sup></td><td class="rightd">是的, 因为<code>œ</code>是一个字母.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'ἄτομον</code>是一个<code>Atom</code>吗?<div class="tcomment"><b>译注.</b> ἄτομον是一个古希腊语词, 意思是不可分割的东西, 即原子.</div></td><td class="middled"><sup>10</sup></td><td class="rightd">That's Greek to me!<div class="tcomment"><b>译注.</b> 这算是一语双关.</div>但是希腊字母也是字母, 所以它必然是一个<code>Atom</code>.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">单引号之律</div><p>一个单引号后直接跟着一个或更多的字母或者连字符则为一个<code>Atom</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">诸如<p><code>'ratatouille</code>是一个<code>Atom</code></p>和<p><code>'cœurs-d-artichauts</code>是一个<code>Atom</code></p>这样的句子被称为<em>判断(judgment)</em>.<div class="comment"><b>注记.</b> 感谢Per Martin-Löf (1942–).</div></td><td class="middled"><sup>11</sup></td><td class="rightd">判断的要义在于什么?</td></tr></table><table class="dialogue"><tr><td class="leftd">一个判断是一个人对于一个表达所采取的一个态度. 当我们得以获知什么东西时, 我们就在作出一个判断.<br/>关于<code>Atom</code>和<code>'courgette</code>, 可以判断什么?</td><td class="middled"><sup>12</sup></td><td class="rightd"><code>'courgette</code>是一个<code>Atom</code>.<div class="tcomment"><b>译注.</b> courgette指的是西葫芦.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">一个<em>判断形式(form of judgment)</em>是一个带有空白的观察, 例如<p>____是一个____.</p></td><td class="middled"><sup>13</sup></td><td class="rightd">还有其他的判断形式吗?</td></tr></table><table class="dialogue"><tr><td class="leftd"><q>判断 (judgment)</q>的另一种形式是<q>判断 (judgement)</q>.</td><td class="middled"><sup>14</sup></td><td class="rightd">十分有趣.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>'ratatouille</code></pre>和<pre><code>'ratatouille</code></pre>是相同的<pre><code>Atom</code></pre>吗?</td><td class="middled"><sup>15</sup></td><td class="rightd">是的.<p>它们之所以是相同的<code>Atom</code>, 是因为单引号之后有着相同的字母.</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>'ratatouille</code></pre>和<pre><code>'courgette</code></pre>是相同的<pre><code>Atom</code></pre>吗?</td><td class="middled"><sup>16</sup></td><td class="rightd">不是.<p>单引号之后, 它们有着不同的字母.</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">单引号之诫</div><p>两个表达式为相同的<code>Atom</code>, 如果它们的值是单引号后跟着完全等同的字母和连字符.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">第二种判断形式为<p>____和____是相同的____.</p></td><td class="middled"><sup>17</sup></td><td class="rightd">因而<p><code><u>'citron</u></code>和<code><u>'citron</u></code>是相同的<code><u>Atom</u></code></p>是一个判断.<div class="tcomment"><b>译注.</b> citron指的是香橼.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这的确是一个判断, 而且我们有理由去相信.<p><p><code>'pomme</code>和<code>'orange</code>是相同的<code>Atom</code></p>是判断吗?</p></td><td class="middled"><sup>18</sup></td><td class="rightd">诚然它是判断, 但是我们没有理由去相信它. 毕竟, 我们不该比较苹果 (apple) 和橙子.<div class="tcomment"><b>译注.</b> pomme是法语的苹果.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(cons 'ratatouille 'baguette)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>这显然吗?<div class="comment"><b>注记.</b> 当准备好的时候, 读[page 62]看<q>定型 (typing)</q>指令.</div></td><td class="middled"><sup>19</sup></td><td class="rightd">不, 完全不是.<p>成为一个<pre><code>(Pair Atom Atom)</code></pre>是什么意思呢?</p><div class="tcomment"><b>译注.</b> baguette指的是法棍面包.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">成为一个<pre><code>(Pair Atom Atom)</code></pre>就是要成为一个序对, 其<code>car</code>是一个<code>Atom</code>, 例如<code>'ratatouille</code>, 其<code>cdr</code>也是一个<code>Atom</code>, 例如<code>'baguette</code>.</td><td class="middled"><sup>20</sup></td><td class="rightd"><code>cons</code>, <code>car</code>, <code>cdr</code>看上去很眼熟. 不谈以前, 这里它们是什么意思呢? 它们和序对 (pair) 又有什么关系呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">一个序对以<code>cons</code>起手, 而以另外两个部分作结, 我们称其为它的<code>car</code>和<code>cdr</code>.<div class="comment"><b>注记.</b> 在Lisp中, <code>cons</code>可以使得列表更长. 但在这里, <code>cons</code>只是用来构造序对.</div></td><td class="middled"><sup>21</sup></td><td class="rightd">好吧, 这意味着之所以<pre><code>(cons 'ratatouille 'baguette)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>是因为<code>(cons 'ratatouille 'baguette)</code>是一个序对, 其<code>car</code>是一个<code>Atom</code>, 其<code>cdr</code>也是一个<code>Atom</code>.<p>那么, <code>cons</code>是一个<code>Pair</code>吗?</p></td></tr></table><table class="dialogue" id="alone"><tr><td class="leftd">甚至<code>cons</code>和<code>Pair</code>在单独情况下都不是表达式, 它们都需要两个参数.<p><pre><code>(cons 'ratatouille 'baguette)</code></pre>和<pre><code>(cons 'ratatouille 'baguette)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>吗?</p><div class="comment"><b>注记.</b> 在Lisp中, <code>cons</code>是一个过程, 有着其自身的含义, 但是诸如<code>cond</code>或<code>lambda</code>这样的形式如果单独出现则是没有意义的.</div></td><td class="middled"><sup>22</sup></td><td class="rightd">两个表达式为相同的<pre><code>(Pair Atom Atom)</code></pre>是什么意思呢?</td></tr></table><table class="dialogue" id="same-pair"><tr><td class="leftd">这意味着它们的<code>car</code>都是相同的<code>Atom</code>, 它们的<code>cdr</code>也都是相同的<code>Atom</code>.</td><td class="middled"><sup>23</sup></td><td class="rightd">那么的确<pre><code>(cons 'ratatouille 'baguette)</code></pre>和<pre><code>(cons 'ratatouille 'baguette)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(cons 'ratatouille 'baguette)</code></pre>和<pre><code>(cons 'baguette 'ratatouille)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>24</sup></td><td class="rightd"><pre><code>(cons 'ratatouille 'baguette)</code></pre>的<code>car</code>是<code>'ratatouille</code>而<pre><code>(cons 'baguette 'ratatouille)</code></pre>的<code>car</code>是<code>'baguette</code>.<p>因此, 我们没有理由去相信它们是相同的<code>(Pair Atom Atom)</code>.</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(cdr
 (cons 'ratatouille 'baguette))</code></pre>可以怎样描述呢?</td><td class="middled"><sup>25</sup></td><td class="rightd">它是一个<pre><code>Atom</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">描述其他表达式的表达式, 例如<code>Atom</code>, 被称为<em>类型(type)</em>.<p><code>(Pair Atom Atom)</code>是一个类型吗?</p><div class="comment"><b>注记.</b> 当一个名字 (例如<code>Pair</code>或者<code>Atom</code>) 牵涉类型时, 首字母会大写.</div></td><td class="middled"><sup>26</sup></td><td class="rightd">是的, 因为它描述了<code>car</code>和<code>cdr</code>均为<code>Atom</code>的序对.</td></tr></table><table class="dialogue"><tr><td class="leftd">第三种判断形式为<p>____是一个类型.</p></td><td class="middled"><sup>27</sup></td><td class="rightd">这意味着<p><code>Atom</code>是一个类型</p>和<p><code>(Pair Atom Atom)</code>是一个类型</p>都是判断.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>Atom</code>之律</div><p><code>Atom</code>是一个类型.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><p><code>'courgette</code>是一个类型.</p>是一个判断吗?</td><td class="middled"><sup>28</sup></td><td class="rightd">它的确是一个判断, 但是我们没有任何理由去相信它, 因为<code>'courgette</code>并不描述其他表达式.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Atom</code>和<code>Atom</code>是相同的类型吗?</td><td class="middled"><sup>29</sup></td><td class="rightd">想必如此, 它们看上去就应该是相同的类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">第四种判断形式, 也是最后一种, 如下<p>____和____是相同的类型.</p></td><td class="middled"><sup>30</sup></td><td class="rightd">那么, 所以说<p><code><u>Atom</u></code>和<code><u>Atom</u></code>是相同的类型</p>是一个判断, 并且我们有理由去相信它.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">判断的四种形式</div><ol><li>____是一个____.</li><li>____和____是相同的____.</li><li>____是一个类型.</li><li>____和____是相同的类型.</li></ol></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">以下是一个判断吗?<p><code>Atom</code>和<code>(Pair Atom Atom)</code>是相同的类型.</p></td><td class="middled"><sup>31</sup></td><td class="rightd">它是一个判断, 但是没有理由去相信它.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Pair Atom Atom)</code></pre>和<pre><code>(Pair Atom Atom)</code></pre>是相同的类型吗?</td><td class="middled"><sup>32</sup></td><td class="rightd">看起来相当可信啊.</td></tr></table><table class="dialogue"><tr><td class="leftd">判断是获知的行为, 而相信是获知的一部分.</td><td class="middled"><sup>33</sup></td><td class="rightd">判断难道不是句子吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">句子从理解它们的人那里获得意义. 句子捕获了我们所拥有的思想, 而思想比我们用来表达思想的词语要重要得多.</td><td class="middled"><sup>34</sup></td><td class="rightd">啊, 所以说得以获知<pre><code>(Pair Atom Atom)</code></pre>和<pre><code>(Pair Atom Atom)</code></pre>是相同的类型这一行为是一个判断.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p><code>'pêche</code>和<code>'pêche</code>是相同的<code>'fruit</code>吗?</p><div class="tcomment"><b>译注.</b> pêche指的是桃子.</div></td><td class="middled"><sup>35</sup></td><td class="rightd">好问题.<p><code>'pêche</code>是一个<code>'fruit</code>吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">不, 当然不是, 因为<p><code>'fruit</code>是一个类型</p>并不可信.<p>某些形式的判断只有在早前的判断的基础之上才具备意义.</p><div class="comment"><b>注记.</b> 这种早前的判断有时被称为<em>前置假定(presupposition)</em>.</div></td><td class="middled"><sup>36</sup></td><td class="rightd">有哪些呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">为了提问一个表达式是否由一个类型描述, 我们必须已经判断过给定的类型的确是一个类型. 为了提问两个表达式是否在一个类型下是相同的, 我们必须首先判断出这两个表达式都由该类型所描述.<div class="comment"><b>注记.</b> 当然, 为了描述那两个表达式, 那个给定的类型也得是类型.</div>在提问两个表达式是否是相同的类型之前, 有什么判断是必要的吗?</td><td class="middled"><sup>37</sup></td><td class="rightd">为了提问两个表达式是否是相同的类型, 我们必须先要判断这两个表达式的确都是类型.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(car
 (cons 'ratatouille 'baguette))</code></pre>和<pre><code>'ratatouille</code></pre>是相同的<pre><code>Atom</code></pre>吗?</td><td class="middled"><sup>38</sup></td><td class="rightd">看起来十分熟悉啊. 想必是这样, 因为<code>car</code>可以找到一个序对的<code>car</code>, 所以它们<em>是</em>相同的.</td></tr></table><table class="dialogue" id="ch1-39"><tr><td class="leftd"><pre><code>(cdr
 (cons 'ratatouille 'baguette))</code></pre>和<pre><code>'baguette</code></pre>是相同的<pre><code>Atom</code></pre>吗?</td><td class="middled"><sup>39</sup></td><td class="rightd">诚然如此, 因为这个序对的<code>cdr</code>是<code>'baguette</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">于是<pre><code>(car
 (cons
  (cons 'aubergine 'courgette)
  'tomato))</code></pre>是一个...<div class="tcomment"><b>译注.</b> aubergine指的是茄子.</div></td><td class="middled"><sup>40</sup></td><td class="rightd">... <code>(Pair Atom Atom)</code>, 因为<pre><code>(cons 'aubergine 'courgette)</code></pre>是一个序对, 其<code>car</code>是<code>Atom</code> <code>'aubergine</code>, 其<code>cdr</code>是<code>Atom</code> <code>'courgette</code>.</td></tr></table><table class="dialogue" id="ch1-41"><tr><td class="leftd"><pre><code>(car
 (cdr
  (cons
   'ratatouille
   (cons 'baguette 'olive-oil))))</code></pre>和<pre><code>'baguette</code></pre>是相同的<pre><code>Atom</code></pre>吗?</td><td class="middled"><sup>41</sup></td><td class="rightd">是的, 的确如此.</td></tr></table><table class="dialogue"><tr><td class="leftd">正如从<a href="#ch1-39">第1章第39框</a>到<a href="#ch1-41">第1章第41框</a>所展现的那样, 写法不同的表达式或许可能是相同的. 其中一种写法要比其他写法都更加直接.</td><td class="middled"><sup>42</sup></td><td class="rightd"><code>'baguette</code>的确看上去比<pre><code>(car
 (cdr
  (cons
   'ratatouille
   (cons 'baguette 'olive-oil))))</code></pre>更加直接.</td></tr></table><table class="dialogue"><tr><td class="leftd">一个表达式的<em>规范形式(normal form)</em>是书写该表达式最直接的方式. 任何两个相同的表达式都有着等同的规范形式, 并且任何两个有着等同规范形式的表达式都是相同的.</td><td class="middled"><sup>43</sup></td><td class="rightd"><code>'olive-oil</code>是<pre><code>(cdr
 (cdr
  (cons
   'ratatouille
   (cons 'baguette 'olive-oil))))</code></pre>的规范形式吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个问题是不完整的.<p>相同总是相对于某个类型而言的, 因此规范形式也由类型决定.</p></td><td class="middled"><sup>44</sup></td><td class="rightd"><code>'olive-oil</code>是<code>Atom</code><pre><code>(cdr
 (cdr
  (cons
   'ratatouille
   (cons 'baguette 'olive-oil))))</code></pre>的规范形式吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 的确如此.<pre><code>(cons 'ratatouille 'baguette)</code></pre>是一个规范的<pre><code>(Pair Atom Atom)</code></pre>吗?<div class="comment"><b>注记.</b> <em>规范的(normal)</em>是<em>具有规范形式(in normal form)</em>的简略说法.</div></td><td class="middled"><sup>45</sup></td><td class="rightd">是的, <code>(cons 'ratatouille 'baguette)</code>的确是规范的.<p>每个表达式都具有一个规范形式吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">如果不刻画一个表达式的类型, 那么提问其是否具有规范形式也是没有意义的.<p>然而, 给定一个类型, 每个由该类型描述的表达式的确都有一个由该类型确定的规范形式.</p></td><td class="middled"><sup>46</sup></td><td class="rightd">如果了两个表达式根据它们的类型是相同的, 那么它们就具有等同的规范形式. 因此, 这必然意味着我们可以通过比较两个表达式的规范形式来判断 (check) 它们是否相同.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">规范形式</div><p>给定一个类型, 每个由该类型所描述的表达式都具有一个<em>规范形式</em>, 这是书写该表达式最直接的方式. 如果两个表达式是相同的, 那么它们有着等同的规范形式. 如果两个表达式有着等同的规范形式, 那么它们是相同的.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(car
 (cons
  (cons 'aubergine 'courgette)
  'tomato))</code></pre>的规范形式是什么?</td><td class="middled"><sup>47</sup></td><td class="rightd">类型是什么呢?<p>如果类型是<pre><code>(Pair Atom Atom)</code></pre>那么规范形式为<pre><code>(cons 'aubergine 'courgette)</code></pre></p></td></tr></table><table class="dialogue"><tr><td class="leftd">干得好!<p>之前我们对于什么是一个<pre><code>(Pair Atom Atom)</code></pre>的描述其实是不完整的, 而完整的描述应该是...</p></td><td class="middled"><sup>48</sup></td><td class="rightd">...成为一个序对, 其<code>car</code>是一个<code>Atom</code>, 其<code>cdr</code>也是一个<code>Atom</code>, <em>或者是与这样一个序对相同的一个表达式.</em></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">规范形式和类型</div><p>相同总是根据一个类型来的, 因而规范形式也由类型决定.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(car
 (cons
  (cons 'aubergine 'courgette)
  'tomato))</code></pre>和<pre><code>(cons 'aubergine 'courgette)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>49</sup></td><td class="rightd">是的, 之所以这两个表达式是相同的<code>(Pair Atom Atom)</code>, 是因为<pre><code>(car
 (cons
  (cons 'aubergine 'courgette)
  'tomato))</code></pre>的规范形式是<pre><code>(cons 'aubergine 'courgette)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<pre><code>(cons 'aubergine 'courgette)</code></pre>和<pre><code>(cons 'aubergine 'courgette)</code></pre>是相同的<code>(Pair Atom Atom)</code>呢?</td><td class="middled"><sup>50</sup></td><td class="rightd">这看起来非常显然?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 但是不是每个<em>看上去</em>显然的东西<em>实际上</em>都是显然的.<p><a href="#same-pair">第1章第23框</a>描述了何谓一个表达式和另一个表达式是相同的<pre><code>(Pair Atom Atom)</code></pre></p><div class="comment"><b>注记.</b> 在Lisp中, 相同的原子使用两次<code>cons</code>产生的序对并不<code>eq</code>. 但在这里, 它们无法以任何方式进行区分.</div></td><td class="middled"><sup>51</sup></td><td class="rightd"><pre><code>(cons 'aubergine 'courgette)</code></pre>和<pre><code>(cons 'aubergine 'courgette)</code></pre>的顶层都是<code>cons</code>, <code>'aubergine</code>和<code>'aubergine</code>是相同的<code>Atom</code>, <code>'courgette</code>和<code>'courgette</code>是相同的<code>Atom</code>.<p>这两个表达式具有相同的<code>car</code>和相同的<code>cdr</code>, 因而它们是相同的<pre><code>(Pair Atom Atom)</code></pre></p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>cons</code>之第一诫</div><p>两个<code>cons</code>表达式是相同的<code>(Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)</code>, 如果它们的<code>car</code>是相同的<math><mi>A</mi></math>而它们的<code>cdr</code>是相同的<math><mi>D</mi></math>, 其中<math><mi>A</mi></math>和<math><mi>D</mi></math>代表任意的类型.</p></blockquote></td></tr></table><table class="dialogue" id="not-a-type"><tr><td class="leftd">很好.<pre><code>(Pair
 (cdr
  (cons Atom 'olive))
 (car
  (cons 'oil Atom)))</code></pre>的规范形式是什么呢?</td><td class="middled"><sup>52</sup></td><td class="rightd">我猜是<code>(Pair 'olive 'oil)</code>, 是这样吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 表达式<pre><code>(Pair
 (cdr
  (cons Atom 'olive))
 (car
  (cons 'oil Atom)))</code></pre>既不由某个类型刻画, 本身也不是一个类型, 因此提问其规范形式是毫无意义的.<div class="comment"><b>注记.</b> 不被类型刻画且自身不是类型的表达式也被称为是<em>病态类型(ill-typed)</em>的.</div></td><td class="middled"><sup>53</sup></td><td class="rightd">为什么呢?</td></tr></table><table class="dialogue" id="Pair-type"><tr><td class="leftd">因为<code>Pair</code>在其参数为实际原子时并非类型.<p>只有在其参数均为类型 (例如<code>Atom</code>) 时, 它才是一个表达式.</p></td><td class="middled"><sup>54</sup></td><td class="rightd">这是不是意味着<code>Pair</code>不能和<code>car</code>与<code>cdr</code>一起使用呢?</td></tr></table><table class="dialogue" id="type-eval"><tr><td class="leftd">不, 完全不是.<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>的规范形式是什么?</td><td class="middled"><sup>55</sup></td><td class="rightd">它的类型是什么呢? 规范形式总是相对于某个类型而言的.</td></tr></table><table class="dialogue"><tr><td class="leftd">类型本身也有规范形式. 如果两个类型有着等同的规范形式, 那么它们就是相同的类型. 如果两个类型是相同的类型, 那么它们就具有等同的规范形式.</td><td class="middled"><sup>56</sup></td><td class="rightd">类型<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>的规范形式必然是<code>(Pair Atom Atom)</code>, 因为<pre><code>(car
 (cons Atom 'olive))</code></pre>的规范形式为<code>Atom</code>, 并且<pre><code>(cdr
 (cons 'oil Atom))</code></pre>的规范形式也是<code>Atom</code>.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">类型的规范形式</div><p>每个为类型的表达式都具有一个规范形式, 其是书写该类型最直接的方式. 如果两个表达式是相同的类型, 那么它们有着等同的规范形式. 如果两个类型有着等同的规范形式, 那么它们是相同的类型.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">就是这样. 现在我们知道<pre><code>(cons 'ratatouille 'baguette)</code></pre>也是一个<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>因为...</td><td class="middled"><sup>57</sup></td><td class="rightd">...<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>的规范形式为<pre><code>(Pair Atom Atom)</code></pre>而<pre><code>(cons 'ratatouille 'baguette)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">另一种说法是<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>和<pre><code>(Pair Atom Atom)</code></pre>是相同的类型.</td><td class="middled"><sup>58</sup></td><td class="rightd">如果一个表达式是一个<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>那么它也是一个<pre><code>(Pair Atom Atom)</code></pre>因为这两个类型是相同的类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">类似地, 如果一个表达式是一个<pre><code>(Pair Atom Atom)</code></pre>那么它也是一个<pre><code>(Pair
 (car
  (cons Atom 'olive))
 (cdr
  (cons 'oil Atom)))</code></pre>因为这两个类型是相同的类型.</td><td class="middled"><sup>59</sup></td><td class="rightd">对于<pre><code>(Pair
 Atom
 (cdr
  (cons 'oil Atom)))</code></pre>也是类似的, 因为它和前面两个也是相同的类型.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'6</code>是一个<code>Atom</code>吗?</td><td class="middled"><sup>60</sup></td><td class="rightd">不是, 我们没有理由去相信<p><code>'6</code>是一个<code>Atom</code></p>因为数位<code>6</code>既非字母也非连字符, 不是吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<pre><code>(cons '17 'pepper)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>61</sup></td><td class="rightd">不, 因为<code>(cons '17 'pepper)</code>的<code>car</code>是<code>'17</code>, 它<em>并非</em>一个<code>Atom</code>.<p>尽管如此, 拥有数字应该也是很自然的事情才对.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">数字当然是很方便的. 除了<code>Atom</code>和<code>Pair</code>, 我们还可以判断某个东西是否是一个<code>Nat</code>.</td><td class="middled"><sup>62</sup></td><td class="rightd">让我们来试一下.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>1</code>是一个<code>Nat</code>吗?<div class="comment"><b>注记.</b> <code>Nat</code>是<em>自然数(natural number)</em>的缩写.</div></td><td class="middled"><sup>63</sup></td><td class="rightd">的确, <code>1</code>是一个<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>1729</code>是一个<code>Nat</code>吗?</td><td class="middled"><sup>64</sup></td><td class="rightd">是的, <code>1729</code>是一个<code>Nat</code>. 它不仅是一个<code>Nat</code>, 还很著名!<div class="comment"><b>注记.</b> 谢谢Srinivasa Ramanujan (1887–1920) 和Godfrey Harold Hardy (1877–1947).</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>-1</code>是一个<code>Nat</code>吗?</td><td class="middled"><sup>65</sup></td><td class="rightd">嗯, 你确定?</td></tr></table><table class="dialogue"><tr><td class="leftd">不, 当然不是. <code>-23</code>呢?</td><td class="middled"><sup>66</sup></td><td class="rightd">不是很清楚啊.</td></tr></table><table class="dialogue"><tr><td class="leftd">正数是<code>Nat</code>.</td><td class="middled"><sup>67</sup></td><td class="rightd">啊, 那么<code>-23</code>不是一个<code>Nat</code>?</td></tr></table><table class="dialogue"><tr><td class="leftd">我们更喜欢采取积极 (positive) 的态度.<div class="tcomment"><b>译注.</b> 这大概是一语双关吧.</div>最小的<code>Nat</code>是什么?</td><td class="middled"><sup>68</sup></td><td class="rightd"><code>0</code>不是一个自然数吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">啊, 所以我们也不能总是很积极. 我们该如何获得剩下来的<code>Nat</code>呢?<div class="comment"><b>注记.</b> 然而, 数字<code>1</code>总<em>是</em>正的.</div></td><td class="middled"><sup>69</sup></td><td class="rightd">我们可以使用我们的老朋友<code>add1</code>. 如果<math><mi>n</mi></math>是一个<code>Nat</code>, 那么<code>(add1 <math><mi>n</mi></math>)</code>也是一个<code>Nat</code>, 并且这个新的<code>Nat</code>永远是正数, 即便<math><mi>n</mi></math>是<code>0</code>.<p>有多少个<code>Nat</code>呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">很多很多!</td><td class="middled"><sup>70</sup></td><td class="rightd">存在最大的<code>Nat</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">并不, 因为我们总是可以...</td><td class="middled"><sup>71</sup></td><td class="rightd">...使用<code>add1</code>来加上一?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确是这样!<p><code>0</code>和<code>26</code>是相同的<code>Nat</code>吗?</p><div class="comment"><b>注记.</b> 谢谢Giuseppe Peano (1838-1932).</div></td><td class="middled"><sup>72</sup></td><td class="rightd">显然不是.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(+ 0 26)</code>和<code>26</code>是相同的吗?<div class="comment"><b>注记.</b> 即便我们还没有解释<code>+</code>, 暂时请用你自己对于加法的理解.</div></td><td class="middled"><sup>73</sup></td><td class="rightd">这个问题没有意义. 但是, 我们可以问它们是否是相同的<code>Nat</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">当然可以.<p><code>(+ 0 26)</code>和<code>26</code>是相同的<code>Nat</code>吗?</p></td><td class="middled"><sup>74</sup></td><td class="rightd">是的, 这是因为<code>(+ 0 26)</code>的规范形式为<code>26</code>, 而<code>26</code>和<code>26</code>当然是相同的.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>zero</code>的意思是什么呢?</td><td class="middled"><sup>75</sup></td><td class="rightd"><code>zero</code>和<code>0</code>是相同的吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">在Pie里, <code>zero</code>和<code>0</code>不过是书写同一个<code>Nat</code>的不同方式而已.<p><code>one</code>和<code>1</code>是相同的<code>Nat</code>吗?</p></td><td class="middled"><sup>76</sup></td><td class="rightd">嗯, 如果<code>zero</code>和<code>0</code>是相同的<code>Nat</code>的话, 那么这似乎很合理.</td></tr></table><table class="dialogue" id="definition"><tr><td class="leftd">实际上, <code>one</code>没有意义. 但是, <code>(add1 zero)</code>是书写数字<code>1</code>的另一种方式.<p>通过<em>定义</em>使得<code>one</code>为<code>(add1 zero)</code>的确是可行的.<pre class="dashed"><code>(define one
  (add1 zero))</code></pre></p></td><td class="middled"><sup>77</sup></td><td class="rightd">为什么这个定义周围用虚线框住了呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">虚线框意味着这个定义有点问题, 以至于它不能在之后使用.</td><td class="middled"><sup>78</sup></td><td class="rightd">这个定义有什么问题呢?<p>看上去很正常啊.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">当定义一个名字时, 有必要先<code>claim</code>这个名字具有一个类型, 而<code>one</code>是一个<code>Nat</code>.<pre><code>(claim one Nat)
(define one
  (add1 zero))</code></pre></td><td class="middled"><sup>79</sup></td><td class="rightd">因此, <code>two</code>可以被定义成<pre><code>(claim two Nat)
(define two
  (add1 one))</code></pre></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">定义前先声明</div><p>使用<code>define</code>将一个名字和一个表达式联系起来之前需要使用<code>claim</code>将名字和表达式的类型联系起来.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">如果<code>1</code>是书写<code>(add1 zero)</code>的另一种方式, 那么书写<code>4</code>的另一种方式是什么呢?</td><td class="middled"><sup>80</sup></td><td class="rightd">难道不应该是<pre><code>(add1
 (add1
  (add1
   (add1 zero))))</code></pre>吗? 我们不能定义<code>four</code>来指代这个表达式吗?</td></tr></table><table class="dialogue" id="top-add1"><tr><td class="leftd">当然可以了.<pre><code>(claim four Nat)
(define four
  (add1
   (add1
    (add1
     (add1 zero)))))</code></pre>那么, 再问一下书写<code>8</code>有另外的方式吗?</td><td class="middled"><sup>81</sup></td><td class="rightd">那必然是<pre><code>(<u>add1</u>
 (add1
  (add1
   (add1
    (add1
     (add1
      (add1
       (add1 zero))))))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>8</code>是规范的吗?</td><td class="middled"><sup>82</sup></td><td class="rightd">似乎如此, 但是为什么<code>8</code>是规范的呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">之所以<code>8</code>是<em>规范</em>的, 是因为其顶<code><u>add1</u></code>是一个<em>构造子(constructor)</em>, 并且塞在顶<code><u>add1</u></code>下面的参数, 即<code>7</code>, 也是规范的.<div class="comment"><b>注记.</b> <a href="#top-add1">第1章第81框</a>中的顶<code><u>add1</u></code>只此一次用下划线标注出来以示强调.</div></td><td class="middled"><sup>83</sup></td><td class="rightd">为什么<code>7</code>, 亦写作<pre><code>(add1
 (add1
  (add1
   (add1
    (add1
     (add1
      (add1 zero)))))))</code></pre>是规范的呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>7</code>是规范的完全是同理可得.</td><td class="middled"><sup>84</sup></td><td class="rightd">这意味着<code>zero</code>必然是规范的, 不然的话<code>(add1 zero)</code>就不是规范的了.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>zero</code>的顶是什么呢?</td><td class="middled"><sup>85</sup></td><td class="rightd">必须是<code>zero</code>.</td></tr></table><table class="dialogue" id="zero-constructor"><tr><td class="leftd">之所以<code>zero</code>是规范的, 是因为顶<code>zero</code>是一个构造子, 并且其没有参数.<pre><code>(add1
 (+ (add1 zero)
    (add1
     (add1 zero))))</code></pre>是规范的吗?</td><td class="middled"><sup>86</sup></td><td class="rightd">不是, 因为<code>+</code>不是构造子.</td></tr></table><table class="dialogue"><tr><td class="leftd">一个以构造子为顶的表达式被称为一个<em>值(value)</em>.<p>即便<pre><code>(add1
 (+ (add1 zero)
    (add1
     (add1 zero))))</code></pre>不是规范的, 它的确是一个值.</p><div class="comment"><b>注记.</b> 值也被称为<em>典则(canonical)</em>表达式.</div></td><td class="middled"><sup>87</sup></td><td class="rightd">这个表达式不是规范的, 是因为<pre><code>(+ (add1 zero)
   (add1
    (add1 zero)))</code></pre>并非书写<code>3</code>的最直接方式.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">值</div><p>以构造子为顶的表达式被称为<em>值</em>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">现在我们给出另一个并非规范的表达式.<pre><code>(+ (add1
    (add1 zero))
   (add1 zero))</code></pre>这是书写<code>3</code>的最直接方式吗?</td><td class="middled"><sup>88</sup></td><td class="rightd">肯定不是.<p>准确来说, 构造子究竟是什么呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">某些表达式是类型, 例如<code>Nat</code>和<code>(Pair Nat Atom)</code>.<p>对于新类型的解释的一部分是要说明其构造子为何. 构造子表达式是构造具有该类型的表达式的直接方式.</p></td><td class="middled"><sup>89</sup></td><td class="rightd">构造子的例子有哪些呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Nat</code>的构造子是<code>zero</code>和<code>add1</code>, 而<code>Pair</code>的构造子是<code>cons</code>.</td><td class="middled"><sup>90</sup></td><td class="rightd">值和规范形式之间有何关系?</td></tr></table><table class="dialogue"><tr><td class="leftd">在一个值里, 顶层的构造子的参数不必是规范的. 但如果这些参数的确是规范的, 那么整个构造子表达式就具有规范形式.<p>所有的值都是规范的吗?</p></td><td class="middled"><sup>91</sup></td><td class="rightd">显然不是.<pre><code>(add1
 (+ (add1 zero)
    (add1
     (add1 zero))))</code></pre>和<pre><code>(add1
 (+ (add1 zero) (add1 one)))</code></pre>都是值, 但是它们都不是规范的.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">值和规范形式</div><p>不是所有的值都具有规范形式. 这是因为构造子的参数不必是规范的. 每个表达式只有一个规范形式, 但是有时可能将其写成值的方式不止一种.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">以下空白方框里填什么会使得整个表达式<em>不</em>是一个<code>Nat</code>值呢?<pre><code>(add1 <span style="border: 2px solid white; display: inline-block;">          </span>)</code></pre></td><td class="middled"><sup>92</sup></td><td class="rightd"><code>'aubergine</code>怎么样?</td></tr></table><table class="dialogue"><tr><td class="leftd">诚然如此.<pre><code>(add1 'aubergine)</code></pre>并非一个<code>Nat</code>值, 因为<code>'aubergine</code>是一个<code>Atom</code>而不是一个<code>Nat</code>.<p>当填充这样的方框时, 我们的期望是作为结果的表达式由某个类型刻画.</p></td><td class="middled"><sup>93</sup></td><td class="rightd">然而, 若置于该方框里的是任何一个<code>Nat</code>表达式, 那么整个表达式就<em>是</em>一个值. 这一整个表达式以<code>add1</code>为顶, 而<code>add1</code>是一个<code>Nat</code>构造子.</td></tr></table><table class="dialogue"><tr><td class="leftd">找出一个与某起始表达式相同的值被称为<em>求值(evaluation)</em>.</td><td class="middled"><sup>94</sup></td><td class="rightd">类型呢? 毕竟, 相同需要类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">有时当我们提及相同时, 我们并不显式提及类型. 然而, 总是存在一个意图的类型, 并且这个类型可以通过仔细阅读找到.</td><td class="middled"><sup>95</sup></td><td class="rightd">难道求值指的不是找到一个表达式的<em>意义(meaning)</em>吗? 这不只是某个更简单的表达式.</td></tr></table><table class="dialogue"><tr><td class="leftd">我们这里的含义不一样. 表达式并不指向某种外部的意义概念&mdash;&mdash;在Pie中, 除了表达式和我们对于表达式的判断之外, 别无其他.<div class="comment"><b>注记.</b> 在Lisp中, 值和表达式是不同的, 而求值的结果是一个值.</div></td><td class="middled"><sup>96</sup></td><td class="rightd">这是一种看待求值的新方式.<p>为什么规范形式和值之间要做区分呢?</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">每个东西都是一个表达式</div><p>在Pie中, 值也是表达式. Pie中的求值是寻找一个表达式, 而不是其他别的什么东西.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">规范表达式没有可供求值的剩余机会了. 通常而言, 规范的表达式更容易理解. 然而, 往往找到一个值就足够了, 因为顶层的构造子可以用来判断接下来必然发生的事情.</td><td class="middled"><sup>97</sup></td><td class="rightd">如果找到一个值经常就足够了的话, 难道说这意味着我们可以自由地去寻找值, 并且然后可以想停就停呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">是这样的, 只要关于构造子的参数的信息从没有用到即可.<pre><code>(add1
 (+ (add1 zero)
    (add1
     (add1 zero))))</code></pre>和<code>four</code>是相同的<code>Nat</code>吗?</td><td class="middled"><sup>98</sup></td><td class="rightd">这里给出一个可能的回答.<p>它们不是相同的<code>Nat</code>, 因为<pre><code>(add1
 (+ (add1 zero)
    (add1
     (add1 zero))))</code></pre>是一个值, 而且它当然长得不像变量<code>four</code>. 找到<code>four</code>的值也无济于事, 因为<code>four</code>的值看起来非常不同.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">算是好的尝试.<p>但是, 实际上它们是相同的<code>Nat</code>.</p></td><td class="middled"><sup>99</sup></td><td class="rightd">怎么能这样呢?</td></tr></table><table class="dialogue" id="Nat-same"><tr><td class="leftd">两个不是值的<code>Nat</code>表达式相同, 如果它们的值相同. 恰存在两种<code>Nat</code>值可以相同的方式: 每种构造子一个.<p>如果两个都是<code>zero</code>, 那么它们就是相同的<code>Nat</code>.</p></td><td class="middled"><sup>100</sup></td><td class="rightd">那么两个值都以<code>add1</code>为顶的情况呢?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>zero</code>之诫</div><p><code>zero</code>和<code>zero</code>是相同的<code>Nat</code>.</p></blockquote></td></tr></table><table class="dialogue" id="add1-zero"><tr><td class="leftd">如果每个<code>add1</code>的参数是相同的<code>Nat</code>, 那么两个<code>add1</code>表达式是相同的<code>Nat</code>值.<p>为什么<pre><code>(add1 zero)</code></pre>和<pre><code>(add1 zero)</code></pre>是相同的<pre><code>Nat</code></pre></p></td><td class="middled"><sup>101</sup></td><td class="rightd">这两个表达式都是值. 这两个值都以<code>add1</code>为顶, 因此它们的参数应该是相同的<code>Nat</code>.<p>这两个参数都是<code>zero</code>, <code>zero</code>是一个值, 而且<code>zero</code>和<code>zero</code>是相同的<code>Nat</code>值.</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>add1</code>之诫</div><p>如果<math><mi>n</mi></math>和<math><mi>k</mi></math>是相同的<code>Nat</code>, 那么<code>(add1 <math><mi>n</mi></math>)</code>和<code>(add1 <math><mi>k</mi></math>)</code>是相同的<code>Nat</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<pre><code>(add1 (+ 0 1))</code></pre>和<pre><code>(add1 (+ 1 0))</code></pre>是相同的<pre><code>Nat</code></pre></td><td class="middled"><sup>102</sup></td><td class="rightd">这两个<code>Nat</code>都以<code>add1</code>为顶, 于是它们都是值.<p>它们之所以相同, 是因为<pre><code>(+ 0 1)</code></pre>和<pre><code>(+ 1 0)</code></pre>是相同的<pre><code>Nat</code></pre></p></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>(+ 0 1)</code>和<code>(+ 1 0)</code>是相同的<code>Nat</code>?</td><td class="middled"><sup>103</sup></td><td class="rightd">这些<code>Nat</code>并非值, 因而为了判断它们是否相同, 第一步应该是找出它们的值.<p>这两个表达式都以<code>(add1 zero)</code>为其一个值, 而<a href="#add1-zero">第1章第101框</a>解释了为什么<pre><code>(add1 zero)</code></pre>和<pre><code>(add1 zero)</code></pre>是相同的<pre><code>Nat</code></pre></p></td></tr></table><table class="dialogue"><tr><td class="leftd">很对.</td><td class="middled"><sup>104</sup></td><td class="rightd">是否这意味着<code>four</code>本可以按照以下方式定义?<pre class="dashed"><code>(define four
  (add1
   (+ (add1 zero)
      (add1
       (add1 zero)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么有虚线框呢?</td><td class="middled"><sup>105</sup></td><td class="rightd"><code>four</code>已经被定义了, 因而不能被再次定义.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">定义是永恒的</div><p>一旦一个名字被<code>claim</code>了, 那么它就不能被重新<code>claim</code>. 一旦一个名字被<code>define</code>了, 那么它就不能被重新<code>define</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">不过当然了, 一开始<code>four</code>的确可以像那样定义.<p>实际上, 其他表达式都不能分辨出<code>four</code>的两种定义之间的不同, 因为这两个定义了<code>four</code>为相同的<code>Nat</code>.</p></td><td class="middled"><sup>106</sup></td><td class="rightd"><code>cons</code>是一个构造子吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, <code>cons</code>构造<code>Pair</code>.</td><td class="middled"><sup>107</sup></td><td class="rightd">为了对于<code>car</code>表达式求值, 是否有必要对于<code>car</code>的参数求值?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确. 为了找出一个<code>car</code>表达式的值, 我们从找出其参数的值开始.<p>关于这参数的值, 我们能说什么呢?</p></td><td class="middled"><sup>108</sup></td><td class="rightd">这参数的值以<code>cons</code>为顶.</td></tr></table><table class="dialogue"><tr><td class="leftd">在找出参数的值之后, 接下来应该做什么呢?</td><td class="middled"><sup>109</sup></td><td class="rightd">整个表达式的值是<code>cons</code>的第一个参数.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(car
 (cons (+ 3 5) 'baguette))</code></pre>的值是什么?</td><td class="middled"><sup>110</sup></td><td class="rightd"><code>cons</code>的第一个参数是<pre><code>(+ 3 5)</code></pre>这并非一个值.</td></tr></table><table class="dialogue"><tr><td class="leftd">为了找出一个<code>car</code>表达式的值, 首先找出其参数的值, 这应该是<code>(cons <math><mi>a</mi></math> <math><mi>d</mi></math>)</code>, 而<pre><code>(car
 (cons <math><mi>a</mi></math> <math><mi>d</mi></math>))</code></pre>的值然后就是<math><mi>a</mi></math>的<em>值</em>.<p>如何找出一个<code>cdr</code>表达式的值呢?</p><div class="comment"><b>注记.</b> 这里的<math><mi>a</mi></math>代表<code>car</code>而<math><mi>d</mi></math>代表<code>cdr</code>.</div></td><td class="middled"><sup>111</sup></td><td class="rightd">就和<code>car</code>一样, 我们从对于<code>cdr</code>的参数求值开始, 直至其变为<code>(cons <math><mi>a</mi></math> <math><mi>d</mi></math>)</code>, 然后<pre><code>(cdr
 (cons <math><mi>a</mi></math> <math><mi>d</mi></math>))</code></pre>的值就是<math><mi>d</mi></math>的值.<p>所有的构造子都有参数吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">当然不是, 回忆一下, <a href="#zero-constructor">第1章第86框</a>里的<code>zero</code>是一个构造子.<p>两个表达式为相同的<code>(Pair Atom Nat)</code>是什么意思?</p></td><td class="middled"><sup>112</sup></td><td class="rightd">这必然意味着每个表达式的值都以<code>cons</code>为顶, 并且它们的<code>car</code>是相同的<code>Atom</code>而<code>cdr</code>是相同的<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">非常好.</td><td class="middled"><sup>113</sup></td><td class="rightd">原子是构造子吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">原子<code>'bay</code>是一个构造子, 因而原子<code>'leaf</code>也是一个构造子.</td><td class="middled"><sup>114</sup></td><td class="rightd"><em>所有</em>原子都是构造子吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 每个原子都构造其自身.<p>这是不是意味着每个原子都是值?</p></td><td class="middled"><sup>115</sup></td><td class="rightd">的确, 因为解释为什么<p><code>Atom</code>是一个类型</p>就是在说原子是<code>Atom</code>值.</td></tr></table><table class="dialogue"><tr><td class="leftd">嗯.<p>在表达式<code>zero</code>中, 顶层构造子是什么?</p></td><td class="middled"><sup>116</sup></td><td class="rightd">那必然是<code>zero</code>, 因为<code>zero</code>是没有参数的构造子.</td></tr></table><table class="dialogue"><tr><td class="leftd">对于表达式<code>'garlic</code>而言, 什么是顶层的构造子?</td><td class="middled"><sup>117</sup></td><td class="rightd">原子<code>'garlic</code>是仅有的构造子, 所以它必然就是顶层的构造子.<p>那么, <code>Nat</code>是一个构造子吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">不是, <code>Nat</code>并非一个构造子. <code>zero</code>和<code>add1</code>是创造<em>数据</em>的构造子, 而<code>Nat</code><em>描述</em>了特定的数据, 其要么就是<code>zero</code>, 要么以<code>add1</code>为顶, 且以另一个<code>Nat</code>为其参数.<p><code>Pair</code>是一个构造子吗?</p></td><td class="middled"><sup>118</sup></td><td class="rightd">不是, 因为<code>Pair</code>表达式是在描述以<code>cons</code>为顶的表达式. 构造子创建<em>数据</em>, 而不是类型.<p>那么, <code>Pair</code>应该叫做什么呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Pair</code>是一个<em>类型构造子(type constructor)</em>, 因其构造了一个类型. 类似地, <code>Nat</code>和<code>Atom</code>也是类型构造子.<pre><code>(cons zero 'onion)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>119</sup></td><td class="rightd">不是.<p>难道它不应该是一个<pre><code>(Pair Nat Atom)</code></pre>吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此! 但是<pre><code>(cons 'zero 'onion)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>请问<pre><code>(cons 'basil
 (cons 'thyme 'oregano))</code></pre>的类型是什么?<div class="comment"><b>注记.</b> 谢谢Julia Child (1912-2004).</div></td><td class="middled"><sup>120</sup></td><td class="rightd">基于我们的所见所闻, 它必然是一个<pre><code>(Pair Atom
 (Pair Atom Atom))</code></pre><div class="tcomment"><b>译注.</b> basil, thyme, oregano分别是罗勒, 百里香, 牛至, 这是三种典型的香料. 另外, Julia Child是一位厨师和电视名人.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">诚然如此.</td><td class="middled"><sup>121</sup></td><td class="rightd">好吧, 暂时就那么多了, 我的脑袋要炸了!</td></tr></table><table class="dialogue"><tr><td class="leftd">或许你应该再一次阅读这一章. 判断, 表达式, 类型是本书最重要的概念.</td><td class="middled"><sup>122</sup></td><td class="rightd">在完全读完这一章之后, 或许应该来点新鲜蔬菜.</td></tr></table><h2>第2章 从心所欲, 道法自然</h2><table class="dialogue"><tr><td class="leftd">ratatouille如何?</td><td class="middled"><sup>1</sup></td><td class="rightd"><em>很好(très bien)</em>, 谢谢提问.</td></tr></table><table class="dialogue"><tr><td class="leftd">第<a href="#ch1">1</a>章里有构造子和类型构造子, 分别构造值和类型.<p>然而, <code>car</code>既不是构造子也不是类型构造子.</p></td><td class="middled"><sup>2</sup></td><td class="rightd">那么, <code>car</code>是什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>car</code>是一个<em>消去子(eliminator)</em>. 消去子将构造子构造的值拆开来.<p>另一个消去子是什么呢?</p></td><td class="middled"><sup>3</sup></td><td class="rightd">如果<code>car</code>是一个消去子, 那么显然<code>cdr</code>也是一个消去子.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">构造子和消去子</div><p>构造子构造值, 而消去子将构造子构造的值拆开来.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">另一种看待(消去子和构造子的)不同的方式在于值包含信息, 而消去子允许我们去利用这样的信息.</td><td class="middled"><sup>4</sup></td><td class="rightd">存在兼作构造子和消去子的东西吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不, 并不存在.<p>可以定义一个<em>函数(function)</em>, 其表达力相当于<code>car</code>和<code>cdr</code>的联合.</p></td><td class="middled"><sup>5</sup></td><td class="rightd">怎么做呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这需要请出我们的老朋友<code>λ</code>.</td><td class="middled"><sup>6</sup></td><td class="rightd">这是什么? 我有点陌生.</td></tr></table><table class="dialogue"><tr><td class="leftd">Oops! 它也被称为<code>lambda</code>.<div class="comment"><b>注记.</b> <code>λ</code>可以选择写成<code>lambda</code>.</div></td><td class="middled"><sup>7</sup></td><td class="rightd">好吧, <code>λ</code>可以构造函数.<p>这是不是意味着<code>λ</code>是一个构造子呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 的确如此, 因为每个长得像<code>(λ (<math><msub><mi>x</mi><mn>0</mn></msub></math> <math><mi>x</mi></math> <math><mo>&hellip;</mo></math>) <math><mi mathvariant="italic">body</mi></math>)</code>的表达式都是一个值.<p>这种值的消去子是什么呢?</p><div class="comment"><b>注记.</b> 记号<math><mi>x</mi><mtext>&nbsp;</mtext><mo>&hellip;</mo></math>的意思是零个或更多的<math><mi>x</mi></math>, 因此<math><msub><mi>x</mi><mn>0</mn></msub><mtext>&nbsp;</mtext><mi>x</mi><mtext>&nbsp;</mtext><mo>&hellip;</mo></math>的意思是一个或更多的<math><mi>x</mi></math>.</div></td><td class="middled"><sup>8</sup></td><td class="rightd">我们唯一能对函数做的事情就是将其应用于参数上.<p>这样的话函数怎么拥有消去子呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">应用函数于参数<em>是</em>函数的消去子.</td><td class="middled"><sup>9</sup></td><td class="rightd">好吧.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">消去函数</div><p>应用函数于参数<em>是</em>函数的消去子.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(λ (flavor)
  (cons flavor 'lentils))</code></pre>的值是什么?<div class="tcomment"><b>译注.</b> lentils指的是小扁豆.</div></td><td class="middled"><sup>10</sup></td><td class="rightd">它自<code>λ</code>起, 因而它已经是一个值了.</td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<pre><code>((λ (flavor)
   (cons flavor 'lentils))
 'garlic)</code></pre>的值是什么呢?</td><td class="middled"><sup>11</sup></td><td class="rightd">那必然是<code>(cons 'garlic 'lentils)</code>, 如果<code>λ</code>和<code>lambda</code>的行为一致且<code>cons</code>是一个构造子的话.<p>但是这难道不意味着即便<code>cons</code>表达式已经是一个值了, <code>cons</code>的第一个参数仍然会被求值吗?</p></td></tr></table><table class="dialogue" id="lam-app"><tr><td class="leftd">不, 并非如此, 但是这是个非常好的问题. 替换这个<code>λ</code>表达式的<code>flavor</code>行为之发生是因为该<code>λ</code>表达式被应用于了一个参数, 而不是因为<code>cons</code>.<div class="comment"><b>注记.</b> 一致地替换一个变量以一个表达式有时被称为<em>替换(substitution)</em>.</div>这个<code>λ</code>表达式的体的每个<code>flavor</code>都会被替换为<code>'garlic</code>, 不论环绕<code>flavor</code>的表达式是什么.</td><td class="middled"><sup>12</sup></td><td class="rightd">因此, 也就是说<pre><code>((λ (root)
   (cons root
         (cons (+ 1 2) root)))
 'potato)</code></pre>的值应该是<pre><code>(cons 'potato
      (cons (+ 1 2) 'potato))</code></pre>对吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么前一个框里的<pre><code>(+ 1 2)</code></pre>不需要计算呢?</td><td class="middled"><sup>13</sup></td><td class="rightd">整个表达式以<code>cons</code>为顶, 故其已是值.</td></tr></table><table class="dialogue"><tr><td class="leftd"><a href="#lam-app">第2章第12框</a>里有点夸大其词. 如果以下<code>λ</code>表达式的体中的<code><u>root</u></code>出现在另一个同名的<code>λ</code>之下的话, 那么它就不会被替换了.<pre><code>((λ (root)
   (cons <u>root</u>
         (λ (root) root)))
 'carrot)</code></pre>的值是什么?<div class="tcomment"><b>译注.</b> 这里的例子有两个同名但不同的变量, 以示对比.</div></td><td class="middled"><sup>14</sup></td><td class="rightd">那必然是<pre><code>(cons 'carrot
      (λ (root) root))</code></pre>因为内层的<code>root</code>出现在一个同名的<code>λ</code>表达式之下.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>λ</code>的确和<code>lambda</code>行为一致, 因而这的确是正确的答案.<p>成为一个<pre><code>(→ Atom (Pair Atom Atom))</code></pre>就是要成为一个<code>λ</code>表达式, 当其应用于一个<code>Atom</code>作为参数时, 则求值至一个<pre><code>(Pair Atom Atom)</code></pre></p><div class="comment"><b>注记.</b> <code>(→ Atom (Pair Atom Atom))</code>读作<q>箭头 原子 <em>暂停</em> 序对 原子 原子</q>, 并且<code>→</code>可以写成是两个字符的版本: <code>-></code>.</div></td><td class="middled"><sup>15</sup></td><td class="rightd">那以这样的<code>λ</code>表达式为值的表达式呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 那些表达式也是<pre><code>(→ Atom (Pair Atom Atom))</code></pre>因为当给出一个<code>Atom</code>作为其参数时, 它们也会变成<pre><code>(Pair Atom Atom)</code></pre></td><td class="middled"><sup>16</sup></td><td class="rightd">它们也是<pre><code>(→ (car (cons Atom 'pepper))
   (Pair (cdr (cons 'salt Atom))
         Atom))</code></pre>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此, 因为<pre><code>(car (cons Atom 'pepper))</code></pre>是<code>Atom</code>而<pre><code>(cdr (cons 'salt Atom))</code></pre>也是<code>Atom</code>.</td><td class="middled"><sup>17</sup></td><td class="rightd">提问何谓两个表达式为相同的<code>Nat</code>, <code>Atom</code>, <code>(Pair Nat Atom)</code>都是有意义的.<p>提问何谓两个表达式为相同的<pre><code>(→ Nat Atom)</code></pre>或者相同的<pre><code>(→ (Pair Atom Nat) Nat)</code></pre>也是有意义的吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 的确如此. 两个表达式为相同的<pre><code>(→ Nat Atom)</code></pre>当它们的值是相同的<pre><code>(→ Nat Atom)</code></pre></td><td class="middled"><sup>18</sup></td><td class="rightd">它们的值是<code>λ</code>表达式. 两个<code>λ</code>为相同的<pre><code>(→ Nat Atom)</code></pre>是什么意思呢?</td></tr></table><table class="dialogue" id="twin"><tr><td class="leftd">两个接受 (expect) 相同数目的参数的<code>λ</code>是相同的, 如果它们的体是相同的. 例如, 两个<code>λ</code>表达式是相同的<pre><code>(→ Nat (Pair Nat Nat))</code></pre>如果它们的体是相同的<pre><code>(Pair Nat Nat)</code></pre></td><td class="middled"><sup>19</sup></td><td class="rightd">这意味着<pre><code>(λ (x) (cons x x))</code></pre>和<pre><code>(λ (y) (cons y y))</code></pre>不是相同的<pre><code>(→ Nat (Pair Nat Nat))</code></pre>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">这两个表达式有什么不同之处呢?</td><td class="middled"><sup>20</sup></td><td class="rightd">参数的名字是不同的. 尽管如此, 这通常无关紧要. 现在紧不紧要呢?</td></tr></table><table class="dialogue" id="rename"><tr><td class="leftd">两个<code>λ</code>表达式也是相同的, 如果可以通过一致地对于参数换名使得它们的体变得相同.<div class="comment"><b>注记.</b> 一致地对于变量换名常被称为<em><math><mi>&alpha;</mi></math>变换(alpha-conversion)</em>. 感谢Alonzo Church (1903-1995).</div>一致地对于变量换名不会改变任何东西的意义.</td><td class="middled"><sup>21</sup></td><td class="rightd"><pre><code>(λ (a d) (cons a d))</code></pre>和<pre><code>(λ (d a) (cons a d))</code></pre>是相同的<pre><code>(→ Atom Atom (Pair Atom Atom))</code></pre>吗?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">应用之始律</div><p>如果<math><mi>f</mi></math>是一个<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>而<math><mi mathvariant="italic">arg</mi></math>是一个<math><mi>Y</mi></math>, 那么<pre><code>(<math><mi>f</mi></math> <math><mi mathvariant="italic">arg</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>λ</code>始第一诫</div><p>两个接受 (expect) 相同数目的参数的<code>λ</code>是相同的, 如果在一致地对于它们的变量进行换名之后, 它们的体是相同的.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>λ</code>始第二诫</div><p>如果<math><mi>f</mi></math>是一个<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>那么<math><mi>f</mi></math>和<pre><code>(λ (<math><mi>y</mi></math>) (<math><mi>f</mi></math> <math><mi>y</mi></math>))</code></pre>是相同的<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>只要<math><mi>y</mi></math>不出现在<math><mi>f</mi></math>中.</p><div class="tcomment"><b>译注.</b> 这里的<q>出现</q>应该指的是<q>自由出现</q>.</div></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">不, 并非如此, 因为对于第二个<code>λ</code>表达式中的变量进行一致换名以匹配第一个<code>λ</code>表达式的参数将会产生<pre><code>(λ (a d) (cons d a))</code></pre>而<code>(cons d a)</code>和<code>(cons a d)</code>并非相同的<code>(Pair Atom Atom)</code>.</td><td class="middled"><sup>22</sup></td><td class="rightd"><pre><code>(λ (y) (car (cons y y)))</code></pre>呢? 它和<pre><code>(λ (x) x)</code></pre>是相同的<pre><code>(→ Nat Nat)</code></pre>吗?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">对于变量换名之律</div><p>一致地对于变量换名不会改变任何东西的意义.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">首先, 一致地将<math><mi>y</mi></math>换名为<math><mi>x</mi></math>. 现在, 问题就变为<pre><code>(car (cons x x))</code></pre>和<code>x</code>是否是相同的<code>Nat</code>.</td><td class="middled"><sup>23</sup></td><td class="rightd">恰有两种方式可以使得两个表达式成为相同的<code>Nat</code>. 一种是它们的值都是<code>zero</code>. 另一种是它们的值都以<code>add1</code>为顶, 而这两个<code>add1</code>的参数是相同的<code>Nat</code>.<p>这些表达式并非<code>Nat</code>值, 因为它们既不以<code>add1</code>为顶, 也不是<code>zero</code>.</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>x</code>的值尚不可知, 因为这个<code>λ</code>表达式还没有被应用于一个参数. 但是, 当这个<code>λ</code>表达式已被应用于一个参数时, <code>x</code>的值<em>仍然是</em>一个<code>Nat</code>, 因为...</td><td class="middled"><sup>24</sup></td><td class="rightd">...因为这个<code>λ</code>表达式是一个<pre><code>(→ Nat Nat)</code></pre>故参数<code>x</code>不可能是任何其他什么东西.</td></tr></table><table class="dialogue"><tr><td class="leftd">并非值且因为变量的缘故<em>还</em>不能被求值的表达式被称为<em>中立(neutral)</em>的.</td><td class="middled"><sup>25</sup></td><td class="rightd">这意味着<pre><code>(cons y 'rutabaga)</code></pre>是中立的咯?<div class="tcomment"><b>译注.</b> rutabaga是芜菁甘蓝的意思.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">不, 它并非中立, 因为<pre><code>(cons y 'rutabaga)</code></pre>是一个值.<p>如果<code>x</code>是一个<code>(Pair Nat Atom)</code>, 那么<pre><code>(cdr x)</code></pre>是一个值吗?</p></td><td class="middled"><sup>26</sup></td><td class="rightd">不是, 因为<code>cdr</code>是一个消去子, 而消去子把值拆散.<p>在不知道<code>x</code>的值的情况下, 没有办法找出<code>(cdr x)</code>的值, 故<code>(cdr x)</code>是中立的.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">中立表达式使得我们有必要扩展对于何谓相同的看法. 每个变量与其自身都是相同的, 不管其类型如何. 这是因为变量只能被<em>一致</em>地替换, 所以说一个变量的两次出现不可能被代之以不同的值.</td><td class="middled"><sup>27</sup></td><td class="rightd">因此, 如果我们假定<code>y</code>是一个<code>Nat</code>, 那么<pre><code>(car (cons y 'rutabaga))</code></pre>和<code>y</code>是相同的<code>Nat</code>, 这是因为该<code>car</code>表达式的规范形式是<code>y</code>, 而<code>y</code>和<code>y</code>是相同的<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此, 并且类似地, 我们有<pre><code>(λ (x) (car (cons x x)))</code></pre>和<pre><code>(λ (x) x)</code></pre>是相同的<pre><code>(→ Nat Nat)</code></pre></td><td class="middled"><sup>28</sup></td><td class="rightd">是的, 因为中立表达式<code>x</code>和<code>x</code>是相同的<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(λ (x) (car x))</code></pre>和<pre><code>(λ (y) (car y))</code></pre>是相同的<pre><code>(→ (Pair Nat Nat) Nat)</code></pre>吗?</td><td class="middled"><sup>29</sup></td><td class="rightd">我们应该会这样认为, 但是理由是什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">第一步应该是一致地将<code>y</code>换名为<code>x</code>.<p><pre><code>(λ (x) (car x))</code></pre>和<pre><code>(λ (x) (car x))</code></pre>是相同的<pre><code>(→ (Pair Nat Nat) Nat)</code></pre>吗?</p></td><td class="middled"><sup>30</sup></td><td class="rightd">是的, 如果假定<pre><code>(car x)</code></pre>和<pre><code>(car x)</code></pre>是相同的<code>Nat</code>.<p>但是<code>(car x)</code>并不是一个变量, 在知道<code>x</code>的值之前我们都不可能找出<code>(car x)</code>的值.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">如果两个表达式以等同的消去子为顶, 并且两个消去子的参数是相同的, 那么这两个表达式也是相同的. 字面上等同的中立表达式是相同的, <em>不管它们的类型如何.</em></td><td class="middled"><sup>31</sup></td><td class="rightd">因而<pre><code>(car x)</code></pre>和<pre><code>(car x)</code></pre>是相同的<code>Nat</code>, 若假定<code>x</code>是一个<code>(Pair Nat Nat)</code>.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">中立表达式之诫</div><p>字面上等同的中立表达式是相同的, <em>不管它们的类型如何.</em></p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(λ (a d) (cons a d))</code></pre>是一个<pre><code>(→ Atom Atom (Pair Atom Atom))</code></pre>吗?</td><td class="middled"><sup>32</sup></td><td class="rightd"><code>→</code>后面跟着更多的表达式意味着什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>→</code>后面跟着的表达式, 除了最后一个, 都是参数的类型. 最后一个则是值的类型.<div class="comment"><b>注记.</b> 最后一个类型读的时候前面会有<em>停顿</em>.</div></td><td class="middled"><sup>33</sup></td><td class="rightd">好吧, 那么<pre><code>(λ (a d) (cons a d))</code></pre>的确是一个<pre><code>(→ Atom Atom (Pair Atom Atom))</code></pre>这些表达式不可避免地正在逐渐变长.</td></tr></table><table class="dialogue"><tr><td class="leftd">一种缩短它们的方式是小心地使用<code>define</code>, 如<a href="#definition">第1章第77框</a>那样, 其总是允许我们用简短的名字来代替冗长的表达式.</td><td class="middled"><sup>34</sup></td><td class="rightd">好想法.</td></tr></table><table class="dialogue"><tr><td class="leftd">设构造子<code>cons</code>被应用于<code>'celery</code>和<code>'carrot</code>, 我们可以称这个值为<code>vegetables</code>.<pre><code>(claim vegetables
  (Pair Atom Atom))
(define vegetables
  (cons 'celery 'carrot))</code></pre>从现在开始, 每当名字<code>vegetables</code>被使用, 它就和<pre><code>(cons 'celery 'carrot)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>因为这就是<code>vegetables</code>如何被<code>define</code>的.<div class="tcomment"><b>译注.</b> celery指的是西芹.</div></td><td class="middled"><sup>35</sup></td><td class="rightd">为什么<code>claim</code>后面有写着<pre><code>(Pair Atom Atom)</code></pre>呢?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>define</code>之律和诫</div><p>遵照<p><code>(claim <math><mi mathvariant="italic">name</mi></math> <math><mi>X</mi></math>)</code>和<code>(define <math><mi mathvariant="italic">name</mi></math> <math><mi mathvariant="italic">expr</mi></math>)</code></p>如果<p><math><mi mathvariant="italic">expr</mi></math>是一个<math><mi>X</mi></math></p>那么<p><math><mi mathvariant="italic">name</mi></math>是一个<math><mi>X</mi></math></p>并且<p><math><mi mathvariant="italic">name</mi></math>和<math><mi mathvariant="italic">expr</mi></math>是相同的<math><mi>X</mi></math></p></p></blockquote></td></tr></table><table class="dialogue" id="nested-Pair"><tr><td class="leftd"><code>(Pair Atom Atom)</code>描述了我们可以怎样使用<code>vegetables</code>. 例如, 我们知道<code>(car vegetables)</code>是一个<code>Atom</code>, 而<code>(cons 'onion vegetables)</code>是一个<pre><code>(Pair Atom (Pair Atom Atom))</code></pre><div class="comment"><b>注记.</b> 这对于小扁豆汤 (lentil soup) 来说也是一个好的开始.</div></td><td class="middled"><sup>36</sup></td><td class="rightd">啊, 懂了.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>vegetables</code></pre>和<pre><code>(cons (car vegetables)
      (cdr vegetables))</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>37</sup></td><td class="rightd">的确如此, 因为每个表达式的值都是一个序对, 并且其<code>car</code>是<code>'celery</code>而<code>cdr</code>是<code>'carrot</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 每当<math><mi>p</mi></math>是一个<code>(Pair Atom Atom)</code>时, 那么<math><mi>p</mi></math>和<pre><code>(cons (car <math><mi>p</mi></math>) (cdr <math><mi>p</mi></math>))</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>找出<code>(car <math><mi>p</mi></math>)</code>和<code>(cdr <math><mi>p</mi></math>)</code>的值是没有必要的.</td><td class="middled"><sup>38</sup></td><td class="rightd">这看起来很合理.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>cons</code>之第二诫</div><p>如果<math><mi>p</mi></math>是一个<code>(Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)</code>, 那么它和<code>(cons (car <math><mi>p</mi></math>) (cdr <math><mi>p</mi></math>))</code>是相同的<code>(Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)</code>.</p></blockquote></td></tr></table><table class="dialogue" id="wrong-five"><tr><td class="leftd">以下定义可以允许吗?<pre class="dashed"><code>(claim five Nat)
(define five (+ 7 2))</code></pre></td><td class="middled"><sup>39</sup></td><td class="rightd">什么鬼?</td></tr></table><table class="dialogue"><tr><td class="leftd">尽管可能是个愚蠢的想法, 但它是可以被允许的.<pre><code>(+ five 5)</code></pre>的规范形式是什么?</td><td class="middled"><sup>40</sup></td><td class="rightd">那必然是<code>10</code>, 因为五 (five) 加<math><mn>5</mn></math>等于十.</td></tr></table><table class="dialogue"><tr><td class="leftd">再想想. 请记得<code>five</code>的奇怪定义...</td><td class="middled"><sup>41</sup></td><td class="rightd">...哦, 好吧, 那应该是<code>14</code>, 因为<code>five</code>被定义成了<code>9</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.</td><td class="middled"><sup>42</sup></td><td class="rightd"><em>这个</em>定义可以允许吗? 似乎它看上去不那么蠢.<pre class="dashed"><code>(claim zero Nat)
(define zero 0)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">虽然和将<code>five</code>定义为<code>9</code>相比没那么愚蠢, 但是这个定义也是不被允许的.<p>已经被使用了的名字, 不论是用于构造子, 消去子, 还是之前的定义, 都不适合再与<code>claim</code>或者<code>define</code>一起使用了.</p></td><td class="middled"><sup>43</sup></td><td class="rightd">好.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">定义中的名字</div><p>在Pie语言中, 只有没有用过的名字, 才能和<code>claim</code>或者<code>define</code>一起使用, 不论是用作构造子, 消去子, 还是之前的定义.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Nat</code>有一个消去子可以区分值为<code>zero</code>的<code>Nat</code>和值以<code>add1</code>为顶的<code>Nat</code>. 这个消去子被称为<code>which-Nat</code>.</td><td class="middled"><sup>44</sup></td><td class="rightd"><code>which-Nat</code>到底是如何辨别应该是哪一种<code>Nat</code>的呢?</td></tr></table><table class="dialogue" id="which-Nat"><tr><td class="leftd">一个<code>which-Nat</code>表达式具有三个参数: <math><mi mathvariant="italic">target</mi></math>, <math><mi mathvariant="italic">base</mi></math>, <math><mi mathvariant="italic">step</mi></math>:<pre><code>(which-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre><code>which-Nat</code>判断<math><mi mathvariant="italic">target</mi></math>是否是<code>zero</code>, 如果是, 那么整个<code>which-Nat</code>表达式的值即<math><mi mathvariant="italic">base</mi></math>的值. 否则的话, 如果<math><mi mathvariant="italic">target</mi></math>是<code>(add1 <math><mi>n</mi></math>)</code>, 那么整个<code>which-Nat</code>表达式的值即<code>(<math><mi mathvariant="italic">step</mi></math> <math><mi>n</mi></math>)</code>的值.</td><td class="middled"><sup>45</sup></td><td class="rightd">因此, <code>which-Nat</code>既要判断一个数字是否是<code>zero</code>, 又要在数字并非<code>zero</code>时去除其顶的<code>add1</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<pre><code>(which-Nat zero
  'naught
  (λ (<span style="color: grey;">n</span>)
    'more))</code></pre>的规范形式是什么呢?</td><td class="middled"><sup>46</sup></td><td class="rightd">必然是<code>'naught</code>, 因为其target <code>zero</code>是<code>zero</code>, 故整个<code>which-Nat</code>表达式的值是<math><mi mathvariant="italic">base</mi></math>, 即<code>'naught</code>.<p>为什么<code><span style="color: grey;">n</span></code>是黯淡的?</p></td></tr></table><table class="dialogue" id="dim"><tr><td class="leftd">黯淡是用来指出<code><span style="color: grey;">n</span></code>在那个<code>λ</code>表达式的体里没有被使用. 没有被使用的名字都将以黯淡的形式出现.</td><td class="middled"><sup>47</sup></td><td class="rightd">为什么没有被使用呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>which-Nat</code>提供了使用更小的<code>Nat</code>的可能性, 但是它并不要求一定使用. 当然, 为了提供这种可能性, <code>which-Nat</code>的最后一个参数必须要接受一个<code>Nat</code>.</td><td class="middled"><sup>48</sup></td><td class="rightd">好.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">黯淡的名字</div><p>没有被使用的名字是黯淡的, 但是它们的确有必要呆在那里.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(which-Nat 4
  'naught
  (λ (<span style="color: grey;">n</span>)
    'more))</code></pre>的值是什么?</td><td class="middled"><sup>49</sup></td><td class="rightd">必然是<code>'more</code>, 因为<code>4</code>是另一种书写<code>(add1 3)</code>的方式, 而其以<code>add1</code>为顶.<pre><code>((λ (<span style="color: grey;">n</span>) 'more) 3)</code></pre>的规范形式为<pre><code>'more</code></pre></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>which-Nat</code>之律</div><p>如果<math><mi mathvariant="italic">target</mi></math>是一个<code>Nat</code>, <math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, 并且<math><mi mathvariant="italic">step</mi></math>是一个<pre><code>(→ Nat <math><mi>X</mi></math>)</code></pre>那么<pre><code>(which-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>which-Nat</code>之第一诫</div><p>如果<pre><code>(which-Nat zero
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么其和<math><mi mathvariant="italic">base</mi></math>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>which-Nat</code>之第二诫</div><p>如果<pre><code>(which-Nat (add1 <math><mi>n</mi></math>)
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么其和<code>(<math><mi mathvariant="italic">step</mi></math> <math><mi>n</mi></math>)</code>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(which-Nat 5
  0
  (λ (n)
    (+ 6 n)))</code></pre>的规范形式是什么?</td><td class="middled"><sup>50</sup></td><td class="rightd">难道说是<code>11</code>, 因为<pre><code>((λ (n) (+ 6 n)) 5)</code></pre>是<code>11</code>?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个的规范形式应该是<code>10</code>, 因为一个<code>which-Nat</code>表达式的值是将藏在其target底下的<code>Nat</code>作为参数传给其step得到的.<div class="tcomment"><b>译注.</b> 也就是说, 要扒开一层<code>add1</code>.</div></td><td class="middled"><sup>51</sup></td><td class="rightd">啊, 所以说规范形式为<code>10</code>是因为<pre><code>((λ (n) (+ 6 n)) 4)</code></pre>是<code>10</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">请定义一个叫做<code>gauss</code>的函数, 使得<code>(gauss <math><mi>n</mi></math>)</code>是从<code>zero</code>到<math><mi>n</mi></math>的所有<code>Nat</code>之和.<p><code>gauss</code>的类型应该是什么?</p><div class="comment"><b>注记.</b> 根据民间传说, Carl Friedrich Gauss (1777-1855) 在他上小学被要求加起一个很长的数列时发现了<math><mrow><mrow><mn>0</mn><mo>+</mo><mo>&ctdot;</mo><mo>+</mo><mi>n</mi></mrow><mo>=</mo><mfrac><mrow><mi>n</mi><mo>&it;</mo><mrow><mo stretchy="false">(</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow><mo stretchy="false">)</mo></mrow></mrow><mn>2</mn></mfrac></mrow></math>.</div></td><td class="middled"><sup>52</sup></td><td class="rightd">将多个<code>Nat</code>加起来当然应该是一个<code>Nat</code>.<pre><code>(claim gauss
  (→ Nat Nat))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">是的. 现在请定义它.</td><td class="middled"><sup>53</sup></td><td class="rightd">怎么做呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">第一步是挑选一个样例参数. 好的选择大概应该在<code>5</code>至<code>10</code>之间, 这样的话既足够大而有趣, 也足够小而可控.</td><td class="middled"><sup>54</sup></td><td class="rightd"><code>5</code>怎么样, 然后呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">听上去不错.<pre><code>(gauss 5)</code></pre>的规范形式应该是什么?</td><td class="middled"><sup>55</sup></td><td class="rightd">应该是<math><mrow><mn>0</mn><mo>+</mo><mn>1</mn><mo>+</mo><mn>2</mn><mo>+</mo><mn>3</mn><mo>+</mo><mn>4</mn><mo>+</mo><mn>5</mn></mrow></math>, 即<math><mn>15</mn></math>.<div class="tcomment"><b>译注.</b> 当然, 更严格地说, 是<code>15</code>.</div></td></tr></table><table class="dialogue" id="almost-answer"><tr><td class="leftd">接下来的一步应该是收缩参数.<p><code>(gauss 4)</code>和<code>(gauss 5)</code>差不多, 前者是<code>10</code>, 后者是<code>15</code>.</p><p>白框框住的是未知的代码, 而白纸黑字的部分则是其中的已知部分. 在这被框住的内容之中, 我们该如何从<pre><code>(gauss 4)</code></pre>得到<pre><code>(gauss 5)</code></pre>呢?</p><pre><code>    <span style="border: 2px solid white; display: inline-block;">    <span style="background-color: white; color: black;">(gauss 4)</span>    </span></code></pre></td><td class="middled"><sup>56</sup></td><td class="rightd">我们必须给<code>(gauss 4)</code>加上<code>5</code>, 而和为<code>15</code>.<pre><code>    <span style="border: 2px solid white; display: inline-block;">(+ 5 <span style="background-color: white; color: black;">(gauss 4)</span>)</span></code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">接下来, 我们要使得这种手段对于任意的以<code>add1</code>为顶的<code>Nat</code>成立.<p>如果<math><mi>n</mi></math>是一个<code>Nat</code>, 那么该如何从<pre><code>(gauss <math><mi>n</mi></math>)</code></pre>得到<pre><code>(gauss (add1 <math><mi>n</mi></math>))</code></pre>呢?</p><pre><code>    <span style="border: 2px solid white; display: inline-block;">    <span style="background-color: white; color: black;">(gauss <math><mi>n</mi></math>)</span>    </span></code></pre><p>请记得<code>5</code>是书写<code>(add1 4)</code>的另一种方式.</p></td><td class="middled"><sup>57</sup></td><td class="rightd">找出<code>(gauss (add1 <math><mi>n</mi></math>))</code>的方法在于将前一个框中的答案里的<code>4</code>替换成<math><mi>n</mi></math>.<pre><code>    <span style="border: 2px solid white; display: inline-block;">(+ (add1 <math><mi>n</mi></math>) <span style="background-color: white; color: black;">(gauss <math><mi>n</mi></math>)</span>)</span></code></pre><code>zero</code>怎么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(gauss zero)</code>是什么?</td><td class="middled"><sup>58</sup></td><td class="rightd">显然是<code>0</code>.</td></tr></table><table class="dialogue" id="pesudo-gauss"><tr><td class="leftd">现在让我们来定义<code>gauss</code>.<p>请记得白色的框和白纸黑字的部分.</p></td><td class="middled"><sup>59</sup></td><td class="rightd">小菜一碟! 名字<code>n-1</code>暗示了其代表着一个脱去了<code>n</code>的一层<code>add1</code>的<code>Nat</code>, 或者说比<code>n</code>小一的<code>Nat</code>.<pre class="dashed"><code>(define gauss
  (λ (n)
    (which-Nat n
      0
      (λ (n-1)
        <span style="border: 2px solid white; display: inline-block;">(+ (add1 n-1) <span style="background-color: white; color: black;">(gauss n-1)</span>)</span>))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">很好的尝试. 如果递归可以作为一个选项, 那么这就不需要用虚线框住了. 可惜, 递归<em>不是</em>一个选项.</td><td class="middled"><sup>60</sup></td><td class="rightd">为什么不让其成为一个选项呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">因为递归不是一个选项.</td><td class="middled"><sup>61</sup></td><td class="rightd">为什么不让其成为一个选项呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">因为递归不是一个选项.</td><td class="middled"><sup>62</sup></td><td class="rightd">好吧, 请解释为什么递归不是一个选项.</td></tr></table><table class="dialogue"><tr><td class="leftd">递归之所以不是一个选项, 是因为每个表达式都必须具有一个值. 一些递归定义使得我们可以写下没有值的表达式.</td><td class="middled"><sup>63</sup></td><td class="rightd">举个例子呢? 一个递归定义和一个没有值的表达式.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>forever</code>就是一个这样的例子.<pre class="dashed"><code>(claim forever (→ Nat Atom))
(define forever
  (λ (and-ever)
    (forever and-ever)))</code></pre><code>(forever 71)</code>的值是什么?</td><td class="middled"><sup>64</sup></td><td class="rightd">好问题.<p>为什么它被虚线框住了?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">递归不是一个选项, 故像<code>forever</code>这样的递归定义将永远被虚线框住.</td><td class="middled"><sup>65</sup></td><td class="rightd">但是, 对于像<code>gauss</code>这种需要递归的定义该怎么办呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">递归定义存在着一种安全的替代品, 其允许我们写下<code>gauss</code>而不需要包括<code>gauss</code>这个名字, 对于其他诸多类似的定义也是如此.</td><td class="middled"><sup>66</sup></td><td class="rightd">这里是<code>gauss</code>的安全替代版本定义的起点.<pre class="dashed"><code>(define gauss
  (λ (n)
    <span style="border: 2px solid white; display: inline-block;">gauss不是一个选项!</span>))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">就目前的走向来看, 还是正确的. 要义在于<code>gauss</code>不能出现在其自身的定义里.</td><td class="middled"><sup>67</sup></td><td class="rightd">现在<q>递归不是一个选项</q>这句话的含义是清晰的了.<p>难道说这意味着Pie中不可能写下<code>gauss</code>吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">Pie中写下<code>gauss</code><em>是</em>可能的, 但是<code>which-Nat</code>和<code>define</code>还不足以让我们能够应对这个任务. 我们需要不同的消去子, 但是时机还远未成熟.</td><td class="middled"><sup>68</sup></td><td class="rightd">耐心是一种美德.</td></tr></table><table class="dialogue"><tr><td class="leftd">给诸如<code>(Pair Nat Nat)</code>这样的表达式定义更加简短的名字也是可能的.</td><td class="middled"><sup>69</sup></td><td class="rightd">这种情况下的<code>claim</code>是什么样的呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">另一个好问题!<p>诸如<code>Atom</code>, <code>Nat</code>, <code>(Pair Atom Nat)</code>这样的表达式是类型, 而每一个这样的类型都是一个<math><mi mathvariant="script">U</mi></math>.</p><div class="comment"><b>注记.</b> <math><mi mathvariant="script">U</mi></math>读作<q>you</q>, 是<em>universe(宇宙)</em>的缩写, 以其描述了<em>所有</em>的类型 (除了自身).</div></td><td class="middled"><sup>70</sup></td><td class="rightd">类型是值吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">有的类型是值.<p>一个为类型的表达式是一个值, 当其以某个类型构造子为顶时. 到目前为止, 我们见过的类型构造子有<code>Nat</code>, <code>Atom</code>, <code>→</code>, 和<math><mi mathvariant="script">U</mi></math>.</p></td><td class="middled"><sup>71</sup></td><td class="rightd">所有的类型都是值吗?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">类型值</div><p>一个由某个类型描述的表达式是一个值, 当其以某个构造子为顶. 类似地, 一个为类型的表达式是一个(类型)值, 当其以某个类型构造子为顶.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">并非如此.<pre><code>(car (cons Atom 'prune))</code></pre>是一个类型, 但不是一个值, 因为<code>car</code>既不是一个构造子, 也不是一个类型构造子.</td><td class="middled"><sup>72</sup></td><td class="rightd">什么样的表达式由<pre><code>(car (cons Atom 'prune))</code></pre>描述呢?<div class="tcomment"><b>译注.</b> prune, 西梅干.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">因为<pre><code>(car (cons Atom 'prune))</code></pre>和<pre><code>Atom</code></pre>是相同的类型, 所以<pre><code>(car (cons Atom 'prune))</code></pre>所描述的表达式和<code>Atom</code>是同样的.</td><td class="middled"><sup>73</sup></td><td class="rightd">类型构造子和构造子有什么区别?</td></tr></table><table class="dialogue"><tr><td class="leftd">类型构造子构造类型, 而构造子 (或者说<em>数据</em>构造子) 构造由那些类型描述的值.<p>作出一个表达式是一个类型的判断需要知道其构造子. 但是, <math><mi mathvariant="script">U</mi></math>的意义并不由知道所有的类型构造子给出, 因为可以引入新的类型.</p></td><td class="middled"><sup>74</sup></td><td class="rightd"><code>(cons Atom Atom)</code>是一个<math><mi mathvariant="script">U</mi></math>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不是, 但<pre><code>(cons Atom Atom)</code></pre>是一个<pre><code>(Pair <math><mi mathvariant="script">U</mi></math> <math><mi mathvariant="script">U</mi></math>)</code></pre>一个原子, 例如<code>'plum</code>, 是一个<code>Atom</code>. 从另一方面来说, <code>Atom</code>不是一个<code>Atom</code>, 而是一个由<math><mi mathvariant="script">U</mi></math>刻画的类型.</td><td class="middled"><sup>75</sup></td><td class="rightd">让我们来思考<code>(Pair Atom Atom)</code>的事情.<pre><code>(cons Atom Atom)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不是, 这是因为<code>Atom</code>是一个类型, 而不是一个<code>Atom</code>.</td><td class="middled"><sup>76</sup></td><td class="rightd"><math><mi mathvariant="script">U</mi></math>是一个<math><mi mathvariant="script">U</mi></math>吗?</td></tr></table><table class="dialogue" id="paradox"><tr><td class="leftd">不是, 但<math><mi mathvariant="script">U</mi></math>的确是一个类型. 没有表达式可以成为其自身的类型.<div class="comment"><b>注记.</b> <math><mi mathvariant="script">U</mi></math>可以是一个<math><msub><mi mathvariant="script">U</mi><mn>1</mn></msub></math>, 而<math><msub><mi mathvariant="script">U</mi><mn>1</mn></msub></math>可以是一个<math><msub><mi mathvariant="script">U</mi><mn>2</mn></msub></math>, 如此类推. 感谢Bertrand Russell (1872-1970). 感谢Jean-Yves Girard (1947-). 在这本书里, 单一的<math><mi mathvariant="script">U</mi></math>就够用了, 因为我们不需要<math><mi mathvariant="script">U</mi></math>被某个类型刻画.</div></td><td class="middled"><sup>77</sup></td><td class="rightd">每个为<math><mi mathvariant="script">U</mi></math>的表达式是否也都是一个类型呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 如果<math><mi>X</mi></math>是一个<math><mi mathvariant="script">U</mi></math>, 那么<math><mi>X</mi></math>是一个类型.</td><td class="middled"><sup>78</sup></td><td class="rightd">是否每个类型都由<math><mi mathvariant="script">U</mi></math>刻画呢?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">每个<math><mi mathvariant="script">U</mi></math>都是一个类型</div><p>每个由<math><mi mathvariant="script">U</mi></math>刻画的表达式都是一个类型, 但是不是每个类型都由<math><mi mathvariant="script">U</mi></math>刻画.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">每个由<math><mi mathvariant="script">U</mi></math>刻画的表达式都是一个类型, 但是不是每个为类型的表达式都由<math><mi mathvariant="script">U</mi></math>刻画.</td><td class="middled"><sup>79</sup></td><td class="rightd"><pre><code>(cons Atom Nat)</code></pre>是一个<pre><code>(Pair <math><mi mathvariant="script">U</mi></math> <math><mi mathvariant="script">U</mi></math>)</code></pre>吗?</td></tr></table><table class="dialogue" id="Pear-definition"><tr><td class="leftd">的确如此.<p>定义<code>Pear</code>, 其意指<code>Nat</code>的序对的类型.</p><div class="tcomment"><b>译注.</b> pear和pair同音.</div></td><td class="middled"><sup>80</sup></td><td class="rightd">那必然是<pre><code>(claim Pear <math><mi mathvariant="script">U</mi></math>)
(define Pear
  (Pair Nat Nat))</code></pre>从现在开始, <code>Pear</code>的意思是<pre><code>(Pair Nat Nat)</code></pre>这个名字只有四个字符, 而其代表的类型有十四个字符.</td></tr></table><table class="dialogue"><tr><td class="leftd">每当<code>Pear</code>出现时, 是不是它就和<code>(Pair Nat Nat)</code>是相同的类型?</td><td class="middled"><sup>81</sup></td><td class="rightd">的确, 根据<code>define</code>之诫.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(cons 3 5)</code>是一个<code>Pear</code>吗?</td><td class="middled"><sup>82</sup></td><td class="rightd">是的, 因为<pre><code>(cons 3 5)</code></pre>是一个<pre><code>(Pair Nat Nat)</code></pre>而<pre><code>Pear</code></pre>恰被<em>定义</em>为这个类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">这是很好的论证.</td><td class="middled"><sup>83</sup></td><td class="rightd"><code>Pear</code>是一个值吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不是. 由<code>define</code>定义的名字既不是类型构造子也不是构造子, 故并非值.<p><code>Pear</code>有消去子吗?</p></td><td class="middled"><sup>84</sup></td><td class="rightd">你说的消去子是不是指的是将类型<code>Pear</code>的值拆开的那种东西?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<p><code>Pear</code>的消去子必然要使得具有类型<code>Pear</code>的值中的信息能够被使用.</p></td><td class="middled"><sup>85</sup></td><td class="rightd">什么叫做使得信息能够被使用?</td></tr></table><table class="dialogue"><tr><td class="leftd">使得任意<code>Pear</code>中的信息能够被使用的<code>Pear</code>的消去子是这样的一种东西, 其可以应用函数于<code>Pear</code>的两个<code>Nat</code>参数.</td><td class="middled"><sup>86</sup></td><td class="rightd">好吧.</td></tr></table><table class="dialogue"><tr><td class="leftd">什么样的函数可以应用到两个作为参数的<code>Nat</code>上呢?</td><td class="middled"><sup>87</sup></td><td class="rightd">一个例子: <code>+</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">交换<code>Nat</code>的表达式是什么样的呢?</td><td class="middled"><sup>88</sup></td><td class="rightd"><pre><code>(λ (a d)
  (cons d a))</code></pre>如何?</td></tr></table><table class="dialogue"><tr><td class="leftd">非常好. 从一个<code>Pear</code>里提取出第一个<code>Nat</code>的表达式是什么样的呢?</td><td class="middled"><sup>89</sup></td><td class="rightd">那必然是<pre><code>(λ (a d) a)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">非常接近了. 实际上, 应该是<pre><code>(λ (a <span style="color: grey;">d</span>) a)</code></pre></td><td class="middled"><sup>90</sup></td><td class="rightd">你真无聊. 但是, 没有这个黯淡的效果, 表达式本身也应该是正确的吧?</td></tr></table><table class="dialogue"><tr><td class="leftd">是这样的. 为了从一个<code>Pear</code>中得到一个类型为<math><mi>X</mi></math>的值, 我们必然需要有一个类型为<pre><code>(→ Nat Nat <math><mi>X</mi></math>)</code></pre>的表达式. <code>+</code>的类型是什么?<div class="comment"><b>注记.</b> 毕竟<math><mi>X</mi></math>可以是任意的类型.</div></td><td class="middled"><sup>91</sup></td><td class="rightd">其取两个<code>Nat</code>而产生一个<code>Nat</code>, 故类型必然是<pre><code>(→ Nat Nat Nat)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">很好.<p>当<code>a</code>和<code>d</code>都为<code>Nat</code>时, <pre><code>(λ (a d)
  (cons d a))</code></pre>的类型是什么?</p></td><td class="middled"><sup>92</sup></td><td class="rightd">显然是<pre><code>(→ Nat Nat Pear)</code></pre>其和<pre><code>(→ Nat Nat (Pair Nat Nat))</code></pre>相同.<p>一个<code>λ</code>表达式该怎么和一个<code>Pear</code>一起使用呢?</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">定义是没有必要的</div><p>没有定义也可以完成一切事情, 但是定义的确有助于理解.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">试试这个:<pre><code>(claim Pear-maker <math><mi mathvariant="script">U</mi></math>)
(define Pear-maker
  (→ Nat Nat Pear))

(claim elim-Pear
  (→ Pear Pear-maker Pear))
(define elim-Pear
  (λ (pear maker)
    (maker (car pear)
           (cdr pear))))</code></pre>是否可以写下<code>elim-Pear</code>的<code>claim</code>而不使用<code>Pear</code>或<code>Pear-maker</code>呢?</td><td class="middled"><sup>93</sup></td><td class="rightd">可以, 只需要将<code>Pear-maker</code>和<code>Pear</code>替换为相应的定义即可.<pre class="dashed"><code>(claim elim-Pear
  (→ (Pair Nat Nat)
     (→ Nat Nat
        (Pair Nat Nat))
     (Pair Nat Nat)))</code></pre>名字<code>Pear-maker</code>和<code>Pear</code>从不是必要的. 名字<code>elim-Pear</code>是必要的吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">什么时候定义是必要的呢?</td><td class="middled"><sup>94</sup></td><td class="rightd">什么时候都不是必要的!</td></tr></table><table class="dialogue"><tr><td class="leftd">是这样的. <code>elim-Pear</code>和它定义里的那个<code>λ</code>表达式是相同的.<pre><code>(elim-Pear
 (cons 3 17)
 (λ (a d)
   (cons d a)))</code></pre>的值是什么?</td><td class="middled"><sup>95</sup></td><td class="rightd"><pre><code>((λ (pear maker)
   (maker (car pear) (cdr pear)))
 (cons 3 17)
 (λ (a d)
   (cons d a)))</code></pre>怎么样?</td></tr></table><table class="dialogue"><tr><td class="leftd">一个好的开始, 但这还不是值.</td><td class="middled"><sup>96</sup></td><td class="rightd">值是<code>(cons 17 3)</code>, 这是因为<code>elim-Pear</code>和其定义中的那个<code>λ</code>表达式相同, 并且<pre><code>(car (cons 3 17))</code></pre>和<code>3</code>是相同的<code>Nat</code>, 而<pre><code>(cdr (cons 3 17))</code></pre>和<code>17</code>是相同的<code>Nat</code>, 最后<pre><code>((λ (a d)
   (cons d a))
 3 17)</code></pre>和<pre><code>(cons 17 3)</code></pre>是相同的<code>Pear</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">将两个<code>Pear</code>加起来会是什么意思呢?</td><td class="middled"><sup>97</sup></td><td class="rightd">难道说是将每个<code>Pear</code>的第一个<code>Nat</code>和第二个<code>Nat</code>分别加起来吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">很好的猜测.<p>这种<em>pearwise</em>加法的类型是什么?</p><div class="tcomment"><b>译注.</b> 译者认为pearwise并非贴切, 因为是逐<code>Pear</code>的部分相加, 而不是逐<code>Pear</code>相加, 可能partwise是更好的选择.</div></td><td class="middled"><sup>98</sup></td><td class="rightd"><pre><code>(→ Pear Pear Pear)</code></pre>对吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">怎么用<code>elim-Pear</code>定义pearwise加法?</td><td class="middled"><sup>99</sup></td><td class="rightd">好难啊, 是不是两个<code>Pear</code>都要消去, 因为这些<code>Nat</code>都是结果的一部分?</td></tr></table><table class="dialogue"><tr><td class="leftd">当然了.<p>请定义<code>pearwise+</code>, 以使得<pre><code>(pearwise+
 (cons 3 8)
 (cons 7 6))</code></pre>和<pre><code>(cons 10 14)</code></pre>是相同的<code>Pear</code>.</p></td><td class="middled"><sup>100</sup></td><td class="rightd">首先, 将<code>anjou</code>和<code>bosc</code>各自拆成其相应的部分, 然后再将它们的第一部分和第二部分分别加起来.<pre><code>(claim pearwise+
  (→ Pear Pear Pear))
(define pearwise+
  (λ (anjou bosc)
    (elim-Pear
     anjou
     (λ (a<sub>1</sub> d<sub>1</sub>)
       (elim-Pear
        bosc
        (λ (a<sub>2</sub> d<sub>2</sub>)
          (cons
           (+ a<sub>1</sub> a<sub>2</sub>)
           (+ d<sub>1</sub> d<sub>2</sub>))))))))</code></pre><div class="tcomment"><b>译注.</b> anjou和bosc都是梨的品种.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">或许现在应该好好休息一下, 然后回来重读本章.</td><td class="middled"><sup>101</sup></td><td class="rightd">是的, 的确是个好想法.<p>但是, 我们该如何到达第<a href="#ch3">3</a>章呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">通过到达第<a href="#ch3">3</a>章.</td><td class="middled"><sup>102</sup></td><td class="rightd">幸亏递归不是一个选项.</td></tr></table><h2>课间: 一叉子Pie</h2><table class="dialogue"><tr><td class="leftd">是时候玩Pie了呢.</td><td class="middled"><sup>1</sup></td><td class="rightd">玩弄食物是不是有点不礼貌?</td></tr></table><table class="dialogue"><tr><td class="leftd">尽管派 (pie) 的确是一种美味的食物, 但是Pie是一种语言, 玩玩而已无伤大雅.</td><td class="middled"><sup>2</sup></td><td class="rightd">让我们开始吧.</td></tr></table><table class="dialogue"><tr><td class="leftd">使用Pie很像是对话: 其接受声明, 定义和表达式, 并回之以反馈.</td><td class="middled"><sup>3</sup></td><td class="rightd">什么样的反馈呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">对于声明和定义而言, 反馈是判断它们是否具备意义. 对于表达式而言, 反馈是表达式的类型和规范形式.</td><td class="middled"><sup>4</sup></td><td class="rightd">不具备意义会怎么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">Pie会解释它们出了什么问题, 有时添加有用的提示.</td><td class="middled"><sup>5</sup></td><td class="rightd">表达式可能会出什么问题呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">在吃Pie前请吃蔬菜.<p>尝试输入<pre><code>'spinach</code></pre>看看会发生什么.</p><div class="tcomment"><b>译注.</b> spinach, 菠菜.</div></td><td class="middled"><sup>6</sup></td><td class="rightd">Pie回之以<pre><code>(the Atom 'spinach)</code></pre>这里的<code>the</code>是什么意思?</td></tr></table><table class="dialogue"><tr><td class="leftd">其意即<code>'spinach</code>是一个<code>Atom</code>.<p>在Pie里, 一个表达式要么是一个类型, 要么由一个类型描述. Pie可以自己找出诸多表达式的类型, 包括原子.</p></td><td class="middled"><sup>7</sup></td><td class="rightd"><pre><code>(car 'spinach)</code></pre>怎么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个表达式并不由某个类型刻画, 因为<code>'spinach</code>不是一个序对.</td><td class="middled"><sup>8</sup></td><td class="rightd">Pie总能判断描述了表达式的类型吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不能, 有时Pie需要帮助.<p>此时, 使用<code>the</code>表达式来告诉Pie意图的类型.</p><div class="comment"><b>注记.</b> <code>the</code>表达式也被称为<em>类型注解</em>.</div></td><td class="middled"><sup>9</sup></td><td class="rightd">例如?</td></tr></table><table class="dialogue"><tr><td class="leftd">Pie不能确定单独的<code>cons</code>表达式的类型.</td><td class="middled"><sup>10</sup></td><td class="rightd">为什么呢?<pre><code>(cons 'spinach 'cauliflower)</code></pre>是一个<pre><code>(Pair Atom Atom)</code></pre>这难道不是显然的吗?<div class="tcomment"><b>译注.</b> cauliflower, 花椰菜.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这对于我们来说是显然的, 但是之后<code>cons</code>将变得更加壮丽 (magnificent), 提升了的表达力 (power) 使得其类型不再能被自动确定.</td><td class="middled"><sup>11</sup></td><td class="rightd">那么, 怎样让Pie确定<pre><code>(cons 'spinach 'cauliflower)</code></pre>是一个序对呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">试试这个:<pre><code>(the (Pair Atom Atom)
  (cons 'spinach 'cauliflower))</code></pre></td><td class="middled"><sup>12</sup></td><td class="rightd">因此, 一个<code>the</code>表达式将一个表达式与其类型联系起来, 不仅是在Pie的反馈里, 也可以出现在我们写下来的表达式里.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>the</code>之律</div><p>如果<math><mi>X</mi></math>是一个类型而<math><mi>e</mi></math>是一个<math><mi>X</mi></math>, 那么<pre><code>(the <math><mi>X</mi></math> <math><mi>e</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">Pie中存在两种表达式: 一种Pie可以自行判断其类型, 另一种对于Pie而言则需要我们的帮助.</td><td class="middled"><sup>13</sup></td><td class="rightd">还有其他帮助Pie判断类型的方式吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确是有的. 在第<a href="#ch1">1</a>章里, <code>claim</code>在其相应的<code>define</code>之前出现是必要的, 而这告诉了Pie对于定义的意义而言使用何种类型.</td><td class="middled"><sup>14</sup></td><td class="rightd">为什么我们不在每次Pie不能确定一个表达式的类型时就使用<code>claim</code>和<code>define</code>呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">原则上是可以的, 但总是把名字都写出来令人厌倦.</td><td class="middled"><sup>15</sup></td><td class="rightd">还有什么其他方法能够帮助Pie找到类型吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确还有一种方法. 如果某处使用了一个表达式而此处只有一个类型能够成立 (make sense), 那么Pie就会使用这个类型.</td><td class="middled"><sup>16</sup></td><td class="rightd">举个例子呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">当检查<pre><code>(the (Pair Atom
       (Pair Atom Atom))
  (cons 'spinach
    (cons 'kale 'cauliflower)))</code></pre>(是否)由一个类型描述时, Pie使用<pre><code>(Pair Atom Atom)</code></pre>作为<pre><code>(cons 'kale 'cauliflower)</code></pre>的类型.</td><td class="middled"><sup>17</sup></td><td class="rightd">这里, 内层的<code>cons</code>不需要一个<code>the</code>是因为其类型是来源于外层的<code>cons</code>的类型的.<p>以<code>the</code>为顶的表达式都是值吗?</p><div class="tcomment"><b>译注.</b> kale, 羽衣甘蓝.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">并非如此.<pre><code>(the <math><mi>X</mi></math> <math><mi>e</mi></math>)</code></pre>的值是<math><mi>e</mi></math>的值.</td><td class="middled"><sup>18</sup></td><td class="rightd">那么<pre><code>(car
  (the (Pair Atom Nat)
    (cons 'brussels-sprout 4)))</code></pre>的值是什么?<div class="tcomment"><b>译注.</b> brussels sprout, 抱子甘蓝.</div></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>the</code>之诫</div><p>如果<math><mi>X</mi></math>是一个类型而<math><mi>e</mi></math>是一个<math><mi>X</mi></math>, 那么<pre><code>(the <math><mi>X</mi></math> <math><mi>e</mi></math>)</code></pre>和<math><mi>e</mi></math>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">值是很小一点的<code>'brussels-sprout</code>.<p>现在试试这个:<pre><code>U</code></pre></p></td><td class="middled"><sup>19</sup></td><td class="rightd">Pie说:<pre><code>U</code></pre>为什么不是<pre><code>(the U U)</code></pre>呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><math><mi mathvariant="script">U</mi></math>是一个类型, 但是其不<em>具备</em>类型. 这是因为没有表达式可以是其自身的类型, 正如<a href="#paradox">第2章第77框</a>所写的那样.<p>当一个表达式是一个类型但不具备类型时, Pie只回以其规范形式.</p></td><td class="middled"><sup>20</sup></td><td class="rightd">还有其他别的什么类型不具备类型<math><mi mathvariant="script">U</mi></math>的吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">当然有了, 例如<pre><code>(Pair <math><mi mathvariant="script">U</mi></math> <math><mi mathvariant="script">U</mi></math>)</code></pre><pre><code>(Pair Atom <math><mi mathvariant="script">U</mi></math>)</code></pre><pre><code>(→ <math><mi mathvariant="script">U</mi></math> <math><mi mathvariant="script">U</mi></math>)</code></pre>都是类型, 但是它们不以<math><mi mathvariant="script">U</mi></math>作为它们的类型.</td><td class="middled"><sup>21</sup></td><td class="rightd">还有其他什么关于Pie的方面是我们应该知道的呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">暂时就这么多了. 之后还有机会.</td><td class="middled"><sup>22</sup></td><td class="rightd">下一步是什么?</td></tr></table><table class="dialogue"><tr><td class="leftd">尽情玩乐.</td><td class="middled"><sup>23</sup></td><td class="rightd">好主意. (Sounds like a plan!)</td></tr></table><h2 id="ch3">第3章 消去所有的自然数!</h2><table class="dialogue"><tr><td class="leftd">以下是来源于<a href="#pesudo-gauss">第2章第59框</a>的<code>gauss</code>的虚框定义.<pre class="dashed"><code>(define gauss
  (λ (n)
    (which-Nat n
      0
      (λ (n-1)
        (+ (add1 n-1) (gauss n-1))))))</code></pre>现在是时候以不使用显式递归的方式来正确地定义<code>gauss</code>了.</td><td class="middled"><sup>1</sup></td><td class="rightd">难道说我们将要像下面这样来定义<code>gauss</code>吗?<pre class="dashed"><code>(define gauss
  (λ (n)
    <span style="border: 2px solid white; display: inline-block;">...这里没有gauss?</span>))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么递归定义不是一个选项?</td><td class="middled"><sup>2</sup></td><td class="rightd">因为<b>递归定义不是一个选项</b>.</td></tr></table><table class="dialogue"><tr><td class="leftd">确实.<p>但是, 某些递归定义总是能产生一个值.</p></td><td class="middled"><sup>3</sup></td><td class="rightd">比如说<code>gauss</code>, 不是吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p><code>(gauss 0)</code>的规范形式是什么?</p></td><td class="middled"><sup>4</sup></td><td class="rightd">是<code>zero</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(gauss 1)</code>的值是什么?</td><td class="middled"><sup>5</sup></td><td class="rightd">是<code>1</code>, 因为<ol><li>| <code>(gauss (add1 zero))</code>相同于</li><li>| <code>(+ 1 (gauss zero))</code>相同于</li><li>| <code>(add1 (gauss zero))</code></li></ol><div class="comment"><b>注记.</b> 当表达式垂直对齐而左边又有竖杠时, 我们将假定除了最后一行之外的每一行后面都跟着<q>相同于 (is the same as)</q>. 这种图表被称为<q>相同于 (same as)</q>图表.</div><div class="tcomment"><b>译注.</b> 原书的竖杠是连贯的, 虽然也可以实现这样的效果, 但是译者太懒了.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这就是值吗?</td><td class="middled"><sup>6</sup></td><td class="rightd">不是还有更多要做的吗?<ol start="3"><li>| <code>(add1 (gauss zero))</code></li><li>| <code>(add1 zero)</code></li></ol></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">相同性</div><p>如果一个<q>相同于</q>图表可以用来表明两个表达式是相同的, 那么这个事实可以在任何地方使用而不需要进一步的澄清. <q>相同于</q>图表只是为了辅助构建理解的.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">实际上<pre><code>(add1 (gauss zero))</code></pre><em>已经</em>是一个值了. 为什么?</td><td class="middled"><sup>7</sup></td><td class="rightd">好吧, 那是因为构造子<code>add1</code>就在顶上.</td></tr></table><table class="dialogue"><tr><td class="leftd">诚然如此.<p><code>(gauss 1)</code>的规范形式是什么?</p></td><td class="middled"><sup>8</sup></td><td class="rightd">是<code>(add1 zero)</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>(gauss 2)</code>具有规范形式?</td><td class="middled"><sup>9</sup></td><td class="rightd">因为<code>(gauss 2)</code>的规范形式只依赖于<code>(gauss 1)</code>的规范形式 (其的确<em>有</em>一个规范形式) 和<code>+</code>的规范形式.<p><code>+</code>有规范形式吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">一旦定义了<code>+</code>, 它的确具有规范形式. 暂时, 假定<code>+</code>具有规范形式.</td><td class="middled"><sup>10</sup></td><td class="rightd">好吧.</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>(gauss 3)</code>具有规范形式?</td><td class="middled"><sup>11</sup></td><td class="rightd">因为<code>(gauss 3)</code>的规范形式只依赖于<code>(gauss 2)</code>的规范形式 (其的确有一个规范形式) 和<code>+</code>的规范形式. 暂时, 我们假定<code>+</code>具有规范形式.</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么对于任意的<code>Nat</code> <math><mi>k</mi></math>, <code>(gauss (add1 <math><mi>k</mi></math>))</code>都有规范形式?</td><td class="middled"><sup>12</sup></td><td class="rightd">因为<code>(gauss (add1 <math><mi>k</mi></math>))</code>的规范形式仅依赖于<code>(gauss <math><mi>k</mi></math>)</code>的规范形式, <math><mi>k</mi></math>的值, 以及<code>+</code>的规范形式.<p><math><mi>k</mi></math>的值要么是<code>zero</code>, 要么以<code>add1</code>为顶. 我们已经知道了<code>(gauss 0)</code>具有规范形式, 并且我们刚刚验证了, 对于任意的<code>Nat</code> <math><mi>k</mi></math>, <code>(gauss (add1 <math><mi>k</mi></math>))</code>都有规范形式.</p><div class="tcomment"><b>译注.</b> 恕译者愚钝, 此处无法理解.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">为<em>每个</em>可能的参数都赋有一个值的函数被称为<em>完全函数(total function)</em>.<p><code>+</code>和<code>gauss</code>都是完全的.</p></td><td class="middled"><sup>13</sup></td><td class="rightd">存在并非完全的函数吗?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">完全函数</div><p>为<em>每个</em>可能的参数都赋有一个值的函数被称为<em>完全函数(total function)</em>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">至少这里没有. 在Pie里, <em>所有的函数都是完全的</em>.<p>消去子是什么?</p><div class="comment"><b>注记.</b> 因为所有函数都是完全的, 所以子表达式的求值顺序并不重要. 如果某些函数并非完全, 那么求值顺序将会变得重要, 因为其将决定函数是否会应用到并非拥有值的参数上.</div></td><td class="middled"><sup>14</sup></td><td class="rightd">消去子拆开由构造子构造的值.</td></tr></table><table class="dialogue"><tr><td class="leftd">将一个<code>Nat</code>拆开是什么意思?</td><td class="middled"><sup>15</sup></td><td class="rightd">难道<code>which-Nat</code>不会拆开一个<code>Nat</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">这意味着<code>which-Nat</code>是<code>Nat</code>的一个消去子. 但是, 以<code>add1</code>为顶的<code>Nat</code>底下还藏着一个更小的<code>Nat</code>, 而<code>which-Nat</code>并不会消去这更小的<code>Nat</code>.</td><td class="middled"><sup>16</sup></td><td class="rightd">存在消去更小<code>Nat</code>的方法吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">一种消去更小<code>Nat</code>的方法是使用<code>iter-Nat</code>.</td><td class="middled"><sup>17</sup></td><td class="rightd">什么是<code>iter-Nat</code>?</td></tr></table><table class="dialogue"><tr><td class="leftd">一个<code>iter-Nat</code>表达式长得像这样:<pre><code>(iter-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>和<code>which-Nat</code>一样, 当<math><mi mathvariant="italic">target</mi></math>是<code>zero</code>时, 整个<code>iter-Nat</code>表达式的值即<math><mi mathvariant="italic">base</mi></math>的值.</td><td class="middled"><sup>18</sup></td><td class="rightd"><code>iter-Nat</code>和<code>which-Nat</code>不一样的地方在哪里?</td></tr></table><table class="dialogue"><tr><td class="leftd">和<code>which-Nat</code>不一样的是, 当<math><mi mathvariant="italic">target</mi></math>是<code>(add1 <math><mi>n</mi></math>)</code>时, 整个<code>iter-Nat</code>表达式的值是<pre><code>(<math><mi mathvariant="italic">step</mi></math>
 (iter-Nat <math><mi>n</mi></math>
   <math><mi mathvariant="italic">base</mi></math>
   <math><mi mathvariant="italic">step</mi></math>))</code></pre>的值.</td><td class="middled"><sup>19</sup></td><td class="rightd">所以说<math><mi mathvariant="italic">target</mi></math>的值中的每一个<code>add1</code>都将被代之以一个<math><mi mathvariant="italic">step</mi></math>, 而<code>zero</code>会被代之以<math><mi mathvariant="italic">base</mi></math>.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>iter-Nat</code>之律</div><p>如果<math><mi mathvariant="italic">target</mi></math>是一个<code>Nat</code>, <math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, 而<math><mi mathvariant="italic">step</mi></math>是一个<pre><code>(→ <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></pre>那么<pre><code>(iter-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>iter-Nat</code>之第一诫</div><p>如果<pre><code>(iter-Nat zero
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么它和<math><mi mathvariant="italic">base</mi></math>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>iter-Nat</code>之第二诫</div><p>如果<pre><code>(iter-Nat (add1 <math><mi>n</mi></math>)
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么它和<pre><code>(<math><mi mathvariant="italic">step</mi></math>
 (iter-Nat <math><mi>n</mi></math>
   <math><mi mathvariant="italic">base</mi></math>
   <math><mi mathvariant="italic">step</mi></math>))</code></pre>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<pre><code>(iter-Nat 5
  3
  (λ (smaller)
    (add1 smaller)))</code></pre>的规范形式是什么?</td><td class="middled"><sup>20</sup></td><td class="rightd">是<code>8</code>, 因为<code>add1</code>相继应用于<code>3</code>五次是<code>8</code>:<pre><code>(add1
  (add1
    (add1
      (add1
        (add1 3)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">整个<code>iter-Nat</code>表达式的类型和<math><mi mathvariant="italic">base</mi></math>的类型相同吗?</td><td class="middled"><sup>21</sup></td><td class="rightd">必然如此, 因为当<math><mi mathvariant="italic">target</mi></math>是<code>zero</code>时, 整个<code>iter-Nat</code>表达式的值是<math><mi mathvariant="italic">base</mi></math>的值.</td></tr></table><table class="dialogue"><tr><td class="leftd">让我们使用<math><mi>X</mi></math>作为<math><mi mathvariant="italic">base</mi></math>的类型的一个名字.<p><math><mi mathvariant="italic">step</mi></math>的类型如何?</p><div class="tcomment"><b>译注.</b> 也就是说, <math><mi>X</mi></math>是一个元变量.</div></td><td class="middled"><sup>22</sup></td><td class="rightd"><math><mi mathvariant="italic">step</mi></math>被应用于<math><mi mathvariant="italic">base</mi></math>, 其也被应用于由<math><mi mathvariant="italic">step</mi></math>产生的几乎是答案的东西 (almost-answer), 故<math><mi mathvariant="italic">step</mi></math>必然是一个<pre><code>(→ <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">就和<a href="#which-Nat">第2章第45框</a>中的<code>which-Nat</code>一样, 名字<math><mi mathvariant="italic">target</mi></math>, <math><mi mathvariant="italic">base</mi></math>, <math><mi mathvariant="italic">step</mi></math>是引用<code>iter-Nat</code>的参数的便利方式.<p>以下的<code>iter-Nat</code>表达式里, target, base, step分别是什么?<pre><code>(iter-Nat 5
  3
  (λ (k)
    (add1 k)))</code></pre></p></td><td class="middled"><sup>23</sup></td><td class="rightd">target是<pre><code>5</code></pre>base是<pre><code>3</code></pre>step是<pre><code>(λ (k)
  (add1 k))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">到目前为止, 我们引用<code>+</code>就好像其已被完全理解了一样, 并且我们还假定其具有规范形式, 然而我们还没有定义<code>+</code>.<p><code>+</code>的类型应该是什么?</p></td><td class="middled"><sup>24</sup></td><td class="rightd"><code>+</code>接受两个<code>Nat</code>而返回一个<code>Nat</code>.<pre><code>(claim +
  (→ Nat Nat Nat))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p>若是递归可以成为一个选项, 那么以下将会是一个正确的定义.<pre class="dashed"><code>(define +
  (λ (n j)
    (which-Nat n
      j
      (λ (n-1)
        <span style="border: 2px solid white; display: inline-block;">(add1 <span style="background-color: white; color: black;">(+ n-1 j)</span>)</span>))))</code></pre>那么, 该如何利用<code>iter-Nat</code>来定义<code>+</code>呢?</p></td><td class="middled"><sup>25</sup></td><td class="rightd">使用<code>iter-Nat</code>定义<code>+</code>需要一个base和一个step. base应该是<code>j</code>, 鉴于以下<q>相同于</q>图表:<ol><li>| <code>(+ zero j)</code></li><li>| <code>j</code></li></ol>有什么好的办法找到step是什么吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">step基于<code>+</code>的递归版本的白框里的内容, 其描述了如何将一个几乎是答案的东西<code>+<sub>n-1</sub></code>变为一个真正的答案.<p>将白纸黑字的部分 (其包含有递归) 替换以献给step的几乎是答案的参数, 记得保留白框里其他内容.</p></td><td class="middled"><sup>26</sup></td><td class="rightd">以下就是我们想要的step了.<pre><code>(claim step-+
  (→ Nat Nat))
(define step-+
  (λ (+<sub>n-1</sub>)
    <span style="border: 2px solid white; display: inline-block;">(add1 <span style="background-color: white; color: black;">+<sub>n-1</sub></span>)</span>))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">除非类型和定义里的所有名字都已定义, 不然我们无法定义一个新的名字.<div class="comment"><b>注记.</b> 如果定义可以相互引用, 那么我们就无法保证每个被定义的函数都是完全函数了.</div></td><td class="middled"><sup>27</sup></td><td class="rightd">而<code>+</code>需要引用<code>step-+</code>, 当然其既已定义.<pre><code>(define +
  (λ (n j)
    (iter-Nat n
      j
      step-+)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 现在<code>+</code>就定义好了.<p><code>(+ (add1 zero) 7)</code>是什么?</p><div class="tcomment"><b>译注.</b> 右侧排版没有按照原文, 见谅.</div></td><td class="middled"><sup>28</sup></td><td class="rightd">是<code>8</code>, 因为<ol><li>| <code>(+ (add1 zero) 7)</code></li><li>| <pre style="display: inline-block"><code>(iter-Nat (add1 zero)
  7
  step-+)</code></pre></li><li>| <pre style="display: inline-block"><code>(step-+
  (iter-Nat zero
    7
    step-+))</code></pre></li><li>| <pre style="display: inline-block"><code>(add1
  (iter-Nat zero
    7
    step-+))</code></pre></li><li>| <code>(add1 7)</code></li></ol>即<code>8</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>iter-Nat</code>可以用来定义<code>gauss</code>吗?</td><td class="middled"><sup>29</sup></td><td class="rightd"><code>iter-Nat</code>展现了一种反复消去<code>add1</code>下面藏着的更小的<code>Nat</code>的方式.<p>消去更小的<code>Nat</code>... 这听起来的确像是<code>gauss</code>所遵照的方法.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">是挺接近的, 但是step没有足够的信息. <code>gauss</code>需要一个结合了<code>which-Nat</code>和<code>iter-Nat</code>的表达力的消去子. 这个消去子叫做<code>rec-Nat</code>.</td><td class="middled"><sup>30</sup></td><td class="rightd"><code>rec-Nat</code>是什么?<div class="tcomment"><b>译注.</b> 根据The Little Typer官网的勘误表, 其实<code>rec-Nat</code>是可以用<code>iter-Nat</code>表达的.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>rec-Nat</code>的step会被应用到两个参数上: 一个是<code>add1</code>下面藏着的那个更小的<code>Nat</code>, 另一个是这更小的<code>Nat</code>上的递归答案. 这是<a href="#pesudo-gauss">第2章第59框</a>里的<code>gauss</code>定义所使用的方法.<p>此即所谓<code>rec-Nat</code>模式.</p><div class="comment"><b>注记.</b> <code>rec-Nat</code>模式也被称为<em>原始递归(primitive recursion)</em>. 感谢R&oacute;zsa P&eacute;ter (1905-1977), Wilhelm Ackermann (1896-1962), Gabriel Sudan (1899-1977), 以及David Hilbert (1862-1943).</div></td><td class="middled"><sup>31</sup></td><td class="rightd">如何使用<code>rec-Nat</code>定义<code>gauss</code>呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个框里有两种<code>gauss</code>的定义: 一个是来源于<a href="#pesudo-gauss">第2章第59框</a>虚框版本, 另一个则是使用<code>rec-Nat</code>的版本.<pre class="dashed"><code>(define gauss
  (λ (n)
    (which-Nat n
      0
      (λ (n-1)
        <span style="border: 2px solid white; display: inline-block;">(+ (add1 n-1) <span style="background-color: white; color: black;">(gauss n-1)</span>)</span>))))</code></pre><pre class="dashed"><code>(define gauss
  (λ (n)
    (rec-Nat n
      0
      (λ (n-1 gauss<sub>n-1</sub>)
        <span style="border: 2px solid white; display: inline-block;">(+ (add1 n-1) <span style="background-color: white; color: black;">gauss<sub>n-1</sub></span>)</span>))))</code></pre>有什么区别呢?</td><td class="middled"><sup>32</sup></td><td class="rightd">三个区别:<ol><li><code>which-Nat</code>代之以<code>rec-Nat</code>,</li><li>内层的<code>λ</code>表达式多了一个变量<code>gauss<sub>n-1</sub></code>, 以及</li><li>递归<code>(gauss n-1)</code>代之以几乎是答案的<code>gauss<sub>n-1</sub></code>.</li></ol><div class="tcomment"><b>译注.</b> 原文中<code>rec-Nat</code>版本的<code>gauss</code>也被加上了虚框, 并不是因为这个定义是错的, 而是因为之后出现的利用辅助过程<code>step-gauss</code>的定义才是正式的.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">名字<code>n-1</code>和<code>gauss<sub>n-1</sub></code>暗示了其意义, 尽管它们只是变量名而已.<p><code>rec-Nat</code>的参数和<code>iter-Nat</code>有着同样的特殊名字: 其总被称为<math><mi mathvariant="italic">target</mi></math>, <math><mi mathvariant="italic">base</mi></math>, <math><mi mathvariant="italic">step</mi></math>.</p></td><td class="middled"><sup>33</sup></td><td class="rightd">我们该如何确定一个<code>rec-Nat</code>表达式的值呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">和<code>iter-Nat</code>一样, 如果target是<code>zero</code>, 那么整个<code>rec-Nat</code>表达式的值即<math><mi mathvariant="italic">base</mi></math>的值.</td><td class="middled"><sup>34</sup></td><td class="rightd">如果target以<code>add1</code>为顶呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>which-Nat</code>应用其step于藏在<code>add1</code>下的这更小的<code>Nat</code>.<p><code>iter-Nat</code>应用其step于一个新的<code>iter-Nat</code>表达式, 其和原本的表达式带有相同的base和step, 但是以藏在<code>add1</code>下的这更小的<code>Nat</code>为新的target.</p><p>这两者该如何结合起来呢?</p></td><td class="middled"><sup>35</sup></td><td class="rightd">我猜一下.<p>step将被应用到这更小的<code>Nat</code>上. 而且, step也会被应用于一个新的<code>rec-Nat</code>表达式, 其和原本的表达式带有相同的base和step, 但是以恰好相同的这更小的<code>Nat</code>为target.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">很好的想法. 当<code>rec-Nat</code>和作为target的非<code>zero</code>的<code>Nat</code>一起使用时, target将藉由每次移除一个<code>add1</code>收缩. 而且和<code>iter-Nat</code>一样, base和step是不会改变的.<pre><code>(rec-Nat (add1 zero)
  0
  (λ (<span style="color: grey;">n-1</span> almost)
    (add1
      (add1 almost))))</code></pre>的值是什么?</td><td class="middled"><sup>36</sup></td><td class="rightd">其为step应用于<code>zero</code>和新的<code>rec-Nat</code>表达式, 即<pre><code>((λ (<span style="color: grey;">n-1</span> almost)
   (add1
     (add1 almost)))
  zero
  (rec-Nat zero
    0
    (λ (<span style="color: grey;">n-1</span> almost)
      (add1
        (add1 almost)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">前一个框中作为结果的表达式并不是一个值, 但是其和原本的表达式是相同的.<p>那么值是什么呢?</p></td><td class="middled"><sup>37</sup></td><td class="rightd"><pre><code>(add1
  (add1
    (rec-Nat zero
      0
      (λ (<span style="color: grey;">n-1</span> almost)
        (add1
          (add1 almost))))))</code></pre>其是一个值, 因为其以<code>add1</code>为顶.</td></tr></table><table class="dialogue"><tr><td class="leftd">其规范形式如何?</td><td class="middled"><sup>38</sup></td><td class="rightd"><pre><code>(add1
  (add1 0))</code></pre>target是<code>zero</code>, 而base是<code>0</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">一个<code>rec-Nat</code>表达式只在target为<code>Nat</code>时是一个表达式.</td><td class="middled"><sup>39</sup></td><td class="rightd">base和step的类型应该是什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">base必然具有某个类型, 让我们再次称其为<math><mi>X</mi></math>. <math><mi>X</mi></math>可以是任意的类型, 但是整个<code>rec-Nat</code>表达式必然和base有着相同的类型, 即<math><mi>X</mi></math>.</td><td class="middled"><sup>40</sup></td><td class="rightd">这就是所有要说的了吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">还没有说完.<p>如果base是一个<math><mi>X</mi></math>, 那么step必然是一个<pre><code>(→ Nat <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></pre>为什么这是step的合适类型呢?</p></td><td class="middled"><sup>41</sup></td><td class="rightd">step会被应用于两个参数: 第一个参数是一个<code>Nat</code>, 因为其为target里藏在<code>add1</code>下的那个东西; 第二个参数是<code>almost</code>, 其为<math><mi>X</mi></math>是因为其也由<code>rec-Nat</code>产生.</td></tr></table><table class="dialogue"><tr><td class="leftd">那么, 这是如何与<code>which-Nat</code>和<code>iter-Nat</code>里的step的类型联系起来的呢?</td><td class="middled"><sup>42</sup></td><td class="rightd">就像<code>which-Nat</code>, <code>rec-Nat</code>的step接受藏在target的<code>add1</code>下的那个更小的<code>Nat</code>作为参数. 就像<code>iter-Nat</code>, 其也接受递归的几乎是答案的结果.</td></tr></table><table class="dialogue" id="dim-almost"><tr><td class="leftd">以下是一个函数, 其判断一个<code>Nat</code>是否是<code>zero</code>.<pre><code>(claim step-zerop
  (→ Nat Atom Atom))
(define step-zerop
  (λ (<span style="color: grey;">n-1</span> <span style="color: grey;">zerop<sub>n-1</sub></span>)
    'nil))
(claim zerop
  (→ Nat Atom))
(define zerop
  (λ (n)
    (rec-Nat n
      't
      step-zerop)))</code></pre><div class="comment"><b>注记.</b> 我们将<code>'t</code>和<code>'nil</code>当成两个任意的值使用. 这或许对于Lisper而言是熟悉的 (感谢John McCarthy (1927-2011)), 但是<code>zerop</code>在Scheme中被称为<code>zero?</code> (感谢Gerald J. Sussman (1947-) 和Guy L. Steele Jr. (1954-)).</div></td><td class="middled"><sup>43</sup></td><td class="rightd">为什么要使用递归性的<code>rec-Nat</code>来定义实际上只需要判断顶层构造子是<code>zero</code>还是<code>add1</code>的过程呢? 毕竟, <code>which-Nat</code>就已经够用了.</td></tr></table><table class="dialogue" id="step-naming"><tr><td class="leftd"><code>which-Nat</code>很容易解释, 但是<code>rec-Nat</code>可以做到任何<code>which-Nat</code> (和<code>iter-Nat</code>) 可以完成的事情.<p>为什么<code>step-zerop</code>中的<code>λ</code>变量被称为<code><span style="color: grey;">n-1</span></code>和<code><span style="color: grey;">zerop<sub>n-1</sub></span></code>呢?</p></td><td class="middled"><sup>44</sup></td><td class="rightd">之所以选取<code><span style="color: grey;">n-1</span></code>这个暗示比<code>n</code>小一的名字, 还是因为其比target <code>Nat</code>小一, target <code>Nat</code>即正被消去的那个<code>Nat</code>表达式. 名字<code><span style="color: grey;">zerop<sub>n-1</sub></span></code>暗示着<code>(zerop n-1)</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">step仅仅是一个<code>λ</code>表达式, 故其他任意未被使用的变量名亦可运用, 但是我们往往在step中使用这种命名变量的风格.<p><code>step-zerop</code>的两个参数皆未被使用, 故其为黯淡的. 因此, 这个定义只是看上去像递归的, 实则并非如此.</p></td><td class="middled"><sup>45</sup></td><td class="rightd">不使用其参数的<code>λ</code>表达式意义何在?</td></tr></table><table class="dialogue" id="step-zerop"><tr><td class="leftd"><code>rec-Nat</code>的step总是接受两个参数, 尽管其并不总是使用它们.<p><code>(zerop 37)</code>的值是什么?</p></td><td class="middled"><sup>46</sup></td><td class="rightd">让我们看看.<ol><li>| <code>(zerop (add1 36))</code></li><li>| <pre style="display: inline-block"><code>(rec-Nat (add1 36)
  't
  step-zerop)</code></pre></li><li>| <pre style="display: inline-block"><code>(step-zerop 36
  (rec-Nat 36
    't
    step-zerop))</code></pre></li><li>| <code>'nil</code></li></ol>值是立刻确定的. 对于<code>36</code> (也就是<code>(add1 35)</code>) 而言的<code>zerop</code>值并不需要, 故我们没有找到它的理由.</td></tr></table><table class="dialogue"><tr><td class="leftd">在表达式的值实际变得必要之前, 我们都无需对于表达式求值. 否则的话, 对于<code>step-zerop</code>的参数<pre><code>(rec-Nat 36
  't
  step-zerop)</code></pre>求值就太花工夫了, 以至于若记录在<q>相同于</q>图表中则需另费至少105行.</td><td class="middled"><sup>47</sup></td><td class="rightd">有时懒惰 (laziness) 是一种美德.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(zerop 37)</code>和<code>(zerop 23)</code>相同吗?</td><td class="middled"><sup>48</sup></td><td class="rightd">是的, 的确.<ol><li>| <code>'nil</code></li><li>| <pre style="display: inline-block"><code>(step-zerop 22
  (rec-Nat 22
    't
    step-zerop))</code></pre></li><li>| <pre style="display: inline-block"><code>(rec-Nat (add1 22)
  't
  step-zerop)</code></pre></li><li>| <code>(zerop (add1 22))</code></li></ol></td></tr></table><table class="dialogue"><tr><td class="leftd">以下是<code>gauss</code>的step.<pre><code>(claim step-gauss
  (→ Nat Nat
    Nat))
(define step-gauss
  (λ (n-1 gauss<sub>n-1</sub>)
    (+ (add1 n-1) gauss<sub>n-1</sub>)))</code></pre></td><td class="middled"><sup>49</sup></td><td class="rightd">这个定理使用了来源于<a href="#step-naming">第3章第44框</a>的命名约定.</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 的确如此.<p>定义step的另一个好处在于我们需要显式地写下其类型, 而不是任其由其于<code>rec-Nat</code>中的使用方式被推断出来.</p></td><td class="middled"><sup>50</sup></td><td class="rightd">显式类型使得阅读和理解定义更为容易.</td></tr></table><table class="dialogue"><tr><td class="leftd">诸如<code><span style="color: grey;">zerop<sub>n-1</sub></span></code>和<code>gauss<sub>n-1</sub></code>这样的step中的<code>λ</code>变量<em>几乎(almost)</em>就是答案了, 其意见于<a href="#almost-answer">第2章第56框</a>.</td><td class="middled"><sup>51</sup></td><td class="rightd">好.<p><code>gauss</code>的正式定义是什么?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">以下就是了.<pre><code>(define gauss
  (λ (n)
    (rec-Nat n
      0
      step-gauss)))</code></pre>base是什么?</td><td class="middled"><sup>52</sup></td><td class="rightd">base即<code>rec-Nat</code>的第二个参数. 这个情况下, 是<code>0</code>, 一个<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">step是什么?</td><td class="middled"><sup>53</sup></td><td class="rightd">即<code>step-gauss</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.</td><td class="middled"><sup>54</sup></td><td class="rightd">根据这个定义, <code>(gauss zero)</code>是什么?</td></tr></table><table class="dialogue"><tr><td class="leftd">是<code>0</code>, 因为<pre><code>(rec-Nat zero
  0
  step-gauss)</code></pre>和<code>rec-Nat</code>的第二个参数相同, 即<code>0</code>.<p>以下是我们找出<code>(gauss (add1 zero))</code>的值的开始.<ol><li>| <code>(gauss (add1 zero))</code></li><li>| <pre style="display: inline-block"><code>(step-gauss zero
  (rec-Nat zero
    0
    step-gauss))</code></pre></li><li>| <pre style="display: inline-block"><code>(+ (add1 zero)
  (rec-Nat zero
    0
    step-gauss))</code></pre></li></ol>现在请继续下去以找到值.</p></td><td class="middled"><sup>55</sup></td><td class="rightd">出发.<ol start="4"><li>| <pre style="display: inline-block"><code>(iter-Nat (add1 zero)
  (rec-Nat zero
    0
    step-gauss)
  step-+)</code></pre></li><li>| <pre style="display: inline-block"><code>(step-+
  (iter-Nat zero
    (rec-Nat zero
      0
      step-gauss)
    step-+))</code></pre></li><li>| <pre style="display: inline-block"><code>(add1
  (iter-Nat zero
    (rec-Nat zero
      0
      step-gauss)
    step-+))</code></pre></li></ol>其已是值, 鉴于其以<code>add1</code>为顶.</td></tr></table><table class="dialogue"><tr><td class="leftd">这个值是规范的吗?</td><td class="middled"><sup>56</sup></td><td class="rightd">不是, 但是以下图表找出了其规范形式.<ol start="7"><li>| <pre style="display: inline-block"><code>(add1
  (rec-Nat zero
    0
    step-gauss))</code></pre></li><li>| <code>(add1 0)</code></li></ol>这的确是规范的了.</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>rec-Nat</code>使用起来总是安全的?</td><td class="middled"><sup>57</sup></td><td class="rightd">这是个好问题.<p>当target以<code>add1</code>为顶时, <code>rec-Nat</code>是递归性的. 既然递归不是一个选项, 为什么这是可以接受的?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">如果step和<a href="#dim-almost">第3章第43框</a>的情况一样不依赖于几乎是答案的参数, 那么我们就已经抵达了一个值. 如果step的确依赖于几乎是答案的参数, 那么我们可以保证递归抵达base, 其总是一个值或者是一个可以成为值的表达式.</td><td class="middled"><sup>58</sup></td><td class="rightd">我们是怎么知道的呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">因为每个target <code>Nat</code>要么和<code>zero</code>相同, 要么和<code>(add1 <math><mi>n</mi></math>)</code>相同, 其中<math><mi>n</mi></math>是一个更小的<code>Nat</code>.</td><td class="middled"><sup>59</sup></td><td class="rightd">我们怎么知道<math><mi>n</mi></math>更小的?</td></tr></table><table class="dialogue"><tr><td class="leftd">使得<math><mi>n</mi></math>相同或者更大的方式是假设target <code>Nat</code>由无限多的<code>add1</code>构造而成. 然而, 因为每个函数都是完全的, 我们没有办法做到这点. 类似地, 没有步骤 (step) 可以不是完全的, 因为这里<em>所有</em>的函数都是完全的, 而每一步骤不过就是应用一个函数.<div class="tcomment"><b>译注.</b> 这段话中的step有点一语双关的意味.</div></td><td class="middled"><sup>60</sup></td><td class="rightd">所以说, 为什么我们不能将这种推理风格应用于任意的递归函数呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这种推理风格无法以我们的工具表达. 但是, 一旦我们相信step完全的<code>rec-Nat</code>是一种消去任意作为target的<code>Nat</code>的方法, 那么每个新定义都是完全的了.<div class="comment"><b>注记.</b> 大致上说, 我们没法做, 但是即便我们能做, 那也会很累人的.</div></td><td class="middled"><sup>61</sup></td><td class="rightd">还有什么使用<code>rec-Nat</code>的更有趣的例子吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">其可以用来定义<code>*</code>, 意即乘法.<p>换言之, 如果<code>n</code>和<code>j</code>是<code>Nat</code>, 那么<pre><code>(* n j)</code></pre>应该是<code>n</code>和<code>j</code>之积.</p><div class="comment"><b>注记.</b> <code>*</code>读作<q>乘 (times)</q>.</div></td><td class="middled"><sup>62</sup></td><td class="rightd"><code>*</code>接受两个<code>Nat</code>并返回一个<code>Nat</code>, 故以下是<code>*</code>的类型.<pre><code>(claim *
  (→ Nat Nat
    Nat))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">对于每一个步骤 (step), <code>+</code>给当时的答案 (the answer so far) 加上一. <code>*</code>的每一步会做什么呢?</td><td class="middled"><sup>63</sup></td><td class="rightd"><code>*</code>会将<code>j</code>加到第二个参数上去, 也就是几乎是答案的那个参数.</td></tr></table><table class="dialogue"><tr><td class="leftd">以下是<code>make-step-*</code>, 其对于每个给定的<code>j</code>产生一个step函数.<pre class="dashed"><code>(claim make-step-*
  (→ Nat
    (→ Nat Nat
      Nat)))
(define make-step-*
  (λ (j)
    (λ (n-1 *<sub>n-1</sub>)
      (+ j *<sub>n-1</sub>))))</code></pre></td><td class="middled"><sup>64</sup></td><td class="rightd">这看起来和之前的step不太一样.</td></tr></table><table class="dialogue"><tr><td class="leftd">不论<code>j</code>为何, <code>make-step-*</code>都构造了一个合适的<code>step</code>. 这个step接受两个参数, 因为和<code>rec-Nat</code>一起使用的step都要接受两个参数, 就和<a href="#step-zerop">第3章第46框</a>中的<code>step-zerop</code>一样.<p>现在定义<code>*</code>.</p></td><td class="middled"><sup>65</sup></td><td class="rightd">好.<p><code>make-step-*</code>的参数是<code>j</code>, 其在每一步里被加到积上去. base为<code>0</code>是因为乘<code>zero</code>等于<code>0</code>.<pre class="dashed"><code>(define *
  (λ (n j)
    (rec-Nat n
      0
      (make-step-* j))))</code></pre></p></td></tr></table><table class="dialogue" id="step-*"><tr><td class="leftd">看起来好像<code>make-step-*</code>在干什么新鲜的事情. 它是一个<code>λ</code>表达式, 并且产生一个<code>λ</code>表达式. 其实无需两步过程, 我们可以将嵌套的<code>λ</code>合并为一个.<pre><code>(claim step-*
  (→ Nat Nat Nat
    Nat))
(define step-*
  (λ (j n-1 *<sub>n-1</sub>)
    (+ j *<sub>n-1</sub>)))</code></pre><code>make-step-*</code>对于任意给定的<code>j</code>产生一个step. 而且, 尽管看起来不同, <code>make-step-*</code>和<code>step-*</code>实际上有着<em>相同的定义</em>.</td><td class="middled"><sup>66</sup></td><td class="rightd">不可能是相同的定义呀, <code>step-*</code>明明是一个具有三个参数的<code>λ</code>表达式.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 所有的<code>λ</code>表达式都恰接受一个参数.<pre><code>(λ (x y z)
  (+ x (+ y z)))</code></pre>不过是<pre><code>(λ (x)
  (λ (y)
    (λ (z)
      (+ x (+ y z)))))</code></pre>的缩写而已.</td><td class="middled"><sup>67</sup></td><td class="rightd">是不是<pre><code>(→ Nat Nat Nat
  Nat)</code></pre>也是某种东西的缩写呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">其是<pre><code>(→ Nat
  (→ Nat
    (→ Nat
      Nat)))</code></pre>的缩写.</td><td class="middled"><sup>68</sup></td><td class="rightd">如果一个函数接受三个参数, 那么可以只应用函数于其中一个.<p>可以仅仅应用这个函数于两个参数吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">如果<math><mi>f</mi></math>是一个<pre><code>(→ Nat Nat Nat
  Nat)</code></pre>那么<pre><code>(<math><mi>f</mi></math> <math><mi>x</mi></math> <math><mi>y</mi></math> <math><mi>z</mi></math>)</code></pre>不过是<pre><code>((<math><mi>f</mi></math> <math><mi>x</mi></math> <math><mi>y</mi></math>) <math><mi>z</mi></math>)</code></pre>的缩写, 而这又是<pre><code>(((<math><mi>f</mi></math> <math><mi>x</mi></math>) <math><mi>y</mi></math>) <math><mi>z</mi></math>)</code></pre>的缩写.</td><td class="middled"><sup>69</sup></td><td class="rightd">是不是每个函数都恰接受一个参数呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">诚然如此, 每个函数恰接受一个参数.<p>定义多参数函数为嵌套的单参数函数的过程被称为<em>Currying</em>.</p><div class="comment"><b>注记.</b> 感谢Haskell B. Curry (1900-1982) 和Moses Ilyich Schönfinkel (1889–1942).</div></td><td class="middled"><sup>70</sup></td><td class="rightd">以下是<code>*</code>的正式定义.<pre><code>(define *
  (λ (n j)
    (rec-Nat n
      0
      (step-* j))))</code></pre>尽管<code>step-*</code>看上去像一个三参数的<code>λ</code>表达式, 它可以只接受一个参数. <code>rec-Nat</code>期望其<code>step</code>是一个恰接受 (get) 两个参数的函数.</td></tr></table><table class="dialogue"><tr><td class="leftd">以下是计算<code>(* 2 29)</code>的规范形式的图表的前五行.<ol><li>| <code>(* 2 29)</code></li><li>| <pre style="display: inline-block"><code>((λ (n j)
   (rec-Nat n
     0
     (step-* j)))
  2 29)</code></pre></li><li>| <pre style="display: inline-block"><code>(rec-Nat (add1
           (add1 zero))
  0
  (step-* 29))</code></pre></li><li>| <pre style="display: inline-block"><code>((step-* 29)
 (add1 zero)
 (rec-Nat (add1 zero)
   0
   (step-* 29)))</code></pre></li><li>| <pre style="display: inline-block"><code>((λ (n-1 *<sub>n-1</sub>)
   (+ 29 *<sub>n-1</sub>))
 (add1 zero)
 (rec-Nat (add1 zero)
   0
   (step-* 29)))</code></pre></li></ol>现在, 继续找出规范形式.</td><td class="middled"><sup>71</sup></td><td class="rightd">啊, Currying也有参与.<ol start="6"><li>| <pre style="display: inline-block"><code>(+ 29
   (rec-Nat (add1 zero)
     0
     (step-* 29)))</code></pre></li><li>| <pre style="display: inline-block"><code>(+ 29
   ((step-* 29)
    zero
    (rec-Nat zero
      0
      (step-* 29))))</code></pre></li><li>| <pre style="display: inline-block"><code>(+ 29
   (+ 29
      (rec-Nat zero
        0
        (step-* 29))))</code></pre></li><li>| <pre style="display: inline-block"><code>(+ 29
   (+ 29 0))</code></pre></li><li>| <code>58</code></li></ol>这个图表有遗漏什么步骤吗?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-Nat</code>之律</div><p>如果<math><mi mathvariant="italic">target</mi></math>是一个<code>Nat</code>, <math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, <math><mi mathvariant="italic">step</mi></math>是一个<pre><code>(→ Nat <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></pre>那么<pre><code>(rec-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-Nat</code>之第一诫</div><p>如果<pre><code>(rec-Nat zero
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么其和<math><mi mathvariant="italic">base</mi></math>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-Nat</code>之第二诫</div><p>如果<pre><code>(rec-Nat (add1 <math><mi>n</mi></math>)
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么其和<pre><code>(<math><mi mathvariant="italic">step</mi></math> <math><mi>n</mi></math>
  (rec-Nat <math><mi>n</mi></math>
    <math><mi mathvariant="italic">base</mi></math>
    <math><mi mathvariant="italic">step</mi></math>))</code></pre>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">当然有了, 比如说使得<code>(+ 29 0)</code>以及作为结果的<code>(+ 29 29)</code>规范的过程.<div class="comment"><b>注记.</b> 这个图表节约纸张, 能量, 时间.</div></td><td class="middled"><sup>72</sup></td><td class="rightd">谢谢.<p>从一开始, 这种图表似乎就会变得很乏味.</p></td></tr></table><table class="dialogue" id="wrong-fact"><tr><td class="leftd">就是这样.<pre class="dashed"><code>(claim step-<span style="border: 2px solid white; display: inline-block;">    </span>
  (→ Nat Nat
    Nat))
(define step-<span style="border: 2px solid white; display: inline-block;">    </span>
  (λ (n-1 almost)
    (* (add1 n-1) almost)))
(claim <span style="border: 2px solid white; display: inline-block;">    </span>
  (→ Nat
    Nat))
(define <span style="border: 2px solid white; display: inline-block;">    </span>
  (λ (n)
    (rec-Nat n
      0
      step-<span style="border: 2px solid white; display: inline-block;">    </span>)))</code></pre>这个定义取什么名字比较合适呢?</td><td class="middled"><sup>73</sup></td><td class="rightd">这个函数总是返回<code>0</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">非常善于观察啊.<p>像<code>Nat</code>这样的类型的一个缺陷在于其不能说明<em>哪个(which)</em> <code>Nat</code>是我们所意图的. 之后, 我们将遇到更为强大的类型, 其允许我们讨论<em>特定</em>的<code>Nat</code>.</p><div class="comment"><b>注记.</b> 实际上, <a href="#wrong-fact">第3章第73框</a>中的定义本意在是<code>factorial</code>. 然而, 疏忽导致了错误一直存在于诸多草稿版本之中却未被发现 (至于有多少这样的版本, 作者不想说了). 我们将纠错的任务留给读者.</div></td><td class="middled"><sup>74</sup></td><td class="rightd">那么, 更为强大的类型可以阻止我们像<a href="#wrong-five">第2章第39框</a>里那样将<code>five</code>定义成是<code>9</code>吗?<div class="tcomment"><b>译注.</b> 原文为第2章第36框, 应该是笔误.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">当然不行了.<p>类型并不能阻止将<code>five</code>定义成是<code>9</code>的愚蠢行径. 但是, 我们可以将我们的<em>一些</em>想法写成类型.</p></td><td class="middled"><sup>75</sup></td><td class="rightd">非常有趣.</td></tr></table><h2>第4章 小菜一碟, 简单如Pie</h2><table class="dialogue"><tr><td class="leftd">在<a href="#Pear-definition">第2章第80框</a>里, 我们定义<code>Pear</code>为<pre class="dashed"><code>(claim Pear <math><mi mathvariant="script">U</mi></math>)
(define Pear
  (Pair Nat Nat))</code></pre><code>Pear</code>的消去子是由<code>car</code>和<code>cdr</code>定义的.</td><td class="middled"><sup>1</sup></td><td class="rightd">并且...</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Pear</code>的一个消去子必须要做什么呢?</td><td class="middled"><sup>2</sup></td><td class="rightd">这个消去子必须要暴露 (或者说解包) 一个<code>Pear</code>中的信息.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Pair</code>的消去子呢? 它必须要做什么?</td><td class="middled"><sup>3</sup></td><td class="rightd"><code>Pair</code>的一个消去子必然要暴露一个<code>Pair</code>中的信息.</td></tr></table><table class="dialogue"><tr><td class="leftd">那很接近了.<br/>正如<a href="#alone">第1章第22框</a>所言, <code>Pair</code>单独不是一个表达式, 然而<pre><code>(Pair Nat Nat)</code></pre>是一个表达式, 并且它有消去子.<pre><code>(Pair Nat Atom)</code></pre>也有消去子.</td><td class="middled"><sup>4</sup></td><td class="rightd">再次尝试:<pre><code>(Pair Nat Nat)</code></pre>的一个消去子必然要暴露一个特定<pre><code>(Pair Nat Nat)</code></pre>中的信息, 一个<pre><code>(Pair Nat Atom)</code></pre>的消去子必然要暴露一个特定<pre><code>(Pair Nat Atom)</code></pre>中的信息.</td></tr></table><table class="dialogue"><tr><td class="leftd">但是, 这意味着<code>Pair</code>需要许多消去子, 因为就像<a href="#nested-Pair">第2章第36框</a>一样, 更深的嵌套总是可能的.</td><td class="middled"><sup>5</sup></td><td class="rightd">听起来要记得好多名字的样子.</td></tr></table><table class="dialogue"><tr><td class="leftd">本会如此!<p>实际上, 还有更好的方式. 我们可以提供一个<code>(Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)</code>的消去子, <em>不论<math><mi>A</mi></math>和<math><mi>D</mi></math>为何.</em></p></td><td class="middled"><sup>6</sup></td><td class="rightd">不论为何? 即便<math><mi>A</mi></math>是<code>'apple-pie</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">好吧, 当然不是绝对任意的.<p>根据<a href="#Pair-type">第1章第54框</a>, 除非<math><mi>A</mi></math>和<math><mi>D</mi></math>是<em>类型</em>. 也就是说, <math><mi>A</mi></math>必须是一个类型且<math><mi>D</mi></math>必须是一个类型.</p></td><td class="middled"><sup>7</sup></td><td class="rightd">哇! 那这消去子看起来长什么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">给个例子.<pre><code>(claim kar
  (→ (Pair Nat Nat)
    Nat))</code></pre><pre class="dashed"><code>(define kar
  (λ (p)
    (elim-Pair
      Nat Nat
      Nat
      p
      (λ (a <span style="color: grey;">d</span>)
        a))))</code></pre>因为<code>elim-Pair</code>还未被定义, 所以<code>kar</code>的定义才会用虚线框起来, 不是别的什么原因.</td><td class="middled"><sup>8</sup></td><td class="rightd">为什么<code>elim-Pair</code>有这么多参数啊?</td></tr></table><table class="dialogue"><tr><td class="leftd">在这个定义里, <code>elim-Pair</code>的前三个参数都是类型<code>Nat</code>. 前两个参数刻画了要被消去的<code>Pair</code>的<code>car</code>部分和<code>cdr</code>部分的类型. 这第三个参数<code>Nat</code>描述了内层的<code>λ</code>表达式的结果类型.<div class="comment"><b>注记.</b> 因此, 内层的<code>λ</code>表达式的参数<code>a</code>和<code><span style="color: grey;">d</span></code>的类型也都是<code>Nat</code>.</div></td><td class="middled"><sup>9</sup></td><td class="rightd">内层的<code>λ</code>表达式的意图是什么?</td></tr></table><table class="dialogue"><tr><td class="leftd">内层的<code>λ</code>表达式描述了如何使用<code>p</code>的值中的信息. 所谓的信息即<code>p</code>的<code>car</code>和<code>cdr</code>部分.</td><td class="middled"><sup>10</sup></td><td class="rightd">为什么<code><span style="color: grey;">d</span></code>是黯淡的?</td></tr></table><table class="dialogue"><tr><td class="leftd">参数名<code><span style="color: grey;">d</span></code>之所以是黯淡的, 是因为其出现在内层的<code>λ</code>表达式里, 却未被使用, 就和<a href="#dim">第2章第47框</a>一样.<p>现在请定义一个类似的函数<code>kdr</code>, 其找出一个<code>Nat</code>序对的<code>cdr</code>.</p></td><td class="middled"><sup>11</sup></td><td class="rightd">几乎和<code>kar</code>一模一样.<pre><code>(claim kdr
  (→ (Pair Nat Nat)
    Nat))</code></pre><pre class="dashed"><code>(define kdr
  (λ (p)
    (elim-Pair
      Nat Nat
      Nat
      p
      (λ (<span style="color: grey;">a</span> d)
        d))))</code></pre>这次之所以<code><span style="color: grey;">a</span></code>是黯淡的, 是因为其在内层的<code>λ</code>表达式中未被使用, 而<code>d</code>是正常的. 鉴于<code>elim-Pair</code>还没有定义, <code>kdr</code>也被虚框包裹, 就和<code>kar</code>一样.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p>请编写一个叫做<code>swap</code>的函数, 其交换一个<code>(Pair Nat Atom)</code>的<code>car</code>和<code>cdr</code>.</p></td><td class="middled"><sup>12</sup></td><td class="rightd">以下是<code>swap</code>的类型.<pre><code>(claim swap
  (→ (Pair Nat Atom)
    (Pair Atom Nat)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">现在定义<code>swap</code>.</td><td class="middled"><sup>13</sup></td><td class="rightd">以下是<code>swap</code>的定义. 就和<code>kar</code>和<code>kdr</code>一样, 其也被包裹在虚框里.<pre class="dashed"><code>(define swap
  (λ (p)
    (elim-Pair
      Nat Atom
      (Pair Atom Nat)
      p
      (λ (a d)
        (cons d a)))))</code></pre></td></tr></table><table class="dialogue" id="invalid-type"><tr><td class="leftd">一般说来, <code>elim-Pair</code>的用法如下:<pre><code>(elim-Pair
  <math><mi>A</mi></math> <math><mi>D</mi></math>
  <math><mi>X</mi></math>
  <math><mi>p</mi></math>
  <math><mi>f</mi></math>)</code></pre>其中<math><mi>p</mi></math>是一个<code>(Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)</code>, 而<math><mi>f</mi></math>根据<math><mi>p</mi></math>的<code>car</code>和<code>cdr</code>来确定整个表达式的值. 这个值必然具有类型<math><mi>X</mi></math>.<p><code>elim-Pair</code>的类型是什么?</p></td><td class="middled"><sup>14</sup></td><td class="rightd">以下是一个猜测, 可能是<pre><code>(→ A D
   X
   (Pair A D)
   (→ A D
     X)
  X)</code></pre>因为<code>A</code>, <code>D</code>, <code>X</code>是前三个参数, 第四个参数是一个<code>(Pair A D)</code>, 而第五个应该基于一个<code>A</code>和一个<code>D</code>作出一个<code>X</code>来.</td></tr></table><table class="dialogue"><tr><td class="leftd">但是, 这个表达式里的<code>A</code>, <code>D</code>, <code>X</code>是什么呢?</td><td class="middled"><sup>15</sup></td><td class="rightd"><code>A</code>, <code>D</code>, <code>X</code>是<code>elim-Pair</code>的前三个参数?</td></tr></table><table class="dialogue"><tr><td class="leftd">它们会引用之前已经定义过的类型吗?</td><td class="middled"><sup>16</sup></td><td class="rightd">不会, 因为它们指的是<em>不论什么样的参数</em>.</td></tr></table><table class="dialogue"><tr><td class="leftd">一个表达式中的名字要么引用一个定义, 要么指的是由一个<code>λ</code>所命名的一个参数. 显然这个表达式里没有<code>λ</code>, 并且<code>A</code>, <code>D</code>, <code>X</code>也都没有被定义.</td><td class="middled"><sup>17</sup></td><td class="rightd">这必然意味着<a href="#invalid-type">第4章第14框</a>中的那个表达式实际上并非一个类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p>然而, 这种思维过程的确言之成理. 回忆一下, 成为一个<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>是什么意思.</p></td><td class="middled"><sup>18</sup></td><td class="rightd">一个<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>是一个<code>λ</code>表达式, 当接受一个<math><mi>Y</mi></math>时, 产生一个<math><mi>X</mi></math>. 它也可以是一个值为这样的<code>λ</code>表达式的表达式. 我说的对不对呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><math><mi>Y</mi></math>和<math><mi>X</mi></math>都是类型吗?</td><td class="middled"><sup>19</sup></td><td class="rightd">必然如此, 否则<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>就不是一个类型了.</td></tr></table><table class="dialogue"><tr><td class="leftd">在之前我们提出的<code>elim-Pair</code>的类型里, <code>A</code>, <code>D</code>, <code>X</code>是类型构造子吗?</td><td class="middled"><sup>20</sup></td><td class="rightd">并非如此, 它们和<code>Nat</code>或者<code>Atom</code>不是一种表达式, 因为每次<code>elim-Pair</code>应用时它们都可能改变, 而<code>Nat</code>永远是<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">在之前我们提出的<code>elim-Pair</code>的类型里, <code>A</code>, <code>D</code>, <code>X</code>是被定义来指代类型的名字吗?</td><td class="middled"><sup>21</sup></td><td class="rightd">当然不是, 出于相同的原因, 即每次<code>elim-Pair</code>应用时它们都可能改变. 但是, 一旦一个名字被<code>define</code>了, 它就永远指的是相同的东西了.</td></tr></table><table class="dialogue"><tr><td class="leftd">这个消去子必然要能够讨论<em>任意</em>的类型<code>A</code>, <code>D</code>, <code>X</code>.</td><td class="middled"><sup>22</sup></td><td class="rightd">听上去<code>→</code>没法完成任务.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确不行, 但是<code>Π</code>行.<div class="comment"><b>注记.</b> <code>Π</code>读作<q>pie</q>, 并且也可以写成<code>Pi</code>.</div></td><td class="middled"><sup>23</sup></td><td class="rightd"><code>Π</code>是什么意思呢?</td></tr></table><table class="dialogue" id="flip-def"><tr><td class="leftd">以下是一个例子.<pre><code>(claim flip
  (Π ((A <math><mi mathvariant="script">U</mi></math>)
      (D <math><mi mathvariant="script">U</mi></math>))
    (→ (Pair A D)
      (Pair D A))))
(define flip
  (λ (<span style="color: grey;">A</span> <span style="color: grey;">D</span>)
    (λ (p)
      (cons (cdr p) (car p)))))</code></pre></td><td class="middled"><sup>24</sup></td><td class="rightd">是不是这意味着一个<code>λ</code>表达式的类型可以是一个<code>Π</code>表达式?</td></tr></table><table class="dialogue"><tr><td class="leftd">好问题.<p>的确可以.</p></td><td class="middled"><sup>25</sup></td><td class="rightd">如果说<code>Π</code>和<code>→</code>都可以用来描述<code>λ</code>表达式, 那么它们有什么区别呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(flip Nat Atom)</code></pre>的值是什么?</td><td class="middled"><sup>26</sup></td><td class="rightd">那必然是<code>λ</code>表达式<pre><code>(λ (p)
  (cons (cdr p) (car p)))</code></pre>这是因为<code>flip</code>被定义为是一个<code>λ</code>表达式, 而其被应用于了两个参数, <code>Nat</code>和<code>Atom</code>.</td></tr></table><table class="dialogue" id="flip-use"><tr><td class="leftd"><pre><code>((flip Nat Atom)
 (cons 17 'apple))</code></pre>的值是什么?</td><td class="middled"><sup>27</sup></td><td class="rightd">其是<pre><code>(cons 'apple 17)</code></pre>一个<pre><code>(Pair Atom Nat)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Π</code>和<code>→</code>的不同在于一个函数应用于其参数这样的表达式的类型.<pre><code>(flip Nat Atom)</code></pre>的类型为<pre><code>(→ (Pair Nat Atom)
  (Pair Atom Nat))</code></pre>这是因为当一个由<code>Π</code>表达式所描述的表达式被应用时, 参数表达式将代替<code>Π</code>表达式的<em>体</em>里的<em>参数名</em>.</td><td class="middled"><sup>28</sup></td><td class="rightd"><code>Π</code>表达式的体和<code>λ</code>表达式的体有着怎样的联系呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Π</code>表达式和<code>λ</code>表达式都会引入参数名, 而体是这些名字可以使用的地方.</td><td class="middled"><sup>29</sup></td><td class="rightd">什么是<em>参数名</em>?</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair A D)
    (Pair D A)))</code></pre>在这个<code>Π</code>表达式里, 参数名是<code>A</code>和<code>D</code>. <code>Π</code>表达式可以有一个或更多的参数名, 而这些参数名可以出现在<code>Π</code>表达式的体中.</td><td class="middled"><sup>30</sup></td><td class="rightd"><code>Π</code>表达式的<em>体</em>是什么?</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair A D)
    (Pair D A)))</code></pre>在这个<code>Π</code>表达式里, 体是<pre><code>(→ (Pair A D)
  (Pair D A))</code></pre>这个是(<code>flip</code>所代表的)<code>λ</code>表达式的体的类型, 这个体由<code>Π</code>表达式的体所描述.<div class="tcomment"><b>译注.</b> 这句话读起来稍显冗余.</div></td><td class="middled"><sup>31</sup></td><td class="rightd"><code>Π</code>表达式的体里的<code>A</code>和<code>D</code>指的是什么?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">应用之中律</div><p>如果<math><mi>f</mi></math>是一个<pre><code>(Π ((<math><mi>Y</mi></math> <math><mi mathvariant="script">U</mi></math>)) <math><mi>X</mi></math>)</code></pre>而<math><mi>Z</mi></math>是一个<math><mi mathvariant="script">U</mi></math>, 那么<pre><code>(<math><mi>f</mi></math> <math><mi>Z</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 其中每个<math><mi>Y</mi></math>都已被一致地替换为了<math><mi>Z</mi></math>.</p><div class="tcomment"><b>译注.</b> 原文的<math><mi>Y</mi></math>实际上使用的是无衬线字体, 即<code>Y</code>. 但是, 译者认为<math><mi>Y</mi></math>应该是一个代表句法上的变量的元变量.</div></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">体里的<code>A</code>和<code>D</code>指的是尚不可知的特定类型. 不论哪两个类型<math><mi>A</mi></math>和<math><mi>D</mi></math>作为由<code>Π</code>表达式所描述的<code>λ</code>表达式的参数, 应用这<code>λ</code>表达式的结果总是一个<pre><code>(→ (Pair <math><mi>A</mi></math> <math><mi>D</mi></math>)
  (Pair <math><mi>D</mi></math> <math><mi>A</mi></math>))</code></pre><div class="tcomment"><b>译注.</b> 请读者注意字体, <code>A</code>和<math><mi>A</mi></math>相当不同.</div></td><td class="middled"><sup>32</sup></td><td class="rightd">是不是这意味着<pre><code>(flip Atom (Pair Nat Nat))</code></pre>的类型为<pre><code>(→ (Pair Atom
     (Pair Nat Nat))
  (Pair (Pair Nat Nat)
    Atom))</code></pre>呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">对的.<p>但为什么会是如此呢?</p></td><td class="middled"><sup>33</sup></td><td class="rightd">变量<code>A</code>和<code>D</code>被替换以其相应的参数: <code>Atom</code>和<code>(Pair Nat Nat)</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair A D)
    (Pair D A)))</code></pre>和<pre><code>(Π ((Lemon <math><mi mathvariant="script">U</mi></math>)
    (Meringue <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair Lemon Meringue)
    (Pair Meringue Lemon)))</code></pre>是相同的类型吗?</td><td class="middled"><sup>34</sup></td><td class="rightd">的确如此, 因为正如<a href="#rename">第2章第21框</a>所言, 一致地对于变量换名不会改变任何东西的意义.<div class="tcomment"><b>译注.</b> meringue, 蛋白酥.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair A D)
    (Pair D A)))</code></pre>和<pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair
       (car
         (cons A D))
       (cdr
         (cons A D)))
    (Pair D A)))</code></pre>是相同的类型吗?</td><td class="middled"><sup>35</sup></td><td class="rightd">是的, 因为<pre><code>(car
  (cons A D))</code></pre>和<code>A</code>是相同的类型, 而<pre><code>(cdr
  (cons A D))</code></pre>和<code>D</code>是相同的类型.</td></tr></table><table class="dialogue" id="flip-def2"><tr><td class="leftd">我们可以这样定义<code>flip</code>吗?<pre class="dashed"><code>(claim flip
  (Π ((A <math><mi mathvariant="script">U</mi></math>)
      (D <math><mi mathvariant="script">U</mi></math>))
    (→ (Pair A D)
      (Pair D A))))
(define flip
  (λ (<span style="color: grey;">C</span> <span style="color: grey;">A</span>)
    (λ (p)
      (cons (cdr p) (car p)))))</code></pre></td><td class="middled"><sup>36</sup></td><td class="rightd">以下是我的猜测.<p>在这个定义里, 外层的<code>λ</code>表达式中的(参数)名字和<code>Π</code>表达式中的名字不同. 似乎这个定义不应该能够成立. <code><span style="color: grey;">A</span></code>出现在错误的位置, 而<code><span style="color: grey;">C</span></code>既不是<code>A</code>也不是<code>D</code>.</p><div class="tcomment"><b>译注.</b> 原文的后两个<code>A</code>和<code>D</code>本是黯淡的, 但是译者认为既然它们指的是<code>Π</code>表达式中的相应变量, 所以说它们应该是正常颜色更好.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><a href="#flip-def2">第4章第36框</a>中提出的<code>flip</code>定义是可以允许的. 然而, 就像定义<code>five</code>为意指<code>9</code>一样, 这是愚蠢的.</td><td class="middled"><sup>37</sup></td><td class="rightd">为什么可以允许这样的定义呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">外层的<code>λ</code>中的名字不需要匹配<code>Π</code>表达式中的名字. 外层的<code>λ</code>表达式中的<code><span style="color: grey;">C</span></code>与<code>Π</code>表达式中的<code>A</code>相对应, 因为它们都是第一个名字. 外层的<code>λ</code>表达式中的<code><span style="color: grey;">A</span></code>与<code>Π</code>表达式中的<code>D</code>相对应, 因为它们都是第二个名字. 重要的是参数命名的<em>顺序</em>.<div class="comment"><b>注记.</b> 尽管使用不相匹配的名字并非错误, 但这的确相当令人困惑. 我们总是使用匹配的名字.</div>内层的<code>λ</code>表达式中的<code>p</code>与什么相对应?</td><td class="middled"><sup>38</sup></td><td class="rightd">与<code>p</code>相对应的是<code>→</code>后跟着的<code>(Pair A D)</code>, 其给出了内层<code>λ</code>表达式的参数类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">如何对于<a href="#flip-def2">第4章第36框</a>中的定义里的<code><span style="color: grey;">C</span></code>和<code><span style="color: grey;">A</span></code>进行一致换名以改善这个定义?</td><td class="middled"><sup>39</sup></td><td class="rightd">首先, <code><span style="color: grey;">A</span></code>应该被重命名为<code><span style="color: grey;">D</span></code>. 接着, <code><span style="color: grey;">C</span></code>应该被重命名为<code><span style="color: grey;">A</span></code>. 这不就是<a href="#flip-def">第4章第24框</a>中的定义吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">现在可以定义<code>Pair</code>的那个消去子了吗?</td><td class="middled"><sup>40</sup></td><td class="rightd">是的, 其类型应该是<pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>)
    (D <math><mi mathvariant="script">U</mi></math>)
    (X <math><mi mathvariant="script">U</mi></math>))
  (→ (Pair A D)
     (→ A D
       X)
    X))</code></pre>这看起来很像<a href="#invalid-type">第4章第14框</a>里的那个类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p><code>elim-Pair</code>的定义是什么?</p></td><td class="middled"><sup>41</sup></td><td class="rightd"><pre><code>(claim elim-Pair
  (Π ((A <math><mi mathvariant="script">U</mi></math>)
      (D <math><mi mathvariant="script">U</mi></math>)
      (X <math><mi mathvariant="script">U</mi></math>))
    (→ (Pair A D)
       (→ A D
         X)
      X)))
(define elim-Pair
  (λ (<span style="color: grey;">A</span> <span style="color: grey;">D</span> <span style="color: grey;">X</span>)
    (λ (p f)
      (f (car p) (cdr p)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">现在<code>kar</code>不需要虚框了.<pre><code>(define kar
  (λ (p)
    (elim-Pair
      Nat Nat
      Nat
      p
      (λ (a <span style="color: grey;">d</span>)
        a))))</code></pre></td><td class="middled"><sup>42</sup></td><td class="rightd"><code>kdr</code>也是.<pre><code>(define kdr
  (λ (p)
    (elim-Pair
      Nat Nat
      Nat
      p
      (λ (<span style="color: grey;">a</span> d)
        d))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>swap</code>也是.</td><td class="middled"><sup>43</sup></td><td class="rightd">是的.<pre><code>(define swap
  (λ (p)
    (elim-Pair
      Nat Atom
      (Pair Atom Nat)
      p
      (λ (a d)
        (cons d a)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">尽管一个<code>Π</code>表达式可以拥有任意数目的参数名, 还是首先描述单参数<code>Π</code>表达式为类型的情形最为简单.<p>成为一个<pre><code>(Π ((<math><mi>Y</mi></math> <math><mi mathvariant="script">U</mi></math>)) <math><mi>X</mi></math>)</code></pre>即是成为一个<code>λ</code>表达式, 当且被应用于一个类型<math><mi>T</mi></math>时, 将会产生一个表达式, 其类型是将<math><mi>X</mi></math>中的每个<math><mi>Y</mi></math>一致地替换以<math><mi>T</mi></math>的结果.</p></td><td class="middled"><sup>44</sup></td><td class="rightd">是不是忘了什么?</td></tr></table><table class="dialogue"><tr><td class="leftd">也可以是一个表达式, <em>其值是</em>这样的<code>λ</code>表达式.</td><td class="middled"><sup>45</sup></td><td class="rightd">不要忘记求值是重要的.<p>这是对于<code>Π</code>表达式的完整描述了吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">不, 还不完全.<p>基于单参数的<code>Π</code>表达式<pre><code>(Π ((<math><mi>Y</mi></math> <math><mi mathvariant="script">U</mi></math>) (<math><mi>Z</mi></math> <math><mi mathvariant="script">U</mi></math>)) <math><mi>X</mi></math>)</code></pre>该怎样理解呢?</p></td><td class="middled"><sup>46</sup></td><td class="rightd">它应该意味着一个<code>λ</code>表达式 (或者能求值至这样的<code>λ</code>表达式), 当其被应用于两个类型<math><mi>T</mi></math>和<math><mi>S</mi></math>时, 将会产生一个表达式, 其类型可由一致地将<math><mi>X</mi></math>中的每个<math><mi>Y</mi></math>替换以<math><mi>T</mi></math>然后再将这新的<math><mi>X</mi></math>中的每个<math><mi>Z</mi></math>替换以<math><mi>S</mi></math>获得.<div class="tcomment"><b>译注.</b> 这里假定<math><mi>Y</mi></math>和<math><mi>Z</mi></math>相异, 至于不相异的情况该如何解释, 实际上多个参数的<code>Π</code>表达式可以理解为单参数<code>Π</code>表达式的嵌套.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Π</code>表达式可以拥有任意数目的参数, 而其所描述的<code>λ</code>表达式有着相同数目的参数.<p>什么表达式具有类型<pre><code>(Π ((A <math><mi mathvariant="script">U</mi></math>))
  (→ A (Pair A A)))</code></pre>呢?</p></td><td class="middled"><sup>47</sup></td><td class="rightd">比如说以下这个?<pre><code>(λ (<span style="color: grey;">A</span>)
  (λ (a)
    (cons a a)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">以下我们为熟悉的表达式取了个名字.<pre class="dashed"><code>(claim twin-Nat
  (→ Nat
    (Pair Nat Nat)))
(define twin-Nat
  (λ (x)
    (cons x x)))</code></pre><pre><code>(twin-Nat 5)</code></pre>的值是什么?<div class="comment"><b>注记.</b> 自<a href="#twin">第2章第19框</a>起就熟悉了.</div></td><td class="middled"><sup>48</sup></td><td class="rightd">是<pre><code>(cons 5 5)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">以下是一个非常类似的定义.<pre class="dashed"><code>(claim twin-Atom
  (→ Atom
    (Pair Atom Atom)))
(define twin-Atom
  (λ (x)
    (cons x x)))</code></pre><pre><code>(twin-Atom 'cherry-pie)</code></pre>的值是什么?</td><td class="middled"><sup>49</sup></td><td class="rightd">是<pre><code>(cons 'cherry-pie 'cherry-pie)</code></pre>这些定义有什么问题? 为什么它们被虚线框起来了?<div class="tcomment"><b>译注.</b> 之所以用虚线框起来, 是因为这些定义不够一般, 于是不值得定义, 而应该代之以一个更一般的版本.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">之于<pre><code>(λ (a)
  (cons a a))</code></pre><code>Nat</code>和<code>Atom</code>没什么特别之处. 因此, 与其对于每个类型写下一个新的定义, 我们不如使用<code>Π</code>构建一个一般目的性的<code>twin</code>, 其可以对于<em>任意</em>的类型成立.</td><td class="middled"><sup>50</sup></td><td class="rightd">以下即是一般目的性的<code>twin</code>.<pre><code>(claim twin
  (Π ((Y U))
    (→ Y
      (Pair Y Y))))
(define twin
  (λ (Y)
    (λ (x)
      (cons x x))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(twin Atom)</code>的值是什么?</td><td class="middled"><sup>51</sup></td><td class="rightd"><code>(twin Atom)</code>是<pre><code>(λ (x)
  (cons x x))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(twin Atom)</code>的类型是什么?</td><td class="middled"><sup>52</sup></td><td class="rightd">一致地将<pre><code>(→ Y
  (Pair Y Y))</code></pre>中的每个<code>Y</code>替换以<code>Atom</code>就得到了<pre><code>(→ Atom
  (Pair Atom Atom))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>twin-Atom</code>的类型和<code>(twin Atom)</code>的类型之间有什么联系?</td><td class="middled"><sup>53</sup></td><td class="rightd"><code>twin-Atom</code>的类型和<code>(twin Atom)</code>的类型是相同的类型.</td></tr></table><table class="dialogue" id="twin-Atom"><tr><td class="leftd">接着, 使用一般性的<code>twin</code>来定义<code>twin-Atom</code>.<pre><code>(claim twin-Atom
  (→ Atom
    (Pair Atom Atom)))</code></pre></td><td class="middled"><sup>54</sup></td><td class="rightd">可以使用来自于<a href="#flip-use">第4章第27框</a>的技巧.<pre><code>(define twin-Atom
  (twin Atom))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(twin-Atom 'cherry-pie)</code></pre>和<pre><code>((twin Atom) 'cherry-pie)</code></pre>是相同的<pre><code>(Pair Atom Atom)</code></pre>吗?</td><td class="middled"><sup>55</sup></td><td class="rightd">是的, 并且其值 (也是规范形式) 为<pre><code>(cons 'cherry-pie 'cherry-pie)</code></pre>对于甜点而言, 这就是双倍了!</td></tr></table><h2>第5章 表, 表, 更多的表</h2><table class="dialogue"><tr><td class="leftd"><code>Π</code>怎么样?</td><td class="middled"><sup>1</sup></td><td class="rightd">美味至极. 尽管如此, 使用餐巾可以使得用餐不那么狼狈.</td></tr></table><table class="dialogue"><tr><td class="leftd">在我们开始之前, 你有没有<ul><li>烹饪普罗旺斯杂烩,</li><li>吃完两个樱桃派,</li><li>尝试使用带图画的餐巾清理一下,</li><li>理解<code>rec-Nat</code>, 以及</li><li>休息安睡好</li></ul>呢?</td><td class="middled"><sup>2</sup></td><td class="rightd">这俨然是期望清单.</td></tr></table><table class="dialogue" id="nil"><tr><td class="leftd">是的, 不过这些是很好的期望.<pre><code>(claim expectations
  (List Atom))
(define expectations
  (:: 'cooked
    (:: 'eaten
      (:: 'tried-cleaning
        (:: 'understood
          (:: 'slept nil))))))</code></pre></td><td class="middled"><sup>3</sup></td><td class="rightd">这段代码有些令我困惑, 在于以下几个方面:<ul><li><code>::</code>还没有描述,</li><li>类型构造子<code>List</code>还没有描述, 以及</li><li>原子<code>'nil</code>已经作为<code>step-zerop</code>的一部分被使用.</li></ul></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>'nil</code>和<a href="#nil">第5章第3框</a>里的<code>nil</code>是相同的吗?</td><td class="middled"><sup>4</sup></td><td class="rightd">不是, 因为<a href="#nil">第5章第3框</a>里的<code>nil</code>并非一个<code>Atom</code>, 其不以单引号开头.<p><code>nil</code>是一个表达式吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>List</code>是一个类型构造子. 如果<math><mi>E</mi></math>是一个类型, 那么<code>(List <math><mi>E</mi></math>)</code>是一个类型.<div class="comment"><b>注记.</b> 读作<q>类型为<math><mi>E</mi></math>的元素的列表</q>或者更简单的<q><math><mi>E</mi></math>的列表</q>.</div></td><td class="middled"><sup>5</sup></td><td class="rightd">那么, 成为一个<code>(List <math><mi>E</mi></math>)</code>的意思是什么呢?</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>List</code>之律</div><p>如果<math><mi>E</mi></math>是一个类型, 那么<code>(List <math><mi>E</mi></math>)</code>是一个类型.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>nil</code>是一个<code>(List Atom)</code>吗?</td><td class="middled"><sup>6</sup></td><td class="rightd">在<a href="#nil">第5章第3框</a>里<code>nil</code>看起来扮演着空列表的角色.</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, <code>nil</code>的确是一个<code>(List Atom)</code>.<p><code>nil</code>是一个<code>(List Nat)</code>吗?</p></td><td class="middled"><sup>7</sup></td><td class="rightd">似乎不是这样, 因为<code>nil</code>已经是一个<code>(List Atom)</code>了.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, <code>nil</code>也是一个<code>(List Atom)</code>.<p><code>nil</code>是一个<code>(List (List Atom))</code>吗?</p></td><td class="middled"><sup>8</sup></td><td class="rightd">是的, 因为<code>(List Atom)</code>是一个类型, 所以<code>(List (List Atom))</code>也是一个类型. <code>(List (Pair Nat Atom))</code>怎么样呢?<p>是不是<code>nil</code>可以具有任意以上类型之一呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.</td><td class="middled"><sup>9</sup></td><td class="rightd">这意味着<code>nil</code>也是一个<pre><code>(List 'potato)</code></pre>咯?</td></tr></table><table class="dialogue"><tr><td class="leftd">不, 并非如此, 因为<code>'potato</code>不是一个类型.</td><td class="middled"><sup>10</sup></td><td class="rightd">是不是这和<a href="#not-a-type">第1章第52框</a>中<pre><code>(Pair 'olive 'oil)</code></pre>并非类型出于相同的原因?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<p>之所以<code>(List 'potato)</code>不是一个类型, 是因为<code>'potato</code>是一个<code>Atom</code>, 而不是一个类型.</p></td><td class="middled"><sup>11</sup></td><td class="rightd">好吧. 这意味着如果<math><mi>E</mi></math>是一个类型, 那么<code>(List <math><mi>E</mi></math>)</code>是一个类型, 对吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">并且, 如果<code>(List <math><mi>E</mi></math>)</code>是一个类型, 那么<code>nil</code>是一个<code>(List <math><mi>E</mi></math>)</code>.</td><td class="middled"><sup>12</sup></td><td class="rightd">好吧.<p><code>nil</code>是一个构造子吗?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">是的, <code>nil</code>的确是一个构造子.<p>猜猜<code>(List <math><mi>E</mi></math>)</code>还有什么其他的构造子.</p></td><td class="middled"><sup>13</sup></td><td class="rightd">根据<code>expectations</code>, <code>::</code>是另一个构造子.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>::</code>和<code>cons</code>有什么区别?<p>构造子<code>::</code>构建一个<code>List</code>...</p><div class="comment"><b>注记.</b> 出于历史原因, <code>::</code>亦读作<q>cons</q>或者<q>list-cons</q>.</div></td><td class="middled"><sup>14</sup></td><td class="rightd">..., 但是构造子<code>cons</code>构建一个<code>Pair</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">可以有序对的列表, 也可以有列表的序对.<p>何时<code>(:: <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>)</code>是一个<code>(List <math><mi>E</mi></math>)</code>?</p><div class="comment"><b>注记.</b> <math><mi>e</mi></math>的复数形式是<math><mi mathvariant="italic">es</mi></math>, 读作<q>ease</q>. 使用<math><mi mathvariant="italic">es</mi></math>是因为一个列表的剩余部分可以具有任意数目的元素.</div></td><td class="middled"><sup>15</sup></td><td class="rightd">嗯, <math><mi mathvariant="italic">es</mi></math>必须要是一个<code>(List <math><mi>E</mi></math>)</code>. <math><mi mathvariant="italic">es</mi></math>可以是<code>nil</code>, 而<code>nil</code>是一个<code>(List <math><mi>E</mi></math>)</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><math><mi>e</mi></math>可以是任意的东西吗?</td><td class="middled"><sup>16</sup></td><td class="rightd">当然可以!</td></tr></table><table class="dialogue"><tr><td class="leftd">当然不行! 再试试.</td><td class="middled"><sup>17</sup></td><td class="rightd">我猜一下: <math><mi>e</mi></math>必须要是一个<math><mi>E</mi></math>, 不然的话<math><mi>E</mi></math>还没有任何用处.</td></tr></table><table class="dialogue"><tr><td class="leftd">正确的答案, 错误的原因.<p>之所以<math><mi>e</mi></math>必须要是一个<math><mi>E</mi></math>, 是因为为了能够使用<code>(List <math><mi>E</mi></math>)</code>的一个消去子, 我们需要保证这样的列表的每个元素都是一个<math><mi>E</mi></math>.</p><p>请将<code>rugbrød</code>定义为丹麦黑麦面包的成分.</p><div class="comment"><b>注记.</b> 读作[ˈʁuˌb̥ʁœðˀ], 如果还是不懂, 就去问问丹麦人.</div><div class="tcomment"><b>译注.</b> rugbrød, 丹麦语, 意思是黑麦面包.</div></td><td class="middled"><sup>18</sup></td><td class="rightd">那么成分有什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><em>rugbrød</em>里的成分有:<ul><li>全黑麦面粉,</li><li>黑麦籽粒, 浸泡直至变软,</li><li>纯净水,</li><li>活跃的酵种, 以及</li><li>盐.</li></ul></td><td class="middled"><sup>19</sup></td><td class="rightd"><code>rugbrød</code>应该具有什么类型?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(List Atom)</code>, 因为每个成分都是一个<code>Atom</code>.</td><td class="middled"><sup>20</sup></td><td class="rightd">好的, 以下就是了.<pre><code>(claim rugbrød
  (List Atom))
(define rugbrød
  (:: 'rye-flour
    (:: 'rye-kernels
      (:: 'water
        (:: 'sourdough
          (:: 'salt nil))))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">非常好.</td><td class="middled"><sup>21</sup></td><td class="rightd">是的, <code>rugbrød</code>非常美味! 尽管如此, 顶上还需要加点什么才好.</td></tr></table><table class="dialogue"><tr><td class="leftd">让我们回到正题.<p><code>rugbrød</code>和<code>5</code>有什么不同之处?</p></td><td class="middled"><sup>22</sup></td><td class="rightd">似乎看起来它们就没有相同的地方. <code>5</code>由<code>add1</code>和<code>zero</code>构成. 而且, <code>5</code>也不好吃.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>rugbrød</code>里包含多少种成分呢?</td><td class="middled"><sup>23</sup></td><td class="rightd">五种.</td></tr></table><table class="dialogue"><tr><td class="leftd">不仅只需要五种成分, <code>rugbrød</code>甚至不需要揉面.</td><td class="middled"><sup>24</sup></td><td class="rightd">那么, <code>::</code>是不是和<code>add1</code>有什么关系?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>::</code>使得一个列表更大, 而<code>add1</code>使得一个<code>Nat</code>更大.<p><code>nil</code>是不是和<code>zero</code>有什么关系?</p></td><td class="middled"><sup>25</sup></td><td class="rightd"><code>nil</code>是最小的列表, 而<code>zero</code>是最小的自然数.<p>列表的消去子和<code>Nat</code>的消去子是不是看起来差不多?</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>nil</code>之律</div><p><code>nil</code>是一个<code>(List <math><mi>E</mi></math>)</code>, 不论类型<math><mi>E</mi></math>为何.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>::</code>之律</div><p>如果<math><mi>e</mi></math>是一个<math><mi>E</mi></math>而<math><mi mathvariant="italic">es</mi></math>是一个<code>(List <math><mi>E</mi></math>)</code>, 那么<code>(:: <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>)</code>是一个<code>(List <math><mi>E</mi></math>)</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<pre><code>(rec-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>的类型是什么?</td><td class="middled"><sup>26</sup></td><td class="rightd">当<ul><li><math><mi mathvariant="italic">target</mi></math>是一个<code>Nat</code>,</li><li><math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, 且</li><li><math><mi mathvariant="italic">step</mi></math>是一个<code>(→ Nat <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></li></ul>时, <code>rec-Nat</code>表达式是一个<math><mi>X</mi></math>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(List <math><mi>E</mi></math>)</code>的消去子写作<pre><code>(rec-List <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>并且当<ul><li><math><mi mathvariant="italic">target</mi></math>是一个<code>(List <math><mi>E</mi></math>)</code>,</li><li><math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, 且</li><li><math><mi mathvariant="italic">step</mi></math>是一个<code>(→ <math><mi>E</mi></math> (List <math><mi>E</mi></math>) <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></li></ul>时, 其是一个<math><mi>X</mi></math>.<p>这和<code>rec-Nat</code>有什么不同之处?</p></td><td class="middled"><sup>27</sup></td><td class="rightd"><code>rec-List</code>的<math><mi mathvariant="italic">step</mi></math>比<code>rec-Nat</code>的<math><mi mathvariant="italic">step</mi></math>多一个参数&mdash;&mdash;其接受<math><mi>e</mi></math>, 列表里的一个元素.</td></tr></table><table class="dialogue"><tr><td class="leftd">说的很好!<p>在这两种情况下, step都接受相应构造子的每个参数, 并且也接受对于更小的值的递归性消去.</p></td><td class="middled"><sup>28</sup></td><td class="rightd">消去子暴露了值中的信息.</td></tr></table><table class="dialogue"><tr><td class="leftd">base也暴露了不少关于一个<code>rec-List</code>的结果的信息. 能给出两个以<code>0</code>为base的<code>rec-List</code>用例吗?</td><td class="middled"><sup>29</sup></td><td class="rightd">一个是找出列表的长度, 另一个是找出一个<code>(List Nat)</code>中的所有<code>Nat</code>之和.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确是两个不错的例子.<pre class="dashed"><code>(claim step-<span style="border: 2px solid white; display: inline-block;">     </span>
  (→ Atom (List Atom) Nat
    Nat))
(define step-<span style="border: 2px solid white; display: inline-block;">     </span>
  (λ (<span style="color: grey;">e</span> <span style="color: grey;">es</span> n)
    (add1 n)))</code></pre>以此定义,<pre><code>(rec-List nil
  0
  step-<span style="border: 2px solid white; display: inline-block;">     </span>)</code></pre>之值为何?</td><td class="middled"><sup>30</sup></td><td class="rightd">必然是<code>0</code>, 因为<code>0</code>是base, 而base之值必然是<code>rec-List</code>对于<code>nil</code>之值.</td></tr></table><table class="dialogue"><tr><td class="leftd">是的.<p>一个<code>kartoffelmad</code>是带有<code>toppings</code>和<code>condiments</code>的<code>rugbrød</code>.<pre><code>(claim toppings
  (List Atom))
(define toppings
  (:: 'potato
    (:: 'butter nil)))
(claim condiments
  (List Atom))
(define condiments
  (:: 'chives
    (:: 'mayonnaise nil)))</code></pre></p><div class="comment"><b>注记.</b> butter和mayonnaise也可以换成你喜欢的非乳制品替代物.</div></td><td class="middled"><sup>31</sup></td><td class="rightd">听起来非常地<em>美味(lækkert)</em>!</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-List</code>之律</div><p>如果<math><mi mathvariant="italic">target</mi></math>是一个<code>(List <math><mi>E</mi></math>)</code>, <math><mi mathvariant="italic">base</mi></math>是一个<math><mi>X</mi></math>, 而<math><mi mathvariant="italic">step</mi></math>是一个<pre><code>(→ <math><mi>E</mi></math> (List <math><mi>E</mi></math>) <math><mi>X</mi></math> <math><mi>X</mi></math>)</code></pre>那么<pre><code>(rec-List <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-List</code>之第一诫</div><p>如果<pre><code>(rec-List nil
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么它和<math><mi mathvariant="italic">base</mi></math>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>rec-List</code>之第二诫</div><p>如果<pre><code>(rec-List (:: <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>)
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 那么它和<pre><code>(<math><mi mathvariant="italic">step</mi></math> <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>
  (rec-List <math><mi mathvariant="italic">es</mi></math>
    <math><mi mathvariant="italic">base</mi></math>
    <math><mi mathvariant="italic">step</mi></math>))</code></pre>是相同的<math><mi>X</mi></math>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">的确美味!<pre><code>(rec-List condiments
  0
  step-<span style="border: 2px solid white; display: inline-block;">     </span>)</code></pre>的值是什么?</td><td class="middled"><sup>32</sup></td><td class="rightd">让我们看看.<ol><li>| <pre style="display: inline-block"><code>(rec-List (:: 'chives
            (:: 'mayonnaise
              nil))
  0
  step-<span style="border: 2px solid white; display: inline-block;">     </span>)</code></pre></li><li>| <pre style="display: inline-block"><code>(step-<span style="border: 2px solid white; display: inline-block;">     </span>
  'chives
  (:: 'mayonnaise nil)
  (rec-List (:: 'mayonnaise
              nil)
    0
    step-<span style="border: 2px solid white; display: inline-block;">     </span>))</code></pre></li><li>| <pre style="display: inline-block"><code>(add1
  (rec-List (:: 'mayonnaise
              nil)
    0
    step-<span style="border: 2px solid white; display: inline-block;">     </span>))</code></pre></li></ol></td></tr></table><table class="dialogue"><tr><td class="leftd">规范形式是什么? 不要对于省略中间的表达式保有负担.</td><td class="middled"><sup>33</sup></td><td class="rightd">规范形式为<pre><code>(add1
  (add1 zero))</code></pre>或者更为人知的版本是<code>2</code>.</td></tr></table><table class="dialogue" id="step-length-def"><tr><td class="leftd">这个<code>rec-List</code>表达式将<code>condiments</code>中的每个<code>::</code>都替换为了<code>add1</code>, 而<code>nil</code>则被替换为了<code>0</code>.<p>方框里填什么名字好呢?</p></td><td class="middled"><sup>34</sup></td><td class="rightd"><code>length</code>似乎比较恰当.<pre class="dashed"><code>(claim step-length
  (→ Atom (List Atom) Nat
    Nat))
(define step-length
  (λ (<span style="color: grey;">e</span> <span style="color: grey;">es</span> length<sub>es</sub>)
    (add1 length<sub>es</sub>)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">那么以下必然是<code>length</code>的定义了.<pre class="dashed"><code>(claim length
  (→ (List Atom)
    Nat))
(define length
  (λ (es)
    (rec-List es
      0
      step-length)))</code></pre></td><td class="middled"><sup>35</sup></td><td class="rightd">但是<pre><code>(:: 17
  (:: 24
    (:: 13 nil)))</code></pre>的长度是多少?</td></tr></table><table class="dialogue"><tr><td class="leftd">那简单, 只需将<code>Atom</code>替换以<code>Nat</code>.<pre class="dashed"><code>(claim step-length
  (→ Nat (List Nat) Nat
    Nat))
(define step-length
  (λ (<span style="color: grey;">e</span> <span style="color: grey;">es</span> length<sub>es</sub>)
    (add1 length<sub>es</sub>)))</code></pre></td><td class="middled"><sup>36</sup></td><td class="rightd">而以下是对于<code>Nat</code>列表而言的<code>length</code>.<pre class="dashed"><code>(claim length
  (→ (List Nat)
    Nat))
(define length
  (λ (es)
    (rec-List es
      0
      step-length)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">列表可以包含任意类型的元素, 不仅是<code>Atom</code>和<code>Nat</code>.<p>什么可以用来作成一个对于所有类型成立的<code>step-length</code>版本呢?</p></td><td class="middled"><sup>37</sup></td><td class="rightd">It's as easy as <code>Π</code>.<pre><code>(claim length
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (List E)
      Nat)))</code></pre><div class="tcomment"><b>译注.</b> 这里是显然的一语双关.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这个<code>claim</code>需要一个step.<pre><code>(claim step-length
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ E (List E) Nat
      Nat)))</code></pre></td><td class="middled"><sup>38</sup></td><td class="rightd">每个步骤 (step) 时, 长度通过<code>add1</code>增长.<pre><code>(define step-length
  (λ (<span style="color: grey;">E</span>)
    (λ (<span style="color: grey;">e</span> <span style="color: grey;">es</span> length<sub>es</sub>)
      (add1 length<sub>es</sub>))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">这个定义使用了和<a href="#step-*">第3章第66框</a>中的<code>step-*</code>相同的技巧, 以将<code>step-length</code>应用于<code><span style="color: grey;">E</span></code>.<p>现在定义<code>length</code>.</p></td><td class="middled"><sup>39</sup></td><td class="rightd">将<code><span style="color: grey;">E</span></code>传递给<code>step-length</code>将导致其(结果)取三个参数.<pre><code>(define length
  (λ (E)
    (λ (es)
      (rec-List es
        0
        (step-length E)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>step-length</code>中的<code><span style="color: grey;">e</span></code>是黯淡的?</td><td class="middled"><sup>40</sup></td><td class="rightd">因为列表中的特定元素在计算列表长度时无需使用.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(length Atom)</code>的值是什么?</td><td class="middled"><sup>41</sup></td><td class="rightd">其为<pre><code>(λ (es)
  (rec-List es
    0
    (step-length Atom)))</code></pre>这是将内层<code>λ</code>表达式的体中的每个<code>E</code>替换以<code>Atom</code>得到的.</td></tr></table><table class="dialogue"><tr><td class="leftd">请定义<code>length</code>的一个特化版本, 其找出一个<code>(List Atom)</code>的元素数目.</td><td class="middled"><sup>42</sup></td><td class="rightd">这会使用和<a href="#twin-Atom">第4章第54框</a>中的<code>twin-Atom</code>定义相同的技巧.<pre><code>(claim length-Atom
  (→ (List Atom)
    Nat))
(define length-Atom
  (length Atom))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">这是一个很实用的技巧.<p>现在是时候将一片面包, <code>toppings</code>以及<code>condiments</code>组装为一个美味的<em>kartoffelmad</em>.</p><p>请定义一个函数, 其合并两个列表.</p></td><td class="middled"><sup>43</sup></td><td class="rightd">这个定义的类型应该是什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">我们可以将一个<code>(List Nat)</code>和一个<code>(List (Pair Nat Nat))</code>合并吗?</td><td class="middled"><sup>44</sup></td><td class="rightd">不能.<p>一个列表中的所有元素都必须具有相同的类型.</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">列表的元素之类型</div><p>一个列表中的所有元素都必须具有相同的类型.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">只要两个列表包含相同的元素类型, 它们就可以被合并, 不论这个类型是什么.<p>这是否暗示了<code>append</code>定义中的类型呢?</p></td><td class="middled"><sup>45</sup></td><td class="rightd">其类型必然是一个<code>Π</code>表达式.<pre class="dashed"><code>(claim append
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    <span style="border: 2px solid white; display: inline-block;">          </span>))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p>剩下来的参数应该是什么呢?</p></td><td class="middled"><sup>46</sup></td><td class="rightd">这里必须有两个<code>(List E)</code>参数. 而且, 结果应该也是一个<code>(List E)</code>. 据此, <code>append</code>必然是一个<code>λ</code>表达式.</td></tr></table><table class="dialogue"><tr><td class="leftd">以下是claim, 现在请开始定义.<pre><code>(claim append
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (List E) (List E)
      (List E))))</code></pre></td><td class="middled"><sup>47</sup></td><td class="rightd">它应该是一个<code>λ</code>表达式, 但是其体仍然成谜.<pre class="dashed"><code>(define append
  (λ (E)
    (λ (start end)
      <span style="border: 2px solid white; display: inline-block;">               </span>)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">方框里应该是什么呢?</td><td class="middled"><sup>48</sup></td><td class="rightd">应该是某种<code>rec-List</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(append Atom
  nil
  (:: 'salt
    (:: 'pepper nil)))</code></pre>的值是什么?</td><td class="middled"><sup>49</sup></td><td class="rightd">显然应该是<pre><code>(:: 'salt
  (:: 'pepper nil))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(append Atom
  (:: 'cucumber
    (:: 'tomato nil))
  (:: 'rye-bread nil))</code></pre>的规范形式又应该是什么呢?</td><td class="middled"><sup>50</sup></td><td class="rightd">那必然是<pre><code>(:: 'cucumber
  (:: 'tomato
    (:: 'rye-bread nil)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(append E nil end)</code>的值应该是<code>end</code>的值. 因此, <code>append</code>的最后一个参数<code>end</code>应该是base.<div class="tcomment"><b>译注.</b> <code>(append E nil end)</code>中的<code>E</code>和<code>end</code>是元变量.</div></td><td class="middled"><sup>51</sup></td><td class="rightd">step呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">step的类型由<code>rec-List</code>之律确定. 其应该能够对于任意的元素类型成立.</td><td class="middled"><sup>52</sup></td><td class="rightd">比如说这个?<pre><code>(claim step-append
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ E (List E) (List E)
      (List E))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">以之前的框为例, 填充<code>step-append</code>的剩余部分.<pre class="dashed"><code>(define step-append
  (λ (E)
    (λ (e es append<sub>es</sub>)
      <span style="border: 2px solid white; display: inline-block;">               </span>)))
(define append
  (λ (E)
    (λ (start end)
      (rec-List start
        end
        (step-append E)))))</code></pre><div class="comment"><b>注记.</b> 当列表包含的元素类型为<code>E</code>时, 表达式<code>(step-append E)</code>应该是<code>append</code>的一个step. 请注意Currying.</div></td><td class="middled"><sup>53</sup></td><td class="rightd">如果<code>append<sub>es</sub></code>是<pre><code>nil</code></pre>那么<code>step-append</code>应该产生<pre><code>(:: 'rye-bread nil)</code></pre>如果<code>append<sub>es</sub></code>是<pre><code>(:: 'rye-bread nil)</code></pre>那么<code>step-append</code>应该产生<pre><code>(:: 'tomato
  (:: 'rye-bread nil))</code></pre>最后, 如果<code>append<sub>es</sub></code>是<pre><code>(:: 'tomato
  (:: 'rye-bread nil))</code></pre>那么<code>step-append</code>应该产生<pre><code>(:: 'cucumber
  (:: 'tomato
    (:: 'rye-bread nil)))</code></pre><div class="tcomment"><b>译注.</b> 这里的第一段我不是很理解, 因为你并不会在运行<code>append</code>过程中把参数<code>end</code>拆开.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这是很好的推理.<p>所以正确的定义是什么?</p></td><td class="middled"><sup>54</sup></td><td class="rightd">现在<code>append</code>就不应该用虚线框住了.<pre><code>(define step-append
  (λ (E)
    (λ (e <span style="color: grey;">es</span> append<sub>es</sub>)
      (:: e append<sub>es</sub>))))
(define append
  (λ (E)
    (λ (start end)
      (rec-List start
        end
        (step-append E)))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>append</code>的定义很像<code>+</code>.</td><td class="middled"><sup>55</sup></td><td class="rightd">是不是有一个<code>iter-List</code>, 就像是<code>iter-Nat</code>, 而我们可以用它来定义<code>append</code>?<div class="tcomment"><b>译注.</b> 我想是不太行的, 因为按照类比, <code>iter-List</code>的step不能知道参数<code>e</code>会是什么.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">没有什么能够阻止我们定义<code>iter-List</code>, 但是又没有必要, 因为<code>iter-List</code>能做的, <code>rec-List</code>也能做, 就像<code>iter-Nat</code>和<code>which-Nat</code>能做的, <code>rec-Nat</code>也能做.</td><td class="middled"><sup>56</sup></td><td class="rightd">好的, 这里我们就用更富表达力的消去子吧.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上还可以用另外的方式定义<code>append</code>, 其将<code>::</code>替换成别的什么东西.</td><td class="middled"><sup>57</sup></td><td class="rightd">真的能行吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">当然可以. 除了使用<code>::</code>以将第一个列表的元素<q>cons</q>到结果的开头, 也可以使用<code>snoc</code>将第二个列表的元素加到结果的末尾.<p>例如,<pre><code>(snoc Atom toppings 'rye-bread)</code></pre>的值为<pre><code>(:: 'potato
  (:: 'butter
    (:: 'rye-bread nil)))</code></pre></p><p><code>snoc</code>的类型是什么?</p><div class="comment"><b>注记.</b> 感谢David C. Dickson (1947-).</div></td><td class="middled"><sup>58</sup></td><td class="rightd"><code>snoc</code>的类型是<pre><code>(claim snoc
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (List E) E
      (List E))))</code></pre>step必须要做什么呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个step必须要将列表的当前元素<q>cons</q>到结果上.</td><td class="middled"><sup>59</sup></td><td class="rightd">啊, 所以说这就像<code>step-append</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">现在请定义<code>snoc</code>.</td><td class="middled"><sup>60</sup></td><td class="rightd">以下是<code>snoc</code>.<pre><code>(define snoc
  (λ (E)
    (λ (start e)
      (rec-List start
        (:: e nil)
        (step-append E)))))</code></pre><div class="tcomment"><b>译注.</b> 说白了, 其实就是复用<code>append</code>.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">干得好.<p>现在请定义<code>concat</code>, 其行为与<code>append</code>类似, 但是在其step中使用了<code>snoc</code>.<pre><code>(claim concat
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (List E) (List E)
      (List E))))</code></pre><code>concat</code>的类型和<code>append</code>的类型相同, 因为它们做相同的事情.</p></td><td class="middled"><sup>61</sup></td><td class="rightd">除了使用<code>snoc</code>而不是<code>List</code>的<q>cons</q><code>::</code>, <code>concat</code>必须要消去的是其第二个(作为参数的)列表.<pre><code>(claim step-concat
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ E (List E) (List E)
      (List E))))
(define step-concat
  (λ (E)
    (λ (e <span style="color: grey;">es</span> concat<sub>es</sub>)
      (snoc E concat<sub>es</sub> e))))
(define concat
  (λ (E)
    (λ (start end)
      (rec-List end
        start
        (step-concat E)))))</code></pre><div class="tcomment"><b>译注.</b> 不幸的是, <code>concat</code>的定义是错误的, 它实际上相当于第一个列表和反转了的第二个列表合并. 没有什么特别好的补救措施, 因为<code>snoc</code>和<code>concat</code>本身对于<code>List</code>就不那么自然. 尽管如此, 你的确可以使用之后的<code>reverse</code>来反转<code>end</code>以得到一个更加别扭但是还算正确的定义.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">一个列表也可以通过使用<code>snoc</code>得以反转.<p><code>reverse</code>的类型应该是什么?</p></td><td class="middled"><sup>62</sup></td><td class="rightd"><code>reverse</code>接受单独一个列表作为参数.<pre><code>(claim reverse
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (List E)
      (List E))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">每一步骤 (step) 该做什么呢?</td><td class="middled"><sup>63</sup></td><td class="rightd">对于每个步骤, <code>e</code>应该通过<code>snoc</code>添加到反转了的<code>es</code>的末尾.<pre><code>(claim step-reverse
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ E (List E) (List E)
      (List E))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">现在请定义<code>step-reverse</code>和<code>reverse</code>.</td><td class="middled"><sup>64</sup></td><td class="rightd">以下就是了.<pre><code>(define step-reverse
  (λ (E)
    (λ (e <span style="color: grey;">es</span> reverse<sub>es</sub>)
      (snoc E reverse<sub>es</sub> e))))
(define reverse
  (λ (E)
    (λ (es)
      (rec-List es
        nil
        (step-reverse E)))))</code></pre><div class="comment"><b>注记.</b> 在使用Pie语言时, 必须要将这里的<code>nil</code>写成<code>(the (List E) nil)</code>才行.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">现在是时候来点<em>lækkert</em>的东西了.<pre><code>(claim kartoffelmad
  (List Atom))
(define kartoffelmad
  (append Atom
    (concat Atom
      condiments toppings)
    (reverse Atom
      (:: 'plate
        (:: 'rye-bread nil)))))</code></pre><code>kartoffelmad</code>的规范形式是什么?</td><td class="middled"><sup>65</sup></td><td class="rightd">即<pre><code>(:: 'chives
  (:: 'mayonnaise
    (:: 'potato
      (:: 'butter
        (:: 'rye-bread
          (:: 'plate nil))))))</code></pre><div class="tcomment"><b>译注.</b> 原文将<code>condiments</code>和<code>toppings</code>的顺序弄反了, 翻译是按照经过勘误的版本来的.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">我们问的是规范形式, 而非值, 这是很好的. 否则的话, 你原本可能就要在吃的时候自己组转除了<code>'chives</code>的一切了.</td><td class="middled"><sup>66</sup></td><td class="rightd">反转列表是令人发饿的工作.</td></tr></table><h2>第6章 究竟到底是多少?</h2><table class="dialogue"><tr><td class="leftd">...</td><td class="middled"><sup>1</sup></td><td class="rightd">在吃了那么多三明治之后, 吃点<code>Π</code>也是好的.</td></tr></table><table class="dialogue"><tr><td class="leftd">我们很高兴你问了...</td><td class="middled"><sup>2</sup></td><td class="rightd">我很擅长预测你想要我提出的问题.</td></tr></table><table class="dialogue"><tr><td class="leftd">当然了, 让我们开始吧.<p>让我们定义一个函数<code>first</code>, 其找出<em>任意</em><code>List</code>的第一个元素.</p></td><td class="middled"><sup>3</sup></td><td class="rightd">那不是很简单吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 这是不可能哒!</td><td class="middled"><sup>4</sup></td><td class="rightd">为什么不可能?</td></tr></table><table class="dialogue"><tr><td class="leftd">之所以不可能, 是因为<code>nil</code>没有第一个元素...</td><td class="middled"><sup>5</sup></td><td class="rightd">...因而<code>first</code>不是完全的.</td></tr></table><table class="dialogue"><tr><td class="leftd">写一个<code>last</code>函数怎么样, 它不是找出第一个元素, 而是找出一个<code>List</code>的最后一个元素?</td><td class="middled"><sup>6</sup></td><td class="rightd">函数<code>last</code>也不是完全的, 因为<code>nil</code>也没有最后一个元素.</td></tr></table><table class="dialogue"><tr><td class="leftd">为了能够写下一个完全函数<code>first</code>, 我们必须使用一个比<code>List</code>更加特化 (specific) 的类型. 这样一个更加特化的类型被称为<code>Vec</code>, 其是<q>向量 (vector)</q>的缩写, 但是它真的只是带有长度的列表而已.<p>当<math><mi>E</mi></math>是一个类型而<math><mi>k</mi></math>是一个<code>Nat</code>时, 表达式<code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code>是一个类型. 这个<code>Nat</code>给出了列表的长度.</p><p><code>(Vec Atom 3)</code>是一个类型吗?</p><div class="comment"><b>注记.</b> <code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code>读作<q>长度为<math><mi>k</mi></math>的<math><mi>E</mi></math>的列表</q>或者更简单的<q><math><mi>E</mi></math>的列表, 长度为<math><mi>k</mi></math></q>.</div></td><td class="middled"><sup>7</sup></td><td class="rightd">类型可以包含不是类型的表达式吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">正如类型可以是对于某个表达式求值的结果一样 (见<a href="#type-eval">第1章第55框</a>), 某些类型可以包含其他并非类型的表达式.<div class="tcomment"><b>译注.</b> 意味不明的类比.</div></td><td class="middled"><sup>8</sup></td><td class="rightd">那么, 之所以<code>(Vec Atom 3)</code>是一个类型, 是因为<code>Atom</code>是一个类型而<code>3</code>显然是一个<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(Vec
  (cdr
    (cons 'pie
      (List (cdr (cons Atom Nat)))))
  (+ 2 1))</code></pre>是一个类型吗?</td><td class="middled"><sup>9</sup></td><td class="rightd">必然是的, 因为<pre><code>(cdr
  (cons 'pie
    (List (cdr (cons Atom Nat)))))</code></pre>和<pre><code>(List Nat)</code></pre>是相同的类型, 且<pre><code>(+ 2 1)</code></pre>和<pre><code>3</code></pre>是相同的<code>Nat</code>. 这意味着该表达式和<pre><code>(Vec (List Nat) 3)</code></pre>是相同的, 而其 (指后者) 显然是一个类型.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(Vec <math><mi>E</mi></math> zero)</code>唯一的构造子是<code>vecnil</code>.</td><td class="middled"><sup>10</sup></td><td class="rightd">这是因为<code>vecnil</code>的长度为<code>zero</code>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">恰是如此.<p><code>vec::</code>是<pre><code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code></pre>唯一的构造子.</p></td><td class="middled"><sup>11</sup></td><td class="rightd">这里的<math><mi>k</mi></math>是什么?</td></tr></table><table class="dialogue" id="vec::"><tr><td class="leftd">这里, <math><mi>k</mi></math>可以是任意的<code>Nat</code>.<p>当<math><mi>e</mi></math>是一个<math><mi>E</mi></math>而<math><mi mathvariant="italic">es</mi></math>是一个<code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code>时, <code>(vec:: <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>)</code>是一个<code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code>.</p></td><td class="middled"><sup>12</sup></td><td class="rightd">如果一个表达式是一个<code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code>那么其值至少拥有一个元素, 因而有可能定义<code>first</code>和<code>last</code>, 是不是这样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">对的.<pre><code>(vec:: 'oyster vecnil)</code></pre>是一个<pre><code>(Vec Atom 1)</code></pre>吗?</td><td class="middled"><sup>13</sup></td><td class="rightd">是的, 因为<pre><code>'oyster</code></pre>是一个<pre><code>Atom</code></pre>而<pre><code>vecnil</code></pre>是一个<pre><code>(Vec Atom zero)</code></pre></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>Vec</code>之律</div><p>如果<math><mi>E</mi></math>是一个类型而<math><mi>k</mi></math>是一个<code>Nat</code>, 那么<code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code>是一个类型.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>vecnil</code>之律</div><p><code>vecnil</code>是一个<code>(Vec <math><mi>E</mi></math> zero)</code>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>vec::</code>之律</div><p>如果<math><mi>e</mi></math>是一个<math><mi>E</mi></math>而<math><mi mathvariant="italic">es</mi></math>是一个<code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code>, 那么<code>(vec:: <math><mi>e</mi></math> <math><mi mathvariant="italic">es</mi></math>)</code>是一个<code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(vec:: 'crimini
  (vec:: 'shiitake vecnil))</code></pre>是一个<pre><code>(Vec Atom 3)</code></pre>吗?</td><td class="middled"><sup>14</sup></td><td class="rightd">不是, 因为其并非恰有三个原子的列表.</td></tr></table><table class="dialogue"><tr><td class="leftd">这和<a href="#vec::">第6章第12框</a>是怎样联系起来的呢?<div class="tcomment"><b>译注.</b> 原文是第11框, 但是译者认为第12框更合理一点.</div></td><td class="middled"><sup>15</sup></td><td class="rightd">之所以其并非<pre><code>(Vec Atom 3)</code></pre>是因为<pre><code>(vec:: 'shiitake vecnil)</code></pre>不是一个<pre><code>(Vec Atom 2)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<pre><code>(vec:: 'shiitake vecnil)</code></pre>不是一个<pre><code>(Vec Atom 2)</code></pre></td><td class="middled"><sup>16</sup></td><td class="rightd">如果它真的是一个<code>(Vec Atom 2)</code>的话, 那么基于<a href="#vec::">第6章第12框</a>中的描述<pre><code>vecnil</code></pre>就会是一个<pre><code>(Vec Atom 1)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么不能是这样呢?</td><td class="middled"><sup>17</sup></td><td class="rightd">因为<pre><code>vecnil</code></pre>是一个<pre><code>(Vec Atom zero)</code></pre>而<code>1</code>和<code>zero</code>不是相同的<code>Nat</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">为什么<code>1</code>和<code>zero</code>不是相同的<code>Nat</code>呢?</td><td class="middled"><sup>18</sup></td><td class="rightd">根据<a href="#Nat-same">第1章第100框</a>的解释, 两个<code>Nat</code>相同, 当其值相同; 而其值相同, 当其均为<code>zero</code>或者均以<code>add1</code>为顶(且<code>add1</code>的参数是相同的<code>Nat</code>).<div class="tcomment"><b>译注.</b> 括号里的内容是译者添加的. 另外, 不仅是第100框, 也有第101框的内容.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">现在可以定义<code>first-of-one</code>了, 其获取一个<code>(Vec <math><mi>E</mi></math> 1)</code>的第一个元素.</td><td class="middled"><sup>19</sup></td><td class="rightd">但是这可能吗? 到目前为止, 我们还没有<code>Vec</code>的消去子.</td></tr></table><table class="dialogue"><tr><td class="leftd">很好的论点. <code>Vec</code>的两个消去子是<code>head</code>和<code>tail</code>.</td><td class="middled"><sup>20</sup></td><td class="rightd"><code>head</code>和<code>tail</code>是什么意思呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">当<pre><code><math><mi mathvariant="italic">es</mi></math></code></pre>是一个<pre><code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code></pre>时,<pre><code>(head <math><mi mathvariant="italic">es</mi></math>)</code></pre>是一个<pre><code><math><mi>E</mi></math></code></pre><math><mi mathvariant="italic">es</mi></math>的值可以具有怎样的形式?</td><td class="middled"><sup>21</sup></td><td class="rightd">它不可能是<code>vecnil</code>, 因为<code>vecnil</code>只有<code>zero</code>个元素. 因此, <math><mi mathvariant="italic">es</mi></math>以<code>vec::</code>为顶.</td></tr></table><table class="dialogue"><tr><td class="leftd">表达式<pre><code>(head
  (vec:: <math><mi>a</mi></math> <math><mi>d</mi></math>))</code></pre>和<math><mi>a</mi></math>是相同的<math><mi>E</mi></math>.</td><td class="middled"><sup>22</sup></td><td class="rightd"><code>tail</code>怎么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">当<pre><code><math><mi mathvariant="italic">es</mi></math></code></pre>是一个<pre><code>(Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))</code></pre>时,<pre><code>(tail <math><mi mathvariant="italic">es</mi></math>)</code></pre>是一个<pre><code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code></pre></td><td class="middled"><sup>23</sup></td><td class="rightd"><math><mi mathvariant="italic">es</mi></math>以<code>vec::</code>为顶.<pre><code>(tail
  (vec:: <math><mi>a</mi></math> <math><mi>d</mi></math>))</code></pre>和<pre><code><math><mi>d</mi></math></code></pre>是相同的<pre><code><math><mi>E</mi></math></code></pre>吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不是, 但<pre><code>(tail
  (vec:: <math><mi>a</mi></math> <math><mi>d</mi></math>))</code></pre>和<pre><code><math><mi>d</mi></math></code></pre>是相同的<pre><code>(Vec <math><mi>E</mi></math> <math><mi>k</mi></math>)</code></pre>现在定义<code>first-of-one</code>.</td><td class="middled"><sup>24</sup></td><td class="rightd"><code>first-of-one</code>使用<code>head</code>来找出这仅有的元素.<pre><code>(claim first-of-one
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (Vec E 1)
      E)))
(define first-of-one
  (λ (<span style="color: grey;">E</span>)
    (λ (es)
      (head es))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(first-of-one Atom
  (vec:: 'shiitake vecnil))</code></pre>的值是什么?</td><td class="middled"><sup>25</sup></td><td class="rightd">是<code>'shiitake</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(first-of-one Atom vecnil)</code></pre>的值是什么?</td><td class="middled"><sup>26</sup></td><td class="rightd">这个问题是没有意义的, 因为<pre><code>(first-of-one Atom vecnil)</code></pre>并不由某个类型刻画, 而这又是因为<pre><code>vecnil</code></pre>并非一个<pre><code>(Vec Atom 1)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">完全正确, 这的确是一个毫无意义的问题.<p>现在请定义<code>first-of-two</code>.</p></td><td class="middled"><sup>27</sup></td><td class="rightd">那必然非常类似于<code>first-of-one</code>.<pre><code>(claim first-of-two
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (Vec E 2)
      E)))
(define first-of-two
  (λ (<span style="color: grey;">E</span>)
    (λ (es)
      (head es))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(first-of-two Atom
  (vec:: 'matsutake
    (vec:: 'morel
      (vec:: 'truffle vecnil))))</code></pre>的值是什么?</td><td class="middled"><sup>28</sup></td><td class="rightd">这个列表上的都是蘑菇珍品.<p>然而, 问题本身并不意义, 因为这个蘑菇珍品的列表放了三个蘑菇, 而不是恰有两个蘑菇.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">很好的论点.<p>是时候定义<code>first-of-three</code>了.</p></td><td class="middled"><sup>29</sup></td><td class="rightd">存在<code>first</code>对于任意长度成立吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">不行, 因为长度为<code>zero</code>时并不存在<code>first</code>的元素. 但是, 可以定义<code>first</code>, 使其找出任意<em>至少拥有一个元素</em>的列表的第一个元素.</td><td class="middled"><sup>30</sup></td><td class="rightd">听起来有点困难.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 并不那么困难.<p>事实上, 简单如...</p></td><td class="middled"><sup>31</sup></td><td class="rightd">...<code>Π</code>?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>Π</code>比我们所见更加灵活.</td><td class="middled"><sup>32</sup></td><td class="rightd">什么是更加灵活的<code>Π</code>呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">一人食的蘑菇派. (A mushroom pot pie, for one.)</td><td class="middled"><sup>33</sup></td><td class="rightd">什么是更加灵活的<code>Π</code>表达式呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">以下是<code>first</code>的声明.<pre><code>(claim first
  (Π ((E <math><mi mathvariant="script">U</mi></math>)
      (<math><mi mathvariant="script">l</mi></math> Nat))
    (→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))
      E)))</code></pre>这里有什么新奇之处吗?</td><td class="middled"><sup>34</sup></td><td class="rightd">参数名<code><math><mi mathvariant="script">l</mi></math></code>后面跟着的, 是<code>Nat</code>. 而之前, <code>Π</code>表达式里参数名后面跟着的总是<math><mi mathvariant="script">U</mi></math>.<p><pre><code>(→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))
  E)</code></pre>中的<code>E</code>指的是不论什么作为<code>first</code>的第一个参数的<math><mi mathvariant="script">U</mi></math>. 是不是这意味着<code>(add1 <math><mi mathvariant="script">l</mi></math>)</code>中的<code><math><mi mathvariant="script">l</mi></math></code>指的是不论什么作为<code>first</code>的第二个参数的<code>Nat</code>呢?</p></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>Π</code>之律</div><p>表达式<pre><code>(Π ((<math><mi>y</mi></math> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre>是一个类型, 当<math><mi>Y</mi></math>是一个类型, 且若<math><mi>y</mi></math>是一个<math><mi>Y</mi></math>, <math><mi>X</mi></math>是一个类型.</p><div class="tcomment"><b>译注.</b> 虽然没有明说, 但是<math><mi>X</mi></math>中的<math><mi>y</mi></math>是被绑定的.</div></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">完全正确. <code>(add1 <math><mi mathvariant="script">l</mi></math>)</code>保证了作为<code>first</code>的第三个参数的列表至少拥有一个元素.<p>现在请定义<code>first</code>.</p></td><td class="middled"><sup>35</sup></td><td class="rightd">以下就是了.<pre><code>(define first
  (λ (<span style="color: grey;">E</span> <span style="color: grey;"><math><mi mathvariant="script">l</mi></math></span>)
    (λ (es)
      (head es))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(first Atom 3
  (vec:: 'chicken-of-the-woods
    (vec:: 'chantrelle
      (vec:: 'lions-mane
        (vec:: 'puffball vecnil)))))</code></pre>的值是什么?</td><td class="middled"><sup>36</sup></td><td class="rightd">是<code>'chicken-of-the-woods</code>.<p>但是, 为什么元素的数目是<pre><code>(add1 <math><mi mathvariant="script">l</mi></math>)</code></pre>而非仅仅是<pre><code><math><mi mathvariant="script">l</mi></math></code></pre>呢?</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>vecnil</code>中不能找到第一个元素, 因其只有<code>zero</code>个元素.<p>不论<code><math><mi mathvariant="script">l</mi></math></code>如何, <code>(add1 <math><mi mathvariant="script">l</mi></math>)</code>和<code>zero</code>永远不可能是相同的<code>Nat</code>, 于是<code>vecnil</code>不是一个<code>(Vec E (add1 <math><mi mathvariant="script">l</mi></math>))</code>.</p></td><td class="middled"><sup>37</sup></td><td class="rightd">我们通过使用更加特化的类型以排除不想要的(实际)参数, 这避免了试图定义一个并非完全的函数.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">使用更加特化的类型</div><p>通过使用更加特化的类型以排除不想要的参数来使得函数变成完全的.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">相同的定义本可写成两个嵌套的<code>Π</code>表达式的形式.<pre class="dashed"><code>(claim first
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (Π ((<math><mi mathvariant="script">l</mi></math> Nat))
      (→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))
        E))))
(define first
  (λ (<span style="color: grey;">E</span>)
    (λ (<span style="color: grey;"><math><mi mathvariant="script">l</mi></math></span>)
      (λ (es)
        (head es)))))</code></pre>为什么这会是相同的定义?</td><td class="middled"><sup>38</sup></td><td class="rightd">答案是, 因为具有多个参数名的<code>Π</code>表达式不过就是嵌套的单参数名<code>Π</code>表达式的简略写法而已.</td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, 这个定义本也可以写成三个嵌套的<code>Π</code>表达式的形式.<pre class="dashed"><code>(claim first
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (Π ((<math><mi mathvariant="script">l</mi></math> Nat))
      (Π ((<span style="color: grey;">es</span> (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))))
        E))))
(define first
  (λ (<span style="color: grey;">E</span>)
    (λ (<span style="color: grey;"><math><mi mathvariant="script">l</mi></math></span>)
      (λ (es)
        (head es)))))</code></pre>为什么<em>这</em>也是相同的定义?</td><td class="middled"><sup>39</sup></td><td class="rightd">真的是相同的定义吗?<p>前一个定义有<code>→</code>, 但这个定义没有.</p></td></tr></table><table class="dialogue"><tr><td class="leftd">实际上, <code>→</code>是当参数名不在<code>Π</code>表达式的体中出现时的对于<code>Π</code>表达式的一种简略写法.</td><td class="middled"><sup>40</sup></td><td class="rightd">啊, 好吧.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>→</code>和<code>Π</code></div><p>类型<pre><code>(→ <math><mi>Y</mi></math> <math><mi>X</mi></math>)</code></pre>是对于<pre><code>(Π ((<span style="color: grey;"><math><mi>y</mi></math></span> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre>的简略写法, 当<span style="color: grey;"><math><mi>y</mi></math></span>在<math><mi>X</mi></math>中没有被用到时.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>λ</code>之终律</div><p>若当<math><mi>y</mi></math>是一个<math><mi>Y</mi></math>时<math><mi>x</mi></math>是一个<math><mi>X</mi></math>, 那么<pre><code>(λ (<math><mi>y</mi></math>) <math><mi>x</mi></math>)</code></pre>是一个<pre><code>(Π ((<math><mi>y</mi></math> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre></p><div class="tcomment"><b>译注.</b> 虽然没有显式写出, 但是这里的<math><mi>x</mi></math>依赖于<math><mi>y</mi></math>, <math><mi>X</mi></math>也依赖于<math><mi>y</mi></math>. 当然, 实际上这两个<math><mi>y</mi></math>不需要使用相同的名字 (但指的是同一个东西). 多说一句, 虽然这里是<code>λ</code>之终律, 但是本书之中并无<code>λ</code>之始律, 这可能是作者的失误. 不过, 既然律陈述的是定型规则, <code>λ</code>之始律应该说的是还没有<code>Π</code>的情况下<code>λ</code>表达式的类型.</div></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">应用之终律</div><p>如果<math><mi>f</mi></math>是一个<pre><code>(Π ((<math><mi>y</mi></math> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre>而<math><mi>z</mi></math>是一个<math><mi>Y</mi></math>, 那么<pre><code>(<math><mi>f</mi></math> <math><mi>z</mi></math>)</code></pre>是一个<math><mi>X</mi></math>, 其中每个<math><mi>y</mi></math>都已被一致地替换为了<math><mi>z</mi></math>.</p><div class="tcomment"><b>译注.</b> 应用之始律里没有<code>Π</code>, 应用之中律里<code>Π</code>的参数的类型都是<math><mi mathvariant="script">U</mi></math>, 终律放宽了这个限制.</div></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>λ</code>终第一诫</div><p>如果两个<code>λ</code>表达式可以通过一致换名使其成为相同的<pre><code>(Π ((<math><mi>y</mi></math> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre>那么它们就是相同的.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>λ</code>终第二诫</div><p>如果<math><mi>f</mi></math>是一个<pre><code>(Π ((<math><mi>y</mi></math> <math><mi>Y</mi></math>)) <math><mi>X</mi></math>)</code></pre>而<math><mi>y</mi></math>不出现在<math><mi>f</mi></math>中, 那么<math><mi>f</mi></math>和<pre><code>(λ (<math><mi>y</mi></math>) (<math><mi>f</mi></math> <math><mi>y</mi></math>))</code></pre>是相同的.</p><div class="tcomment"><b>译注.</b> 这里的<q>出现</q>应该指的是<q>自由出现</q>.</div></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">类型<pre><code>(Π ((<span style="color: grey;">es</span> (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))))
  E)</code></pre>本可以写成<pre><code>(→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>)) E)</code></pre>因为<code><span style="color: grey;">es</span></code>在<code>E</code>中没有被用到.<p>实际上, 我们本也可以将<code>first</code>的声明写成一个单独的<code>Π</code>表达式而不使用<code>→</code>.</p></td><td class="middled"><sup>41</sup></td><td class="rightd">之前最后一个版本的<code>first</code>也可以写成这样:<pre class="dashed"><code>(claim first
  (Π ((E <math><mi mathvariant="script">U</mi></math>)
      (<math><mi mathvariant="script">l</mi></math> Nat)
      (<span style="color: grey;">es</span> (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))))
    E))
(define first
  (λ (<span style="color: grey;">E</span> <span style="color: grey;">l</span> es)
    (head es)))</code></pre>这是因为嵌套的<code>Π</code>表达式本就可以写成单独一个<code>Π</code>表达式的形式.</td></tr></table><table class="dialogue"><tr><td class="leftd">更加特化的类型使得我们能够定义<code>first</code>, 这是我们自己的类型化版本的<code>head</code>.<p>若是要定义<code>rest</code>, 这是我们自己的版本的<code>tail</code>, 是不是也需要更加特化的类型呢?</p></td><td class="middled"><sup>42</sup></td><td class="rightd">当然如此, 因为<code>(tail vecnil)</code>和<code>(head vecnil)</code>同样地毫无意义.</td></tr></table><table class="dialogue"><tr><td class="leftd">这更特化的类型是什么呢?</td><td class="middled"><sup>43</sup></td><td class="rightd">参数必然以<code>vec::</code>为顶.<p>因为<code>head</code>不是tail的一部分, 因此作为结果的<code>Vec</code>变得更短了.<pre><code>(claim rest
  (Π ((E <math><mi mathvariant="script">U</mi></math>)
      (<math><mi mathvariant="script">l</mi></math> Nat))
    (→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))
      (Vec E <math><mi mathvariant="script">l</mi></math>))))</code></pre></p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>head</code>和<code>tail</code>都是函数, 而所有函数都是完全的. 这意味着它们不可能与<code>List</code>一起使用, 因为<code>List</code>无法排除<code>nil</code>.<p>现在请定义<code>rest</code>.</p></td><td class="middled"><sup>44</sup></td><td class="rightd">以下就是了.<pre><code>(define rest
  (λ (<span style="color: grey;">E</span> <span style="color: grey;">l</span>)
    (λ (es)
      (tail es))))</code></pre></td></tr></table><h2>第7章 完全取决于动机</h2><table class="dialogue" id="peas-type0"><tr><td class="leftd">我们的蘑菇派需要少许豌豆搭配. 是时候定义<code>peas</code>了, 其产生所需数目的豌豆.<p>什么样的类型表达了这种行为呢?</p></td><td class="middled"><sup>1</sup></td><td class="rightd">类型是<pre><code>(→ Nat (List Atom))</code></pre>因为<code>peas</code>能够产生任意数目的豌豆.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>peas</code>到底应该产生多少豌豆呢?</td><td class="middled"><sup>2</sup></td><td class="rightd">看情况咯. (It depends.)</td></tr></table><table class="dialogue"><tr><td class="leftd">依赖于什么呢? (What does it depend on?)</td><td class="middled"><sup>3</sup></td><td class="rightd">其依赖于豌豆所需要的数目, 即参数.</td></tr></table><table class="dialogue"><tr><td class="leftd"><a href="#peas-type0">第7章第1框</a>中的类型<pre><code>(→ Nat (List Atom))</code></pre>不够特化. 它没有表达出<code>peas</code><em>精确地</em>产生了其被索取的豌豆数目.</td><td class="middled"><sup>4</sup></td><td class="rightd">豌豆的数目是<code>Nat</code>参数. 以下的类型有用吗?<pre><code>(claim peas
  (Π ((how-many-peas Nat))
    (Vec Atom how-many-peas)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 这个类型表达了作为<code>peas</code>的参数的豌豆数目依赖于其被索取的数目. 这样的类型被称为<em>依赖类型(dependent type)</em>.<p><code>peas</code>可以用<code>rec-Nat</code>写出来吗?</p></td><td class="middled"><sup>5</sup></td><td class="rightd">当然了.<pre class="dashed"><code>(define peas
  (λ (how-many-peas)
    (rec-Nat how-many-peas
      vecnil
      (λ (<span style="color: grey;"><math><mi mathvariant="script">l-1</mi></math></span> peas<sub><math><mi mathvariant="script">l-1</mi></math></sub>)
        (vec:: 'pea peas<sub><math><mi mathvariant="script">l-1</mi></math></sub>)))))</code></pre></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">依赖类型</div><p>由某个不是类型的东西所确定的类型被称为<em>依赖类型(dependent type)</em>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">这<code>peas</code>的定义并非表达式. 为了能够使用<code>rec-Nat</code>, base和step的参数<code>peas<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>必须具有相同的类型. 然而, 这里的<code>peas<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>可以是一个<code>(Vec Atom 29)</code>, 但是<code>vecnil</code>是一个<code>(Vec Atom 0)</code>.<p>换言之, 当类型依赖于作为target的<code>Nat</code>时, <code>rec-Nat</code>就不能使用了.</p></td><td class="middled"><sup>6</sup></td><td class="rightd"><code>iter-Nat</code>如何呢?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>rec-Nat</code>可以做任何<code>iter-Nat</code>可以做的事情.</td><td class="middled"><sup>7</sup></td><td class="rightd">有什么更强大的东西可用吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">那被称为<code>ind-Nat</code>, 这是<q>induction on <code>Nat</code></q>的缩写.</td><td class="middled"><sup>8</sup></td><td class="rightd">什么是<code>ind-Nat</code>?</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>ind-Nat</code>和<code>rec-Nat</code>很像, 除了其允许base和step中几乎是答案的参数 (这里是<code>peas<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>) 的类型包括作为target的<code>Nat</code>.<p>换言之, <code>ind-Nat</code>用于依赖类型.</p></td><td class="middled"><sup>9</sup></td><td class="rightd">这里有一个被称为<code>how-many-peas</code>的<code>Nat</code>包含在类型<pre><code>(Vec Atom how-many-peas)</code></pre>里, 它是一个依赖类型吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 它依赖于<code>Nat</code> <code>how-many-peas</code>.<p>为了与依赖类型打交道, <code>ind-Nat</code>需要额外的参数: 为了使用<code>ind-Nat</code>, 有必要陈述base和step几乎是答案的参数的类型是<em>如何</em>依赖于作为target的<code>Nat</code>的.</p></td><td class="middled"><sup>10</sup></td><td class="rightd">这个额外的参数长什么样呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">这个额外的参数, 被称为<em>动机(motive)</em>, 可以是任意的<pre><code>(→ Nat <math><mi mathvariant="script">U</mi></math>)</code></pre>一个<code>ind-Nat</code>表达式的类型是动机应用于作为target的<code>Nat</code>的结果.<div class="comment"><b>注记.</b> 感谢Conor McBride (1973-).</div></td><td class="middled"><sup>11</sup></td><td class="rightd">所以说动机是一个函数, 其体是一个<math><mi mathvariant="script">U</mi></math>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此. 动机解释了<em>为什么</em>target要被消去.<p><code>peas</code>的动机是什么?</p></td><td class="middled"><sup>12</sup></td><td class="rightd">这是个好问题.<p>不过, 至少其类型是清晰的.<pre><code>(claim mot-peas
  (→ Nat <math><mi mathvariant="script">U</mi></math>))</code></pre></p><div class="comment"><b>注记.</b> <q>mot</q>读作<q>moat</q>.</div></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">对于依赖类型应使用<code>ind-Nat</code></div><p>当<code>rec-Nat</code>或者<code>ind-Nat</code>表达式的类型依赖于作为target的<code>Nat</code>时, 应使用<code>ind-Nat</code>而非<code>rec-Nat</code>. <code>ind-Nat</code>表达式的类型是动机 (motive) 应用于target的结果.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">以下就是<code>mot-peas</code>了.<pre><code>(define mot-peas
  (λ (k)
    (Vec Atom k)))</code></pre><code>(mot-peas zero)</code>的值是什么?</td><td class="middled"><sup>13</sup></td><td class="rightd">它应该是一个<math><mi mathvariant="script">U</mi></math>, 因而也是类型, 即<pre><code>(Vec Atom zero)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>peas</code>的base必然具有什么类型呢?</td><td class="middled"><sup>14</sup></td><td class="rightd">当然其类型必然为<pre><code>(Vec Atom zero)</code></pre>因为base的值是当<code>zero</code>为target时的值.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>peas</code>的base应该是什么呢?</td><td class="middled"><sup>15</sup></td><td class="rightd">其必然是<code>vecnil</code>, 因为<code>vecnil</code>是仅有的<pre><code>(Vec Atom zero)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">这个(类型)也是<code>(mot-peas zero)</code>.<p><code>rec-Nat</code>中的step的目的是什么?</p></td><td class="middled"><sup>16</sup></td><td class="rightd">在<code>rec-Nat</code>里, step的参数是<code>n-1</code>和几乎是答案的东西, 其为消去<code>n-1</code>得到的值.<p>给定<code>n-1</code>和几乎是答案的参数, step确定了<code>(add1 n-1)</code>时的值.</p></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>ind-Nat</code>里的step的参数也是<code>n-1</code>和几乎是答案的东西.<p>那么, 几乎是答案的东西的类型是什么?</p></td><td class="middled"><sup>17</sup></td><td class="rightd">几乎是答案的东西的类型是动机应用于<code>n-1</code>的结果, 因为几乎是答案的东西是target为<code>n-1</code>时的值.</td></tr></table><table class="dialogue"><tr><td class="leftd">对于target <code>(add1 n-1)</code>而言, 值的类型是什么?</td><td class="middled"><sup>18</sup></td><td class="rightd">一个<code>ind-Nat</code>表达式的类型动机应用于target的结果.</td></tr></table><table class="dialogue"><tr><td class="leftd">如果动机是<math><mi mathvariant="italic">mot</mi></math>, 那么step的类型为<pre><code>(Π ((n-1 Nat))
  (→ (<math><mi mathvariant="italic">mot</mi></math> n-1)
    (<math><mi mathvariant="italic">mot</mi></math> (add1 n-1))))</code></pre></td><td class="middled"><sup>19</sup></td><td class="rightd">举一个<code>ind-Nat</code>的step的例子呢?</td></tr></table><table class="dialogue"><tr><td class="leftd">以下是<code>peas</code>的step.<pre><code>(claim step-peas
  (Π ((<math><mi mathvariant="script">l-1</mi></math> Nat))
    (→ (mot-peas <math><mi mathvariant="script">l-1</mi></math>)
      (mot-peas (add1 <math><mi mathvariant="script">l-1</mi></math>)))))
(define step-peas
  (λ (<span style="color: grey;"><math><mi mathvariant="script">l-1</mi></math></span>)
    (λ (peas<sub><math><mi mathvariant="script">l-1</mi></math></sub>)
      (vec:: 'pea peas<sub><math><mi mathvariant="script">l-1</mi></math></sub>))))</code></pre></td><td class="middled"><sup>20</sup></td><td class="rightd">为什么<code>mot-peas</code>在<code>step-peas</code>的类型里出现了两次?</td></tr></table><table class="dialogue"><tr><td class="leftd">好问题.<p><code>(mot-peas <math><mi mathvariant="script">l-1</mi></math>)</code>的值是什么?</p></td><td class="middled"><sup>21</sup></td><td class="rightd">是<code>(Vec Atom <math><mi mathvariant="script">l-1</mi></math>)</code>.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>ind-Nat</code>之律</div><p>如果<math><mi mathvariant="italic">target</mi></math>是一个<code>Nat</code>, <math><mi mathvariant="italic">mot</mi></math>是一个<pre><code>(→ Nat <math><mi mathvariant="script">U</mi></math>)</code></pre><math><mi mathvariant="italic">base</mi></math>是一个<code>(<math><mi mathvariant="italic">mot</mi></math> zero)</code>, 而<math><mi mathvariant="italic">step</mi></math>是一个<pre><code>(Π ((n-1 Nat))
  (→ (<math><mi mathvariant="italic">mot</mi></math> n-1)
    (<math><mi mathvariant="italic">mot</mi></math> (add1 n-1))))</code></pre>那么<pre><code>(ind-Nat <math><mi mathvariant="italic">target</mi></math>
  <math><mi mathvariant="italic">mot</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>是一个<code>(<math><mi mathvariant="italic">mot</mi></math> <math><mi mathvariant="italic">target</mi></math>)</code>.</p><div class="tcomment"><b>译注.</b> 这里的变量<code>n-1</code>其实可以是任意的, 并且从理论上来说<math><mi mathvariant="italic">mot</mi></math>里不应该存在<code>n-1</code>的自由出现.</div></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>ind-Nat</code>之第一诫</div><p><code>ind-Nat</code>表达式<pre><code>(ind-Nat zero
  <math><mi mathvariant="italic">mot</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>和<math><mi mathvariant="italic">base</mi></math>是相同的<code>(<math><mi mathvariant="italic">mot</mi></math> zero)</code>.</p></blockquote></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>ind-Nat</code>之第二诫</div><p><code>ind-Nat</code>表达式<pre><code>(ind-Nat (add1 <math><mi>n</mi></math>)
  <math><mi mathvariant="italic">mot</mi></math>
  <math><mi mathvariant="italic">base</mi></math>
  <math><mi mathvariant="italic">step</mi></math>)</code></pre>和<pre><code>(<math><mi mathvariant="italic">step</mi></math> <math><mi>n</mi></math>
  (ind-Nat <math><mi>n</mi></math>
    <math><mi mathvariant="italic">mot</mi></math>
    <math><mi mathvariant="italic">base</mi></math>
    <math><mi mathvariant="italic">step</mi></math>))</code></pre>是相同的<code>(<math><mi mathvariant="italic">mot</mi></math> (add1 <math><mi>n</mi></math>))</code>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">这是<code>peas<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>的类型, 其描述了包含<math><mi mathvariant="script">l-1</mi></math>个豌豆的列表.<p><pre><code>(mot-peas (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>的值如何, 其又意味着什么?</p></td><td class="middled"><sup>22</sup></td><td class="rightd">其是<pre><code>(Vec Atom (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>其描述了包含<pre><code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code></pre>个豌豆的列表.</td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;">自然数上的归纳</div><p>通过给出零时的值以及将<math><mi>n</mi></math>时的值转换为<math><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></math>时的值的方法来构造对于任意自然数的值被称为<em>自然数上的归纳</em>.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">step必须要能够根据对于<code><math><mi mathvariant="script">l-1</mi></math></code>的值构造出对于<code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code>的值.<p>再次观察<code>step-peas</code>的类型, 其在文中到底为何意?</p></td><td class="middled"><sup>23</sup></td><td class="rightd">不论<code><math><mi mathvariant="script">l-1</mi></math></code>是什么<code>Nat</code>, <code>step-peas</code>总是接受一个<pre><code>(Vec Atom <math><mi mathvariant="script">l-1</mi></math>)</code></pre>然后产生一个<pre><code>(Vec Atom (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>这是通过<q>cons</q>一个<code>'pea</code>到前端完成的.</td></tr></table><table class="dialogue"><tr><td class="leftd">base将<pre><code>zero</code></pre>替换以<pre><code>vecnil</code></pre>因为<pre><code>vecnil</code></pre>是仅有的<pre><code>(Vec Atom zero)</code></pre><code>step-peas</code>将一个<code>add1</code>替换成什么呢?</td><td class="middled"><sup>24</sup></td><td class="rightd"><code>step-peas</code>将每个<code>add1</code>替换以一个<code>vec::</code>, 就像<a href="#step-length-def">第5章第34框</a>中的<code>length</code>将一个列表中的每个<code>::</code>替换以<code>add1</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">现在定义<code>peas</code>是可能的了, 只需使用<code>mot-peas</code>和<code>step-peas</code>.</td><td class="middled"><sup>25</sup></td><td class="rightd">以下是我们的定义.<pre><code>(define peas
  (λ (how-many-peas)
    (ind-Nat how-many-peas
      mot-peas
      vecnil
      step-peas)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(peas 2)</code>的值是什么?<p>以下是最初的两个计算步骤.<ol><li>| <pre style="display: inline-block"><code>(peas
  (add1
    (add1 zero)))</code></pre></li><li>| <pre style="display: inline-block"><code>(ind-Nat (add1
           (add1 zero))
  mot-peas
  vecnil
  step-peas)</code></pre></li><li>| <pre style="display: inline-block"><code>(step-peas (add1 zero)
  (ind-Nat (add1 zero)
    mot-peas
    vecnil
    step-peas))</code></pre></li></ol>现在, 请找出其值. 记得参数(有时)无需被求值.</p></td><td class="middled"><sup>26</sup></td><td class="rightd">以下就是了.<ol start="4"><li>| <pre style="display: inline-block"><code>(vec:: 'pea
  (ind-Nat (add1 zero)
    mot-peas
    vecnil
    step-peas))</code></pre></li></ol>而且, 我们最终可以找出其规范形式.<ol start="5"><li>| <pre style="display: inline-block"><code>(vec:: 'pea
  (step-peas zero
    (ind-Nat zero
      mot-peas
      vecnil
      step-peas)))</code></pre></li><li>| <pre style="display: inline-block"><code>(vec:: 'pea
  (vec:: 'pea
    (ind-Nat zero
      mot-peas
      vecnil
      step-peas)))</code></pre></li><li>| <pre style="display: inline-block"><code>(vec:: 'pea
  (vec:: 'pea vecnil))</code></pre></li></ol>这就是规范形式了.</td></tr></table><table class="dialogue"><tr><td class="leftd">如果动机的参数是黯淡的, 那么说明<code>ind-Nat</code>表现得就像是<code>rec-Nat</code>. 现在请定义一个函数<code>also-rec-Nat</code>, 其使用<code>ind-Nat</code>, 而行为正如<code>rec-Nat</code>.<pre><code>(claim also-rec-Nat
  (Π ((X U))
    (→ Nat
       X
       (→ Nat X X)
      X)))</code></pre></td><td class="middled"><sup>27</sup></td><td class="rightd">因为类型并不依赖于target, 所以<code><span style="color: grey;">k</span></code>是黯淡的.<pre><code>(define also-rec-Nat
  (λ (X)
    (λ (target base step)
      (ind-Nat target
        (λ (<span style="color: grey;">k</span>) X)
        base
        step))))</code></pre></td></tr></table><table class="dialogue" id="last-claim"><tr><td class="leftd">就像<code>first</code>可以找出一个列表的第一个元素, <code>last</code>可以找出最后一个元素.<p><code>last</code>的类型应该是什么?</p></td><td class="middled"><sup>28</sup></td><td class="rightd">此列表必然是非空的, 这意味着我们可以应用和<code>first</code>的类型相同的想法.<pre><code>(claim last
  (Π ((E <math><mi mathvariant="script">U</mi></math>)
      (<math><mi mathvariant="script">l</mi></math> Nat))
    (→ (Vec E (add1 <math><mi mathvariant="script">l</mi></math>))
      E)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">如果一个列表只包含一个<code>Atom</code>, 那么哪个<code>Atom</code>是最后一个呢?</td><td class="middled"><sup>29</sup></td><td class="rightd">显然只有一种可能.</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(last Atom zero
  (vec:: 'flour vecnil))</code></pre>的规范形式是什么?</td><td class="middled"><sup>30</sup></td><td class="rightd">以下是我的猜测. 这个问题没有意义, 因为列表包含的是一个元素而不是零个元素.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>(last Atom zero)</code>的类型是什么?<p>请记得Currying.</p></td><td class="middled"><sup>31</sup></td><td class="rightd"><code>(last Atom zero)</code>的类型为<pre><code>(→ (Vec Atom (add1 zero))
  Atom)</code></pre>因此, 前一个框中的问题, 实际上是有意义的!</td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(last Atom zero
  (vec:: 'flour vecnil))</code></pre>的规范形式是什么?</td><td class="middled"><sup>32</sup></td><td class="rightd">那必然是<code>'flour</code>.</td></tr></table><table class="dialogue"><tr><td class="leftd">的确如此.<p>使用这个洞察, <code>base-last</code>的类型是什么?</p></td><td class="middled"><sup>33</sup></td><td class="rightd">base在(作为target的)<code>Nat</code>为<code>zero</code>时使用.<pre><code>(claim base-last
  (Π ((E <math><mi mathvariant="script">U</mi></math>))
    (→ (Vec E (add1 zero))
      E)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>base-last</code>的定义是什么?</td><td class="middled"><sup>34</sup></td><td class="rightd">其使用<code>head</code>以获得一个<code>(Vec E (add1 zero))</code>中的唯一元素.<pre><code>(define base-last
  (λ (<span style="color: grey;">E</span>)
    (λ (es)
      (head es))))</code></pre><div class="tcomment"><b>译注.</b> 原文是<code>(Vec Atom (add1 zero))</code>, 这可能是一个笔误.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">这是我们第一次遇到base是一个函数的情况. 根据动机, base和step的几乎是答案的参数都是函数.<p>当base是一个函数而step将一个几乎是答案的函数转换为另一个函数时, 整个<code>ind-Nat</code>表达式当然也是在构造一个函数.</p><div class="tcomment"><b>译注.</b> 虽然实际的动机还没有给出, 但是读者应该料想得到.</div></td><td class="middled"><sup>35</sup></td><td class="rightd"><code>λ</code>表达式是值吗?</td></tr></table><table class="dialogue"><tr><td class="leftd">是的, 因为<code>λ</code>是一个构造子.</td><td class="middled"><sup>36</sup></td><td class="rightd">函数的确是值.</td></tr></table><table class="dialogue"><tr><td class="leftd"><code>ind-Nat</code>表达式的类型是动机应用于target的结果, 这个target是要被消去的<code>Nat</code>.<p>当抵达base时, 作为target的<code>Nat</code>是什么?</p></td><td class="middled"><sup>37</sup></td><td class="rightd">应该是<code>zero</code>, 这就是base的意义所在.</td></tr></table><table class="dialogue"><tr><td class="leftd">动机应用于<code>zero</code>的结果是base的类型.<p>请找出一个可以用作动机的表达式.</p></td><td class="middled"><sup>38</sup></td><td class="rightd"><pre><code>(Π ((<math><mi>E</mi></math> <math><mi mathvariant="script">U</mi></math>)
    (<math><mi>k</mi></math> Nat))
  (→ (Vec <math><mi>E</mi></math> (add1 <math><mi>k</mi></math>))
    <math><mi>E</mi></math>))</code></pre>怎么样呢? 将<math><mi>E</mi></math>填上列表元素的类型而<math><mi>k</mi></math>填上<code>zero</code>就得到了base的类型.<div class="tcomment"><b>译注.</b> 这里使用的元变量<math><mi>E</mi></math>和<math><mi>k</mi></math>实际上是不必要的, 或者说可以算是一种误用.</div></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>ind-Nat</code>的base的类型</div><p>在<code>ind-Nat</code>之中, base的类型是动机应用于作为target的<code>zero</code>的结果.</p></blockquote></td></tr></table><table class="dialogue"><tr><td class="leftd">很接近了, 但并不那么正确.<p><code>ind-Nat</code>的动机会被应用于<code>zero</code>, 但是应用一个<code>Π</code>表达式并无意义. <code>ind-Nat</code>的动机应该是一个函数, 而非函数的类型.</p></td><td class="middled"><sup>39</sup></td><td class="rightd">啊, 所以说那必然是<pre><code>(λ (E k)
  (→ (Vec E (add1 k))
    E))</code></pre>其可以被应用于列表元素的类型和<code>zero</code>以得到base的类型.</td></tr></table><table class="dialogue"><tr><td class="leftd">现在定义<code>last</code>的动机.<pre><code>(claim mot-last
  (→ <math><mi mathvariant="script">U</mi></math> Nat
    <math><mi mathvariant="script">U</mi></math>))</code></pre></td><td class="middled"><sup>40</sup></td><td class="rightd">以下就是了.<pre><code>(define mot-last
  (λ (E k)
    (→ (Vec E (add1 k))
      E)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(mot-last Atom)</code></pre>的类型和值分别是什么?</td><td class="middled"><sup>41</sup></td><td class="rightd">类型是<pre><code>(→ Nat <math><mi mathvariant="script">U</mi></math>)</code></pre>而值为<pre><code>(λ (k)
  (→ (Vec Atom (add1 k))
    Atom))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">这就像什么?</td><td class="middled"><sup>42</sup></td><td class="rightd"><a href="#twin-Atom">第4章第54框</a>里的<code>twin-Atom</code>. 应用<code>mot-last</code>于一个<math><mi mathvariant="script">U</mi></math>将产生一个适合用于<code>ind-Nat</code>的动机.</td></tr></table><table class="dialogue"><tr><td class="leftd">此时base的类型的值是什么? 这个类型即<code>(mot-last Atom zero)</code></td><td class="middled"><sup>43</sup></td><td class="rightd">应该是类型<pre><code>(→ (Vec Atom (add1 zero))
  Atom)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(mot-last Atom (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>的值是什么?</td><td class="middled"><sup>44</sup></td><td class="rightd">应该是<pre><code>(→ (Vec Atom (add1
               (add1 <math><mi mathvariant="script">l-1</mi></math>)))
  Atom)</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><code>last</code>的step的目的何在?</td><td class="middled"><sup>45</sup></td><td class="rightd"><code>last</code>的step将<code><math><mi mathvariant="script">l-1</mi></math></code>时的几乎答案转换为对于<code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code>的答案.<p>换言之, <code>last</code>的step将一个获取一个<pre><code>(Vec E (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>中的最后一个元素的函数变为一个获取一个<pre><code>(Vec E (add1 (add1 <math><mi mathvariant="script">l-1</mi></math>)))</code></pre>中的最后一个元素的函数. 为什么这里有两个<code>add1</code>?</p></td></tr></table><table class="dialogue"><tr><td class="leftd">外层的<code>add1</code>作为类型的一部分是为了保证送给<code>last</code>的列表至少拥有一个元素. 内层的<code>add1</code>来源于将<code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code>传递给<code>mot-last</code>.</td><td class="middled"><sup>46</sup></td><td class="rightd">外层的<code>add1</code>使得函数完全, 而内层的<code>add1</code>是出于<code>ind-Nat</code>之律.</td></tr></table><table class="dialogue"><tr><td class="leftd">step的类型是什么?</td><td class="middled"><sup>47</sup></td><td class="rightd">step的类型必然是<pre><code>(→ (→ (Vec E (add1 <math><mi mathvariant="script">l-1</mi></math>))
     E)
  (→ (Vec E (add1
              (add1 <math><mi mathvariant="script">l-1</mi></math>)))
    E))</code></pre>因为step必须要根据一个<pre><code>(mot-last E <math><mi mathvariant="script">l-1</mi></math>)</code></pre>构造出一个<pre><code>(mot-last E (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">这个类型如何以文字解释?</td><td class="middled"><sup>48</sup></td><td class="rightd">step将一个对于<pre><code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code></pre>而言的<pre><code>last</code></pre>函数转换为一个对于<pre><code>(add1 (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>而言的<pre><code>last</code></pre>函数.<div class="tcomment"><b>译注.</b> 原文分别是<code><math><mi mathvariant="script">l</mi></math></code>和<code>(add1 <math><mi mathvariant="script">l</mi></math>)</code>, 但是译者自作主张改成了以上的形式.</div></td></tr></table><table class="law"><tr><td><blockquote><div style="text-align: center;"><code>ind-Nat</code>的step的类型</div><p>在<code>ind-Nat</code>之中, step必须要接受两个参数: 某个类型为<code>Nat</code>的<code>n</code>和一个几乎是答案的东西, 其类型是动机<math><mi mathvariant="italic">mot</mi></math>应用于<code>n</code>的结果. step返回的答案的类型是动机应用于<code>(add1 n)</code>的结果. step的类型是:<pre><code>(Π ((n Nat))
  (→ (<math><mi mathvariant="italic">mot</mi></math> n)
    (<math><mi mathvariant="italic">mot</mi></math> (add1 n))))</code></pre></p></blockquote></td></tr></table><table class="dialogue" id="step-last"><tr><td class="leftd">以下是<code>step-last</code>的声明.<pre><code>(claim step-last
  (Π ((E U)
      (<math><mi mathvariant="script">l-1</mi></math> Nat))
    (→ (mot-last E <math><mi mathvariant="script">l-1</mi></math>)
      (mot-last E (add1 <math><mi mathvariant="script">l-1</mi></math>)))))</code></pre>现在请定义<code>step-last</code>.</td><td class="middled"><sup>49</sup></td><td class="rightd"><code>last<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>是几乎正确的函数, 但是只是对于拥有<code>(add1 <math><mi mathvariant="script">l-1</mi></math>)</code>个元素的列表而言的, 因而其接受拥有<code>(add1 (add1 <math><mi mathvariant="script">l-1</mi></math>))</code>个元素的列表的<code>tail</code>作为参数.<pre><code>(define step-last
  (λ (<span style="color: grey;">E</span> <span style="color: grey;"><math><mi mathvariant="script">l-1</mi></math></span>)
    (λ (last<sub><math><mi mathvariant="script">l-1</mi></math></sub>)
      (λ (es)
        (last<sub><math><mi mathvariant="script">l-1</mi></math></sub> (tail es))))))</code></pre><div class="tcomment"><b>译注.</b> 原文有误, 已修正.</div></td></tr></table><table class="dialogue"><tr><td class="leftd">内层的<code>λ</code>表达式的参数<code>es</code>的类型是什么?</td><td class="middled"><sup>50</sup></td><td class="rightd"><code>es</code>是一个<pre><code>(Vec E (add1 (add1 <math><mi mathvariant="script">l-1</mi></math>)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">为什么这是<code>es</code>的类型呢?</td><td class="middled"><sup>51</sup></td><td class="rightd">整个这内层的<code>λ</code>表达式的类型为<pre><code>(mot-last E (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>而这个类型和<pre><code>(→ (Vec E (add1
            (add1 <math><mi mathvariant="script">l-1</mi></math>)))
  E)</code></pre>是相同的类型. 因此, 该<code>λ</code>表达式的参数, 即<code>es</code>, 应该是一个<pre><code>(Vec E (add1 (add1 <math><mi mathvariant="script">l-1</mi></math>)))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd">聪明.<p><code>(tail es)</code>的类型是什么?</p></td><td class="middled"><sup>52</sup></td><td class="rightd"><code>(tail es)</code>的类型为<pre><code>(Vec E (add1 <math><mi mathvariant="script">l-1</mi></math>))</code></pre>其是几乎准备好的函数的适切参数的类型.<div class="tcomment"><b>译注.</b> 这个函数即<code>last<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>.</div></td></tr></table><table class="dialogue"><tr><td class="leftd"><a href="#step-last">第7章第49框</a>中的较外层<code>λ</code>表达式里的<code>last<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>的类型是什么?</td><td class="middled"><sup>53</sup></td><td class="rightd"><code>last<sub><math><mi mathvariant="script">l-1</mi></math></sub></code>的类型为<pre><code>(→ (Vec E (add1 <math><mi mathvariant="script">l-1</mi></math>))
  E)</code></pre>即<code>(mot-last E <math><mi mathvariant="script">l-1</mi></math>)</code>之值.</td></tr></table><table class="dialogue"><tr><td class="leftd">现在是时候定义<code>last</code>了, 其<code>claim</code>出现在<a href="#last-claim">第7章第28框</a>之中.</td><td class="middled"><sup>54</sup></td><td class="rightd">以下就是了.<pre><code>(define last
  (λ (E <math><mi mathvariant="script">l</mi></math>)
    (ind-Nat <math><mi mathvariant="script">l</mi></math>
      (mot-last E)
      (base-last E)
      (step-last E))))</code></pre></td></tr></table><table class="dialogue"><tr><td class="leftd"><pre><code>(last Atom 1
  (vec:: 'carrot
    (vec:: 'celery vecnil)))</code></pre>的规范形式是什么?</td><td class="middled"><sup>55</sup></td><td class="rightd"></td></tr></table><table class="dialogue"><tr><td class="leftd"></td><td class="middled"><sup>56</sup></td><td class="rightd"></td></tr></table><h2>课间: 一次吃一块</h2><table class="dialogue"><tr><td class="leftd"></td><td class="middled"><sup>1</sup></td><td class="rightd"></td></tr></table><table class="dialogue"><tr><td class="leftd"></td><td class="middled"><sup>2</sup></td><td class="rightd"></td></tr></table></body></html>